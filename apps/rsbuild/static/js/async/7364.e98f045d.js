"use strict";(self.webpackChunkrsbuild_website=self.webpackChunkrsbuild_website||[]).push([["7364"],{17072:function(e,n,s){s.r(n),s.d(n,{default:function(){return d}});var i=s(55367),o=s(26971);function r(e){let n=Object.assign({h1:"h1",a:"a",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",p:"p",h2:"h2",div:"div"},(0,o.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"sourceinclude",children:["source.include",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#sourceinclude",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type:"})," ",(0,i.jsx)(n.a,{href:"https://rspack.dev/config/module#condition",target:"_blank",rel:"noopener noreferrer",children:"Rspack.RuleSetCondition"})]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Default:"})}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const defaultInclude = [\n  {\n    and: [rootPath, { not: /[\\\\/]node_modules[\\\\/]/ }],\n  },\n  /\\.(?:ts|tsx|jsx|mts|cts)$/,\n];\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"source.include"})," is used to specify additional JavaScript files that need to be compiled."]}),"\n",(0,i.jsx)(n.p,{children:"To avoid redundant compilation, by default, Rsbuild only compiles JavaScript files in the current directory and TypeScript and JSX files in all directories. It does not compile JavaScript files under node_modules."}),"\n",(0,i.jsxs)(n.p,{children:["Through the ",(0,i.jsx)(n.code,{children:"source.include"})," config, you can specify directories or modules that need to be compiled by Rsbuild. The usage of ",(0,i.jsx)(n.code,{children:"source.include"})," is consistent with ",(0,i.jsx)(n.a,{href:"https://rspack.dev/config/module#ruleinclude",target:"_blank",rel:"noopener noreferrer",children:"Rule.include"})," in Rspack, which supports passing in strings or regular expressions to match the module path."]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import path from 'node:path';\n\nexport default {\n  source: {\n    include: [path.resolve(__dirname, '../other-dir')],\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"compile-npm-packages",children:["Compile npm Packages",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compile-npm-packages",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"A typical usage scenario is to compile npm packages under node_modules, because some third-party dependencies have ESNext syntax, which may cause them to fail to run on low-version browsers. You can solve the problem by using this config to specify the dependencies that need to be compiled."}),"\n",(0,i.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,i.jsx)(n.div,{className:"rspress-directive-title",children:"TIP"}),(0,i.jsx)(n.div,{className:"rspress-directive-content",children:(0,i.jsxs)(n.p,{children:["If you are unsure which third-party dependencies in node_modules contain ESNext syntax, you can use the ",(0,i.jsx)(n.a,{href:"https://github.com/rspack-contrib/rsbuild-plugin-check-syntax",target:"_blank",rel:"noopener noreferrer",children:"@rsbuild/plugin-check-syntax"})," for checking. The plugin can help you find the modules that contain ESNext syntax.\n"]})})]}),"\n",(0,i.jsxs)(n.p,{children:["Take ",(0,i.jsx)(n.code,{children:"query-string"})," as an example, you can add the following config:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import path from 'node:path';\n\nexport default {\n  source: {\n    include: [\n      // Method 1:\n      // First get the path of the module by require.resolve\n      // Then pass path.dirname to point to the corresponding directory\n      path.dirname(require.resolve('query-string')),\n      // Method 2:\n      // Match by regular expression\n      // All paths containing `node_modules/query-string/` will be matched\n      /node_modules[\\\\/]query-string[\\\\/]/,\n    ],\n  },\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:'The above two methods match the absolute paths of files using "path prefixes" and "regular expressions" respectively. It is worth noting that all referenced modules in the project will be matched. Therefore, you should avoid using overly loose values for matching to prevent compilation performance issues or compilation errors.'}),"\n",(0,i.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,i.jsx)(n.div,{className:"rspress-directive-title",children:"TIP"}),(0,i.jsx)(n.div,{className:"rspress-directive-content",children:(0,i.jsxs)(n.p,{children:["In the regular expression example above, we use ",(0,i.jsx)(n.code,{children:"[\\\\/]"})," to match the path separator because different operating systems use different path separators. Using ",(0,i.jsx)(n.code,{children:"[\\\\/]"})," ensures that the paths can be matched in macOS, Linux and Windows.\n"]})})]}),"\n",(0,i.jsxs)(n.h2,{id:"compile-sub-dependencies",children:["Compile Sub Dependencies",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compile-sub-dependencies",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["When you compile an npm package via ",(0,i.jsx)(n.code,{children:"source.include"}),", Rsbuild will only compile the matching module by default, not the ",(0,i.jsx)(n.strong,{children:"Sub Dependencies"})," of the module."]}),"\n",(0,i.jsxs)(n.p,{children:["Take ",(0,i.jsx)(n.code,{children:"query-string"})," for example, it depends on the ",(0,i.jsx)(n.code,{children:"decode-uri-component"})," package, which also has ESNext code, so you need to add the ",(0,i.jsx)(n.code,{children:"decode-uri-component"})," package to ",(0,i.jsx)(n.code,{children:"source.include"})," as well."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export default {\n  source: {\n    include: [\n      /node_modules[\\\\/]query-string[\\\\/]/,\n      /node_modules[\\\\/]decode-uri-component[\\\\/]/,\n    ],\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"compile-libraries-in-monorepo",children:["Compile Libraries in Monorepo",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compile-libraries-in-monorepo",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["When developing in Monorepo, if you need to refer to the source code of other libraries in Monorepo, you can add the corresponding library to ",(0,i.jsx)(n.code,{children:"source.include"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import path from 'node:path';\n\nconst packagesDir = path.resolve(__dirname, '../../packages');\n\nexport default {\n  source: {\n    include: [\n      // Compile all files in Monorepo's package directory\n      // It is recommended to exclude the node_modules\n      {\n        and: [packagesDir, { not: /[\\\\/]node_modules[\\\\/]/ }],\n      },\n    ],\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"matching-symlink",children:["Matching Symlink",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#matching-symlink",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["If you match a module that is symlinked to the current project, then you need to match the ",(0,i.jsx)(n.strong,{children:"real path"})," of the module, not the symlinked path."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, if you symlink the ",(0,i.jsx)(n.code,{children:"packages/foo"})," path in Monorepo to the ",(0,i.jsx)(n.code,{children:"node_modules/foo"})," path of the current project, you need to match the ",(0,i.jsx)(n.code,{children:"packages/foo"})," path, not the ",(0,i.jsx)(n.code,{children:"node_modules/foo"})," path."]}),"\n",(0,i.jsxs)(n.h2,{id:"compile-node_modules",children:["Compile node_modules",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compile-node_modules",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["In general, ",(0,i.jsx)(n.code,{children:"source.include"})," should not be used to compile the entire ",(0,i.jsx)(n.code,{children:"node_modules"})," directory. For example, the following configuration is not recommended:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export default {\n  source: {\n    include: [/[\\\\/]node_modules[\\\\/]/],\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This is because most of the npm packages in ",(0,i.jsx)(n.code,{children:"node_modules"})," are already compiled, and it is usually unnecessary to recompile them. Compiling the entire ",(0,i.jsx)(n.code,{children:"node_modules"})," will increase compilation time and may cause unexpected errors in certain npm packages, such as ",(0,i.jsx)(n.code,{children:"core-js"}),", which may result in runtime exceptions after compilation."]}),"\n",(0,i.jsx)(n.p,{children:"If you are willing to accept the increase in compilation time, you can use the following configuration to compile all JavaScript files but exclude `core-js':"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export default {\n  source: {\n    include: [{ not: /[\\\\/]core-js[\\\\/]/ }],\n  },\n};\n"})})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["en%2Fconfig%2Fsource%2Finclude.mdx"]={toc:[{text:"Compile npm Packages",id:"compile-npm-packages",depth:2},{text:"Compile Sub Dependencies",id:"compile-sub-dependencies",depth:2},{text:"Compile Libraries in Monorepo",id:"compile-libraries-in-monorepo",depth:2},{text:"Matching Symlink",id:"matching-symlink",depth:2},{text:"Compile node_modules",id:"compile-node_modules",depth:2}],title:"source.include",frontmatter:{}}}}]);