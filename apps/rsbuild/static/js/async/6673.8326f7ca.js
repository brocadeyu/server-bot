"use strict";(self.webpackChunkrsbuild_website=self.webpackChunkrsbuild_website||[]).push([["6673"],{46049:function(e,n,s){s.r(n),s.d(n,{default:function(){return o}});var r=s(55367),d=s(26971);function c(e){let n=Object.assign({h1:"h1",a:"a",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",p:"p",h2:"h2",div:"div"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"sourceinclude",children:["source.include",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#sourceinclude",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"类型："})," ",(0,r.jsx)(n.a,{href:"https://rspack.dev/zh/config/module#condition",target:"_blank",rel:"noopener noreferrer",children:"RuleSetCondition"})]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"默认值："})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const defaultInclude = [\n  {\n    and: [rootPath, { not: /[\\\\/]node_modules[\\\\/]/ }],\n  },\n  /\\.(?:ts|tsx|jsx|mts|cts)$/,\n];\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"source.include"})," 用于指定额外需要编译的 JavaScript 文件。"]}),"\n",(0,r.jsx)(n.p,{children:"为了避免二次编译，默认情况下，Rsbuild 只会编译当前目录下的 JavaScript 文件，以及所有目录下的 TypeScript 和 JSX 文件，不会编译 node_modules 下的 JavaScript 文件。"}),"\n",(0,r.jsxs)(n.p,{children:["通过 ",(0,r.jsx)(n.code,{children:"source.include"})," 配置项，可以指定需要 Rsbuild 额外进行编译的目录或模块。",(0,r.jsx)(n.code,{children:"source.include"})," 的用法与 Rspack 中的 ",(0,r.jsx)(n.a,{href:"https://rspack.dev/zh/config/module#ruleinclude",target:"_blank",rel:"noopener noreferrer",children:"Rule.include"})," 一致，支持传入字符串、正则表达式来匹配模块的路径。"]}),"\n",(0,r.jsx)(n.p,{children:"比如:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import path from 'node:path';\n\nexport default {\n  source: {\n    include: [path.resolve(__dirname, '../other-dir')],\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"编译-npm-包",children:["编译 npm 包",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编译-npm-包",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"比较典型的使用场景是编译 node_modules 下的 npm 包，因为某些第三方依赖存在 ESNext 的语法，这可能导致在低版本浏览器上无法运行，你可以通过该选项指定需要编译的依赖，从而解决此类问题。"}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"TIP"}),(0,r.jsx)(n.div,{className:"rspress-directive-content",children:(0,r.jsxs)(n.p,{children:["如果你不确定 node_modules 中的哪些第三方依赖存在 ESNext 的语法，可以使用 ",(0,r.jsx)(n.a,{href:"https://github.com/rspack-contrib/rsbuild-plugin-check-syntax",target:"_blank",rel:"noopener noreferrer",children:"@rsbuild/plugin-check-syntax"})," 进行检查，插件可以帮助你找到存在 ESNext 语法的模块。\n"]})})]}),"\n",(0,r.jsxs)(n.p,{children:["以 ",(0,r.jsx)(n.code,{children:"query-string"})," 为例，你可以做如下的配置："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import path from 'node:path';\n\nexport default {\n  source: {\n    include: [\n      // 方法一:\n      // 先通过 require.resolve 来获取模块的路径\n      // 再通过 path.dirname 来指向对应的目录\n      path.dirname(require.resolve('query-string')),\n      // 方法二:\n      // 通过正则表达式进行匹配\n      // 所有包含 `node_modules/query-string/` 的路径都会被匹配到\n      /node_modules[\\\\/]query-string[\\\\/]/,\n    ],\n  },\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:'上述两种方法分别通过 "路径前缀" 和 "正则表达式" 来匹配文件的绝对路径，值得留意的是，项目中所有被引用的模块都会经过匹配，因此你不能使用过于松散的值进行匹配，避免造成编译性能问题或编译异常。'}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"TIP"}),(0,r.jsx)(n.div,{className:"rspress-directive-content",children:(0,r.jsxs)(n.p,{children:["在上述正则表达式的例子中，我们使用 ",(0,r.jsx)(n.code,{children:"[\\\\/]"})," 来匹配路径分隔符，这是因为不同的操作系统使用了不同的路径分隔符，使用 ",(0,r.jsx)(n.code,{children:"[\\\\/]"})," 可以保证 macOS、Linux 和 Windows 的路径都被匹配到。\n"]})})]}),"\n",(0,r.jsxs)(n.h2,{id:"编译间接依赖",children:["编译间接依赖",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编译间接依赖",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["当你通过 ",(0,r.jsx)(n.code,{children:"source.include"})," 编译一个 npm 包时，Rsbuild 默认只会编译匹配到的模块，不会编译对应模块的",(0,r.jsx)(n.strong,{children:"子依赖"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["以 ",(0,r.jsx)(n.code,{children:"query-string"})," 为例，它依赖的 ",(0,r.jsx)(n.code,{children:"decode-uri-component"})," 包中同样存在 ESNext 代码，因此你需要将 ",(0,r.jsx)(n.code,{children:"decode-uri-component"})," 也加入到 ",(0,r.jsx)(n.code,{children:"source.include"})," 中："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default {\n  source: {\n    include: [\n      /node_modules[\\\\/]query-string[\\\\/]/,\n      /node_modules[\\\\/]decode-uri-component[\\\\/]/,\n    ],\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"编译-monorepo-中的其他库",children:["编译 Monorepo 中的其他库",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编译-monorepo-中的其他库",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 Monorepo 中进行开发时，如果需要引用 Monorepo 中其他库的 JavaScript 代码，也可以直接在 ",(0,r.jsx)(n.code,{children:"source.include"})," 进行配置:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import path from 'node:path';\n\nconst packagesDir = path.resolve(__dirname, '../../packages');\n\nexport default {\n  source: {\n    include: [\n      // 编译 Monorepo 的 package 目录下的所有文件\n      // 建议排除 node_modules\n      {\n        and: [packagesDir, { not: /[\\\\/]node_modules[\\\\/]/ }],\n      },\n    ],\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"匹配-symlink",children:["匹配 Symlink",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#匹配-symlink",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如果你匹配的模块是通过 symlink 链接到当前项目中的，那么需要匹配这个模块的",(0,r.jsx)(n.strong,{children:"真实路径"}),"，而不是 symlink 后的路径。"]}),"\n",(0,r.jsxs)(n.p,{children:["比如，你将 Monorepo 中的 ",(0,r.jsx)(n.code,{children:"packages/foo"})," 路径 symlink 到当前项目的 ",(0,r.jsx)(n.code,{children:"node_modules/foo"})," 路径下，则需要去匹配 ",(0,r.jsx)(n.code,{children:"packages/foo"})," 路径，而不是 ",(0,r.jsx)(n.code,{children:"node_modules/foo"})," 路径。"]}),"\n",(0,r.jsxs)(n.h2,{id:"编译-node_modules",children:["编译 node_modules",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编译-node_modules",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["通常来说，",(0,r.jsx)(n.code,{children:"source.include"})," 不应该用于编译整个 ",(0,r.jsx)(n.code,{children:"node_modules"})," 目录，比如下面的写法是不推荐的："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default {\n  source: {\n    include: [/[\\\\/]node_modules[\\\\/]/],\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这是因为 ",(0,r.jsx)(n.code,{children:"node_modules"})," 中的大部分 npm 包发布的已经是编译后的产物，通常没必要经过二次编译。如果你对整个 ",(0,r.jsx)(n.code,{children:"node_modules"})," 进行编译，会使编译时间增加，并且个别的 npm 包可能会产生不可预期的错误，比如 ",(0,r.jsx)(n.code,{children:"core-js"})," 被编译后会出现运行时异常。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果你可以接受编译时间的增加，可以通过下面的配置来编译所有 JavaScript 文件，但是需要排除 ",(0,r.jsx)(n.code,{children:"core-js"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default {\n  source: {\n    include: [{ not: /[\\\\/]core-js[\\\\/]/ }],\n  },\n};\n"})})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}let o=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["zh%2Fconfig%2Fsource%2Finclude.mdx"]={toc:[{text:"编译 npm 包",id:"编译-npm-包",depth:2},{text:"编译间接依赖",id:"编译间接依赖",depth:2},{text:"编译 Monorepo 中的其他库",id:"编译-monorepo-中的其他库",depth:2},{text:"匹配 Symlink",id:"匹配-symlink",depth:2},{text:"编译 node_modules",id:"编译-node_modules",depth:2}],title:"source.include",frontmatter:{}}}}]);