"use strict";(self.webpackChunkrsbuild_website=self.webpackChunkrsbuild_website||[]).push([["9741"],{69955:function(e,n,i){i.r(n),i.d(n,{default:function(){return d}});var r=i(55367),l=i(26971);function a(e){let n=Object.assign({h1:"h1",a:"a",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",p:"p",h2:"h2",h3:"h3"},(0,l.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"devlazycompilation",children:["dev.lazyCompilation",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#devlazycompilation",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"类型："})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type LazyCompilationOptions =\n  | boolean\n  | {\n      /**\n       * 为 entries 启用 lazy compilation\n       */\n      entries?: boolean;\n      /**\n       * 为 dynamic imports 启用 lazy compilation\n       */\n      imports?: boolean;\n      /**\n       * 指定哪些导入的模块应该被延迟编译\n       */\n      test?: RegExp | ((m: Module) => boolean);\n    };\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"默认值："})," ",(0,r.jsx)(n.code,{children:"false"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"版本："})," ",(0,r.jsx)(n.code,{children:">= 0.7.1"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["用于开启 lazy compilation（即按需编译），基于 Rspack 的 ",(0,r.jsx)(n.a,{href:"https://rspack.dev/zh/config/experiments#experimentslazycompilation",target:"_blank",rel:"noopener noreferrer",children:"experiments.lazyCompilation"})," 实现。"]}),"\n",(0,r.jsxs)(n.h2,{id:"介绍",children:["介绍",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#介绍",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Lazy compilation 是一个提升 dev 启动性能的良好手段，它可以按需编译模块，而不是在启动时就编译所有模块。这意味着开发者在启动 dev server 时，可以很快看到应用运行，并分次构建所需的模块。"}),"\n",(0,r.jsx)(n.p,{children:"尽管 Rspack 本身具备良好的性能，但是面对具有大量模块的应用，其整体构建时间仍然可能不够理想。这是因为应用中的模块需要经过不同 loader 的编译，包括 postcss-loader、sass-loader、vue-loader 等，它们都会产生额外的编译开销。"}),"\n",(0,r.jsx)(n.p,{children:"在启用 lazy compilation 的情况下，Rspack 仅会编译被请求的「页面入口」和「动态 import 模块」，这可以显著减少开发启动时编译的模块数量，从而提升启动时间。"}),"\n",(0,r.jsxs)(n.h2,{id:"局限性",children:["局限性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#局限性",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lazy compilation 仅对 dev 构建生效。"}),"\n",(0,r.jsx)(n.li,{children:"Lazy compilation 仍然是 Rspack 的实验性功能，在部分场景下，lazy compilation 可能无法按照预期工作，或是性能提升不明显。"}),"\n",(0,r.jsx)(n.li,{children:"Lazy compilation 依赖 Rspack 在本地启动的开发服务器，当你将某个域名代理到 localhost 进行开发时，它将无法正常工作。因此，如果你需要使用代理时，请禁用 lazy compilation。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"示例",children:["示例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#示例",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"启用-lazy-compilation",children:["启用 Lazy Compilation",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#启用-lazy-compilation",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default {\n  dev: {\n    lazyCompilation: true,\n  },\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"这等价于以下配置："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default {\n  dev: {\n    lazyCompilation: {\n      imports: true,\n      entries: true,\n    },\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"入口模块",children:["入口模块",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#入口模块",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["通过 ",(0,r.jsx)(n.code,{children:"lazyCompilation.entries"})," 来控制是否 lazy 编译入口模块："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default {\n  dev: {\n    lazyCompilation: {\n      entries: true,\n    },\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在启用 ",(0,r.jsx)(n.code,{children:"entries"})," 选项后，当你启动 dev server 时， Rsbuild 不会编译所有的页面，而是仅在访问特定的页面时，才对该页面进行编译。"]}),"\n",(0,r.jsx)(n.p,{children:"lazy 编译入口模块时，有以下注意事项："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"只适用于多页应用（MPA），对单页应用（SPA）没有优化效果。"}),"\n",(0,r.jsx)(n.li,{children:"当你访问一个页面时，你需要等待页面编译完成才能看到页面的内容。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"异步模块",children:["异步模块",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#异步模块",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["通过 ",(0,r.jsx)(n.code,{children:"lazyCompilation.imports"})," 来控制是否 lazy 编译 ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import",target:"_blank",rel:"noopener noreferrer",children:"dynamic import"})," 引入的异步模块："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export default {\n  dev: {\n    lazyCompilation: {\n      imports: true,\n    },\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["开启 ",(0,r.jsx)(n.code,{children:"imports"})," 选项后，所有的异步模块只有在被请求时才触发编译。如果你的项目是一个单页应用（SPA），并通过 dynamic import 进行了路由拆分，那么 dev 启动时间会有明显提升。"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let d=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["zh%2Fconfig%2Fdev%2Flazy-compilation.mdx"]={toc:[{text:"介绍",id:"介绍",depth:2},{text:"局限性",id:"局限性",depth:2},{text:"示例",id:"示例",depth:2},{text:"启用 Lazy Compilation",id:"启用-lazy-compilation",depth:3},{text:"入口模块",id:"入口模块",depth:3},{text:"异步模块",id:"异步模块",depth:3}],title:"dev.lazyCompilation",frontmatter:{}}}}]);