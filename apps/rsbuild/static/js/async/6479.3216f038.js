"use strict";(self.webpackChunkrsbuild_website=self.webpackChunkrsbuild_website||[]).push([["6479"],{15163:function(e,n,s){s.r(n),s.d(n,{default:function(){return l}});var i=s(55367),r=s(26971);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",h3:"h3",div:"div",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"静态资源内联",children:["静态资源内联",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#静态资源内联",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"静态资源内联是一种优化网页性能的方法，它指的是将静态资源直接内联到 HTML 或 JS 文件中，而不是使用外部文件引用的方式。这样做的好处是减少了浏览器发起的请求数，从而提高页面的加载速度。"}),"\n",(0,i.jsx)(n.p,{children:"不过，静态资源内联也有一些缺点，比如增加了单个文件的体积，可能会导致加载变慢。所以在实际应用中，需要根据具体情况来决定是否使用静态资源内联。"}),"\n",(0,i.jsx)(n.p,{children:"Rsbuild 默认会自动内联体积小于 4KiB 的静态资源，但有时候你可能需要手动控制某些特殊资源，让其强制内联或者强制不内联，这篇文档阐述了如何进行精确地控制静态资源内联行为。"}),"\n",(0,i.jsxs)(n.h2,{id:"自动内联",children:["自动内联",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自动内联",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"默认情况下，当图片、字体、媒体等类型的文件体积小于阈值（默认为 4KiB）时，Rsbuild 会将资源进行内联处理，资源内联后，会被转换成一个 Base64 编码的字符串，不再会发送独立的 HTTP 请求。当文件体积大于或等于该阈值时，则会被作为单独的资源文件，通过独立的 HTTP 请求来加载。"}),"\n",(0,i.jsxs)(n.p,{children:["自动内联的体积阈值可以通过 ",(0,i.jsx)(n.a,{href:"/config/output/data-uri-limit",children:"output.dataUriLimit"})," 配置项修改。例如，修改图片资源的阈值为 5000 字节，设置视频资源不内联："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export default {\n  output: {\n    dataUriLimit: {\n      image: 5000,\n      media: 0,\n    },\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"强制内联",children:["强制内联",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#强制内联",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["你可以通过在引入资源时添加 ",(0,i.jsx)(n.code,{children:"inline"})," URL 参数来强制内联该资源，无论该资源的体积是否小于阈值。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import React from 'react';\nimport img from './foo.png?inline';\n\nexport default function Foo() {\n  return <img src={img} />;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在上面这个例子中，",(0,i.jsx)(n.code,{children:"foo.png"})," 图片将始终被内联，无论该图片的大小是否大于阈值。"]}),"\n",(0,i.jsxs)(n.h3,{id:"从-css-文件中引用",children:["从 CSS 文件中引用",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#从-css-文件中引用",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["当你在 CSS 文件中引用静态资源时，同样可以通过 ",(0,i.jsx)(n.code,{children:"inline"})," 参数来强制内联资源。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".foo {\n  background-image: url('./icon.png?inline');\n}\n"})}),"\n",(0,i.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,i.jsx)(n.div,{className:"rspress-directive-title",children:"你真的需要强制内联吗？"}),(0,i.jsx)(n.div,{className:"rspress-directive-content",children:(0,i.jsx)(n.p,{children:"内联体积过大的资源时，会显著增加页面的白屏时间或首次可交互时间，这会损害用户体验。并且当你将一个静态资源多次内联到 CSS 文件中时，base64 内容会重复注入，导致产物体积增大。因此，请酌情使用强制内联。"})})]}),"\n",(0,i.jsxs)(n.h2,{id:"强制不内联",children:["强制不内联",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#强制不内联",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["当你想把一些资源始终作为单独的资源文件来处理，无论该资源的体积多小时，你可以添加 ",(0,i.jsx)(n.code,{children:"url"})," URL 参数来强制不内联该资源。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import React from 'react';\nimport img from './foo.png?url';\n\nexport default function Foo() {\n  return <img src={img} />;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在上面这个例子中，",(0,i.jsx)(n.code,{children:"foo.png"})," 图片将始终通过单独的资源文件加载，无论该图片的大小是否小于阈值。"]}),"\n",(0,i.jsxs)(n.h3,{id:"从-css-文件中引用-1",children:["从 CSS 文件中引用",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#从-css-文件中引用-1",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["当你在 CSS 文件中引用静态资源时，同样可以通过 ",(0,i.jsx)(n.code,{children:"url"})," 参数来强制不内联资源。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:".foo {\n  background-image: url('./icon.png?url');\n}\n"})}),"\n",(0,i.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,i.jsx)(n.div,{className:"rspress-directive-title",children:"你真的需要把资源排除内联吗？"}),(0,i.jsx)(n.div,{className:"rspress-directive-content",children:(0,i.jsx)(n.p,{children:"将资源排除内联将增加 Web App 需要加载的资源数量，这对于弱网环境，或是未开启 HTTP2 的场景下，将会降低资源加载效率，因此，请酌情使用强制不内联。"})})]}),"\n",(0,i.jsxs)(n.h2,{id:"内联-js-文件",children:["内联 JS 文件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内联-js-文件",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"除了将静态资源文件内联到 JS 文件里，Rsbuild 也支持将 JS 文件内联到 HTML 文件中。"}),"\n",(0,i.jsxs)(n.p,{children:["只需要开启 ",(0,i.jsx)(n.a,{href:"/config/output/inline-scripts",children:"output.inlineScripts"})," 配置项，构建生成的 JS 文件将不会被写入产物目录下，而是会直接内联到对应的 HTML 文件中。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export default {\n  output: {\n    inlineScripts: true,\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,i.jsx)(n.div,{className:"rspress-directive-title",children:"TIP"}),(0,i.jsx)(n.div,{className:"rspress-directive-content",children:(0,i.jsx)(n.p,{children:"内联 JS 文件可能会导致 HTML 单文件体积过大，并且不利于静态资源缓存，请酌情使用。"})})]}),"\n",(0,i.jsxs)(n.h2,{id:"内联-css-文件",children:["内联 CSS 文件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内联-css-文件",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"你也可以将 CSS 文件内联到 HTML 文件中。"}),"\n",(0,i.jsxs)(n.p,{children:["只需要开启 ",(0,i.jsx)(n.a,{href:"/config/output/inline-styles",children:"output.inlineStyles"})," 配置项，构建生成的 CSS 文件将不会被写入产物目录下，而是会直接内联到对应的 HTML 文件中。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export default {\n  output: {\n    inlineStyles: true,\n  },\n};\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"类型声明",children:["类型声明",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型声明",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["当你在 TypeScript 代码中使用 ",(0,i.jsx)(n.code,{children:"?inline"})," 和 ",(0,i.jsx)(n.code,{children:"?url"})," 等 URL 参数时，TypeScript 可能会提示该模块缺少类型定义："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"TS2307: Cannot find module './logo.png?inline' or its corresponding type declarations.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["此时你需要为这些 URL 参数添加类型声明，请在项目中创建 ",(0,i.jsx)(n.code,{children:"src/env.d.ts"})," 文件，并添加类型声明。"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["方法一：如果项目里安装了 ",(0,i.jsx)(n.code,{children:"@rsbuild/core"})," 包，你可以直接引用 ",(0,i.jsx)(n.code,{children:"@rsbuild/core"})," 提供的 ",(0,i.jsx)(n.a,{href:"/guide/basic/typescript#%E9%A2%84%E8%AE%BE%E7%B1%BB%E5%9E%8B",children:"预设类型"}),"："]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'/// <reference types="@rsbuild/core/types" />\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"方法二：手动添加需要的类型声明："}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"declare module '*?url' {\n  const content: string;\n  export default content;\n}\ndeclare module '*?inline' {\n  const content: string;\n  export default content;\n}\n"})})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["zh%2Fguide%2Foptimization%2Finline-assets.mdx"]={toc:[{text:"自动内联",id:"自动内联",depth:2},{text:"强制内联",id:"强制内联",depth:2},{text:"从 CSS 文件中引用",id:"从-css-文件中引用",depth:3},{text:"强制不内联",id:"强制不内联",depth:2},{text:"从 CSS 文件中引用",id:"从-css-文件中引用-1",depth:3},{text:"内联 JS 文件",id:"内联-js-文件",depth:2},{text:"内联 CSS 文件",id:"内联-css-文件",depth:2},{text:"类型声明",id:"类型声明",depth:2}],title:"静态资源内联",frontmatter:{}}}}]);