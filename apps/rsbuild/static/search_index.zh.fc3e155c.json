[{"id":182,"title":"Rsbuild Core","content":"#\n\n本章节描述了 Rsbuild 提供的一些核心方法。\n\n\ncreateRsbuild#\n\n创建一个 Rsbuild 实例对象。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\nOptions#\n\ncreateRsbuild 的第一个参数是一个 options 对象，你可以传入以下选项：\n\n\n\n * cwd：当前执行构建的根路径，默认值为 process.cwd()\n * environment：只构建指定的 environments。\n * rsbuildConfig：Rsbuild 配置对象。参考 配置总览 查看所有可用的配置项。\n\n\nloadConfig#\n\n加载 Rsbuild 配置文件。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n如果 cwd 目录下不存在 Rsbuild 配置文件，loadConfig 方法的返回值为 { content: {}, filePath: null }。\n\n\n指定配置文件#\n\n使用 path 选项加载 my-config.ts 配置文件：\n\n\n\n\n传入 meta 对象#\n\n加载配置文件，并传入自定义的 meta 对象：\n\n\n\n在 defineConfig 定义的配置函数中，你可以通过 meta 对象访问到 foo 变量：\n\n\n\n\nloadEnv#\n\n加载 .env 文件，并返回所有以 prefixes 开头的环境变量。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n该方法也会加载 .env.local 和 .env.[mode] 等文件，详见 环境变量。\n\nTIP\n\nRsbuild CLI 会自动调用 loadEnv() 方法，如果你在使用 Rsbuild CLI，可以通过 --env-mode 选项来设置 mode 参数。\n\n\nmergeRsbuildConfig#\n\n用于合并多份 Rsbuild 配置对象。\n\nmergeRsbuildConfig\n函数接收多个配置对象作为参数，它会将每一个配置对象进行深层合并，自动将多个函数项合并为顺序执行的函数数组，返回一个合并后的配置对象。\n\n * 类型：\n\n\n\n\n基础示例#\n\n\n\n> 该方法不会修改入参中的 config 对象。\n\n\n合并规则#\n\n除了深层合并外，mergeRsbuildConfig 函数还会对部分选项进行特殊处理。\n\n比如 tools.rspack 可以被设置为一个函数，当多份配置对象都包含 tools.rspack 时，mergeRsbuildConfig\n不会简单地保留最后一个函数。相反，它会将所有的 tools.rspack 函数或对象合并到一个数组中。\n\n\n\n在以上示例中，合并后的配置为以下形式，该数组首先包含了一个对象 { someOption: true }，然后是按合并顺序排列的两个函数。\n\n数组中的每一项会依次执行，并且上一个函数的输出将作为下一个函数的输入，最终生成一份 Rspack 配置。\n\n\n\n通过这种方法，我们可以确保合并多份配置对象时，相同的多个 tools.rspack 字段均能够生效。\n\n在 Rsbuild 中，大部分支持函数值的选项都使用上述规则，比如 tools.postcss、tools.less、tools.bundlerChain 等。\n\n\nlogger#\n\n用于输出格式统一的日志信息，基于 rslog。\n\n * 示例：\n\n\n\n\n自定义 Logger#\n\n你可以使用 logger.override 方法来覆盖默认 logger 的部分或全部方法：\n\n\n\n\nrspack#\n\n由 @rspack/core 导出的 rspack 对象。\n\n你可以直接从 @rsbuild/core 中引用 rspack 对象，而无须额外安装 @rspack/core 依赖。\n\n * 类型： Rspack\n * 示例：\n\n\n\n> 请参考 Rspack - JavaScript API 了解更多。\n\n\nversion#\n\n当前使用的 @rsbuild/core 的版本。\n\n * 类型： string\n * 示例：\n\n\n\n\nensureAssetPrefix#\n\nensureAssetPrefix 函数用于将给定的 assetPrefix 拼接到一个可能是 URL 的字符串前面。如果传入的字符串已经是一个完整的\nURL，则直接返回该字符串。\n\n * 类型：\n\n\n\n * 示例：\n\n","routePath":"/zh/api/javascript-api/core","lang":"zh","toc":[{"text":"createRsbuild","id":"creatersbuild","depth":2,"charIndex":30},{"text":"Options","id":"options","depth":3,"charIndex":87},{"text":"loadConfig","id":"loadconfig","depth":2,"charIndex":271},{"text":"指定配置文件","id":"指定配置文件","depth":3,"charIndex":403},{"text":"传入 meta 对象","id":"传入-meta-对象","depth":3,"charIndex":448},{"text":"loadEnv","id":"loadenv","depth":2,"charIndex":541},{"text":"mergeRsbuildConfig","id":"mergersbuildconfig","depth":2,"charIndex":743},{"text":"基础示例","id":"基础示例","depth":3,"charIndex":884},{"text":"合并规则","id":"合并规则","depth":3,"charIndex":920},{"text":"logger","id":"logger","depth":2,"charIndex":1361},{"text":"自定义 Logger","id":"自定义-logger","depth":3,"charIndex":1406},{"text":"rspack","id":"rspack","depth":2,"charIndex":1470},{"text":"version","id":"version","depth":2,"charIndex":1633},{"text":"ensureAssetPrefix","id":"ensureassetprefix","depth":2,"charIndex":1694}],"domain":"","frontmatter":{},"version":""},{"id":183,"title":"Environment API","content":"#\n\n在这里你可以找到所有与 environment 相关的 API。\n\n> 参考 多环境构建 了解更多。\n\n\nEnvironment Context#\n\nEnvironment context 是一个只读对象，提供一些和当前环境有关的上下文信息。\n\n在 Rsbuild 的 Plugin hooks 中，你可以通过 environment 或 environments 入参获取 environment\ncontext 对象。\n\n\n\n\nname#\n\n当前环境的唯一名称，用于区分和定位环境，对应于 environments 配置中的 key。\n\n * 类型： string\n * 示例：\n\n\n\n\nbrowserslist#\n\n当前环境设置的目标浏览器范围。详见 设置浏览器范围。\n\n * 类型： string[]\n * 示例：\n\n\n\n\nconfig#\n\n当前环境使用的 Rsbuild 配置（经过归一化处理）。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\ndistPath#\n\n构建产物输出目录的绝对路径，对应 RsbuildConfig 中的 output.distPath.root 配置项。\n\n * 类型： string\n * 示例：\n\n\n\n\nentry#\n\n构建入口对象，对应 source.entry 选项。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\nhtmlPaths#\n\nHTML 产物的路径信息。\n\n该 API 会返回一个对象，对象的 key 为 entry 名称，value 为 HTML 文件在产物目录下的相对路径。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\ntsconfigPath#\n\ntsconfig.json 文件的绝对路径，若项目中不存在 tsconfig.json 文件，则为 undefined。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\nEnvironment API#\n\nEnvironment API 包了一些与多环境构建相关的 API。\n\n你可以通过 rsbuild.createDevServer() 或 dev.setupMiddlewares 使用 environment\nAPI，这允许你在服务端获取特定环境下的构建产物信息。\n\n\n\n\ngetStats#\n\n获取当前环境的产物信息。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\nloadBundle#\n\n在服务端加载并执行构建产物。该方法会返回入口模块导出的内容。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\ngetTransformedHtml#\n\n获取经过编译和转换后的 HTML 模版内容。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n该方法会返回完整的 HTML 字符串，包含了所有通过 HTML 插件注入的资源和内容。","routePath":"/zh/api/javascript-api/environment-api","lang":"zh","toc":[{"text":"Environment Context","id":"environment-context","depth":2,"charIndex":55},{"text":"name","id":"name","depth":3,"charIndex":218},{"text":"browserslist","id":"browserslist","depth":3,"charIndex":298},{"text":"config","id":"config","depth":3,"charIndex":368},{"text":"distPath","id":"distpath","depth":3,"charIndex":428},{"text":"entry","id":"entry","depth":3,"charIndex":525},{"text":"htmlPaths","id":"htmlpaths","depth":3,"charIndex":582},{"text":"tsconfigPath","id":"tsconfigpath","depth":3,"charIndex":692},{"text":"Environment API","id":"environment-api-1","depth":2,"charIndex":-1},{"text":"getStats","id":"getstats","depth":3,"charIndex":946},{"text":"loadBundle","id":"loadbundle","depth":3,"charIndex":992},{"text":"getTransformedHtml","id":"gettransformedhtml","depth":3,"charIndex":1058}],"domain":"","frontmatter":{},"version":""},{"id":184,"title":"Rsbuild Instance","content":"#\n\n本章节描述了 Rsbuild 实例对象上所有的属性和方法。\n\n\nrsbuild.context#\n\nrsbuild.context 是一个只读对象，提供一些上下文信息。\n\n\ncontext.version#\n\n当前使用的 @rsbuild/core 版本。\n\n * 类型：\n\n\n\n\ncontext.rootPath#\n\n当前执行构建的根路径，对应调用 createRsbuild 时传入的 cwd 选项。\n\n * 类型：\n\n\n\n\ncontext.distPath#\n\n构建产物输出目录的绝对路径，对应 RsbuildConfig 中的 output.distPath.root 配置项。\n\n当有多个环境时，Rsbuild 会尝试获取所有环境的父 distPath 作为 context.distPath。\n\n如果要获取指定环境的输出目录的绝对路径，建议使用 environment.distPath。\n\n * 类型：\n\n\n\n\ncontext.cachePath#\n\n构建过程中生成的缓存文件所在的绝对路径。\n\n * 类型：\n\n\n\n\ncontext.devServer#\n\nDev server 相关信息，包含了当前 dev server 的 hostname 和端口号。\n\n * 类型：\n\n\n\n\ncontext.bundlerType#\n\n当前执行构建的构建工具类型。\n\n * 类型：\n\n\n\n> Rsbuild 内部支持切换到 webpack 进行对照测试，因此提供了该字段进行区分，通常你不需要使用此字段。\n\n\nrsbuild.environments#\n\n\ntarget#\n\n构建产物类型，对应 Rsbuild 的 output.target 配置。\n\n * 类型：\n\n\n\n\ntsconfigPath#\n\ntsconfig.json 文件的绝对路径，若项目中不存在 tsconfig.json 文件，则为 undefined。\n\n * 类型：\n\n\n\n\nrsbuild.build#\n\n调用 build 方法时，会执行一次生产模式构建。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\n监听文件变化#\n\n如果需要自动监听文件变化并重新执行构建，可以将 watch 参数设置为 true。\n\n\n\n在 watch 模式下，rsbuild.build() 会返回一个 close 方法，调用该方法将会结束监听：\n\n\n\n\nStats 对象#\n\n在非 watch 模式下，rsbuild.build() 会返回一个 Rspack 的 stats 对象：\n\n\n\n\n自定义 Compiler#\n\n个别情况下，你可能希望使用自定义的 compiler：\n\n\n\n\nrsbuild.startDevServer#\n\n启动本地 dev server。\n\n * 类型：\n\n\n\n * 示例：\n\n启动 dev server：\n\n\n\n成功启动 dev server 后，可以看到以下日志信息：\n\n\n\nstartDevServer 会返回以下参数：\n\n * urls：访问 dev server 的 URLs\n * port 实际监听的端口号\n * server：Server 实例对象\n\n\n\n\n自定义 Compiler#\n\n个别情况下，你可能希望使用自定义的 compiler：\n\n\n\n\n静默获取端口号#\n\n某些情况下，默认启动的端口号已经被占用，此时 Rsbuild 会自动递增端口号，直至找到一个可用端口。这个过程会输出提示日志，如果你不希望这段日志，可以将\ngetPortSilently 设置为 true。\n\n\n\n\nrsbuild.createDevServer#\n\nRsbuild 配备了一个内置的开发服务器，当你执行 rsbuild dev 时，将启动 Rsbuild dev\nserver，并提供页面预览、路由、模块热更新等功能。\n\n如果你希望将 Rsbuild dev server 集成到自定义的 server 中，可以通过该方法获取 dev server 的实例方法，按需进行调用。\n\n * 类型：\n\n\n\n * 示例：\n\n下面是一个在 express 中集成 Rsbuild DevServer 的例子:\n\n\n\n详细使用情况可参考：示例。\n\n如果你希望直接使用 Rsbuild DevServer 启动项目，可以直接使用 Rsbuild - startDevServer 方法。\nstartDevServer 实际上是以下代码的语法糖：\n\n\n\n\nconnectWebSocket#\n\nRsbuild 内置了 WebSocket 处理器以支持 HMR 功能：\n\n 1. 当用户通过浏览器访问页面时，会自动向服务器发起 WebSocket 连接请求。\n 2. Rsbuild 开发服务器检测到连接请求后，会指示内置的 WebSocket 处理器进行处理。\n 3. 浏览器与 Rsbuild WebSocket 处理器成功建立连接后，便可进行实时通信。\n 4. 每次重新编译完成后，Rsbuild WebSocket 处理器会通知浏览器。随后，浏览器向开发服务器发送 hot-update.(js|json)\n    请求，以加载编译后的新模块。\n\n当你使用自定义的 server 时，可能会遇到 HMR 连接报错的问题，这是因为自定义的 server 没有将 WebSocket 连接请求转发给\nRsbuild 的 WebSocket 处理器。此时需要通过 connectWebSocket 方法已使 Rsbuild 能够感知并处理来自浏览器的\nWebSocket 连接请求。\n\n\n\n\nrsbuild.preview#\n\n在本地启动 server 来预览生产模式构建的产物，需要在 rsbuild.build 方法之后执行。\n\n * 类型：\n\n\n\n * 示例：\n\n启动 Server：\n\n\n\npreview 会返回以下参数：\n\n * urls：访问 Server 的 URLs\n * port 实际监听的端口号\n * server：Server 实例对象\n\n\n\n\nrsbuild.createCompiler#\n\n创建一个 Rspack Compiler 实例；如果本次构建存在多个 environments，则返回值为 MultiCompiler。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n> 大部分场景下，你不需要使用该 API，除非需要进行自定义 dev server 等高级操作。\n\n\nrsbuild.addPlugins#\n\n注册一个或多个 Rsbuild 插件，可以被多次调用。\n\n该方法需要在开始编译前调用，如果在开始编译之后调用，则不会影响编译结果。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\nrsbuild.getPlugins#\n\n获取当前 Rsbuild 实例中注册的所有 Rsbuild 插件。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\nrsbuild.removePlugins#\n\n移除一个或多个 Rsbuild 插件，可以被多次调用。\n\n该方法需要在开始编译前调用，如果在开始编译之后调用，则不会影响编译结果。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\nrsbuild.isPluginExists#\n\n * 示例：\n\n\n\n\nrsbuild.initConfigs#\n\ninitConfigs 方法用于初始化 Rsbuild 内部的配置，并返回 Rsbuild 内部生成的 Rspack 配置。\n\n通常你不需要调用 initConfigs 方法，因为调用 rsbuild.build、rsbuild.startDevServer 等方法时会自动调用\ninitConfigs。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\nrsbuild.inspectConfig#\n\ninspectConfig 方法通常用于调试 Rsbuild 内部的配置，它会返回 Rsbuild 内部生成的 Rsbuild 配置和 Rspack\n配置，将它们序列化为字符串，并支持写入到磁盘上。\n\n如果你需要在构建过程中查看 Rsbuild 和 Rspack 配置，可以使用 调试模式，也可以通过\nonBeforeBuild、onBeforeCreateCompile 等 hooks 来获取。\n\n * 类型：\n\n\n\n\n示例#\n\n拿到字符串格式的 configs 内容：\n\n\n\n直接将配置内容写入到磁盘上：\n\n\n\n\n输出路径#\n\n你可以通过 outputPath 来设置输出目录，默认为 output.distPath.root 的值。\n\n当 outputPath 是一个相对路径时，会相对于 output.distPath.root 的值进行拼接。你也可以将 outputPath\n设置为一个绝对路径，此时会直接将文件写入到该路径下。比如：\n\n\n\n\nrsbuild.onBeforeCreateCompiler#\n\n * 示例：\n\n\n\n\nrsbuild.onAfterCreateCompiler#\n\n * 示例：\n\n\n\n\nrsbuild.onBeforeBuild#\n\n * 示例：\n\n\n\n\nrsbuild.onAfterBuild#\n\n * 示例：\n\n\n\n\nrsbuild.onCloseBuild#\n\n * 示例：\n\n\n\n\nrsbuild.onBeforeStartDevServer#\n\n * 示例：\n\n\n\n\nrsbuild.onAfterStartDevServer#\n\n * 示例：\n\n\n\n\nrsbuild.onCloseDevServer#\n\n * 示例：\n\n\n\n\nrsbuild.onBeforeStartProdServer#\n\n * 示例：\n\n\n\n\nrsbuild.onAfterStartProdServer#\n\n * 示例：\n\n\n\n\nrsbuild.onDevCompileDone#\n\n * 示例：\n\n\n\n\nrsbuild.onExit#\n\n * 示例：\n\n\n\n\nrsbuild.getRsbuildConfig#\n\n * 示例：\n\n\n\n\nrsbuild.getNormalizedConfig#\n\n * 示例：\n\n","routePath":"/zh/api/javascript-api/instance","lang":"zh","toc":[{"text":"rsbuild.context","id":"rsbuildcontext","depth":2,"charIndex":34},{"text":"context.version","id":"contextversion","depth":3,"charIndex":89},{"text":"context.rootPath","id":"contextrootpath","depth":3,"charIndex":143},{"text":"context.distPath","id":"contextdistpath","depth":3,"charIndex":217},{"text":"context.cachePath","id":"contextcachepath","depth":3,"charIndex":415},{"text":"context.devServer","id":"contextdevserver","depth":3,"charIndex":468},{"text":"context.bundlerType","id":"contextbundlertype","depth":3,"charIndex":550},{"text":"rsbuild.environments","id":"rsbuildenvironments","depth":2,"charIndex":659},{"text":"target","id":"target","depth":3,"charIndex":683},{"text":"tsconfigPath","id":"tsconfigpath","depth":3,"charIndex":742},{"text":"rsbuild.build","id":"rsbuildbuild","depth":2,"charIndex":830},{"text":"监听文件变化","id":"监听文件变化","depth":3,"charIndex":894},{"text":"Stats 对象","id":"stats-对象","depth":3,"charIndex":1008},{"text":"自定义 Compiler","id":"自定义-compiler","depth":3,"charIndex":1077},{"text":"rsbuild.startDevServer","id":"rsbuildstartdevserver","depth":2,"charIndex":1124},{"text":"自定义 Compiler","id":"自定义-compiler-1","depth":3,"charIndex":1333},{"text":"静默获取端口号","id":"静默获取端口号","depth":3,"charIndex":1380},{"text":"rsbuild.createDevServer","id":"rsbuildcreatedevserver","depth":2,"charIndex":1498},{"text":"connectWebSocket","id":"connectwebsocket","depth":3,"charIndex":1869},{"text":"rsbuild.preview","id":"rsbuildpreview","depth":2,"charIndex":2337},{"text":"rsbuild.createCompiler","id":"rsbuildcreatecompiler","depth":2,"charIndex":2526},{"text":"rsbuild.addPlugins","id":"rsbuildaddplugins","depth":2,"charIndex":2692},{"text":"rsbuild.getPlugins","id":"rsbuildgetplugins","depth":2,"charIndex":2801},{"text":"rsbuild.removePlugins","id":"rsbuildremoveplugins","depth":2,"charIndex":2878},{"text":"rsbuild.isPluginExists","id":"rsbuildispluginexists","depth":2,"charIndex":2990},{"text":"rsbuild.initConfigs","id":"rsbuildinitconfigs","depth":2,"charIndex":3026},{"text":"rsbuild.inspectConfig","id":"rsbuildinspectconfig","depth":2,"charIndex":3223},{"text":"示例","id":"示例","depth":3,"charIndex":3459},{"text":"输出路径","id":"输出路径","depth":3,"charIndex":3507},{"text":"rsbuild.onBeforeCreateCompiler","id":"rsbuildonbeforecreatecompiler","depth":2,"charIndex":3675},{"text":"rsbuild.onAfterCreateCompiler","id":"rsbuildonaftercreatecompiler","depth":2,"charIndex":3719},{"text":"rsbuild.onBeforeBuild","id":"rsbuildonbeforebuild","depth":2,"charIndex":3762},{"text":"rsbuild.onAfterBuild","id":"rsbuildonafterbuild","depth":2,"charIndex":3797},{"text":"rsbuild.onCloseBuild","id":"rsbuildonclosebuild","depth":2,"charIndex":3831},{"text":"rsbuild.onBeforeStartDevServer","id":"rsbuildonbeforestartdevserver","depth":2,"charIndex":3865},{"text":"rsbuild.onAfterStartDevServer","id":"rsbuildonafterstartdevserver","depth":2,"charIndex":3909},{"text":"rsbuild.onCloseDevServer","id":"rsbuildonclosedevserver","depth":2,"charIndex":3952},{"text":"rsbuild.onBeforeStartProdServer","id":"rsbuildonbeforestartprodserver","depth":2,"charIndex":3990},{"text":"rsbuild.onAfterStartProdServer","id":"rsbuildonafterstartprodserver","depth":2,"charIndex":4035},{"text":"rsbuild.onDevCompileDone","id":"rsbuildondevcompiledone","depth":2,"charIndex":4079},{"text":"rsbuild.onExit","id":"rsbuildonexit","depth":2,"charIndex":4117},{"text":"rsbuild.getRsbuildConfig","id":"rsbuildgetrsbuildconfig","depth":2,"charIndex":4145},{"text":"rsbuild.getNormalizedConfig","id":"rsbuildgetnormalizedconfig","depth":2,"charIndex":4183}],"domain":"","frontmatter":{},"version":""},{"id":185,"title":"Rsbuild Types","content":"#\n\n本章节描述了 Rsbuild 提供的一些类型定义。\n\n\nRsbuildInstance#\n\nRsbuild 实例的类型，对应 createRsbuild 方法的返回值。\n\n\n\n\nRsbuildConfig#\n\nRsbuild 配置的类型。\n\n\n\n你也可以引用 Rsbuild 配置中各个字段的类型定义：\n\n\n\n\nNormalizedConfig#\n\nRsbuild 配置归一化后的类型，对应 getNormalizedConfig 方法的返回值。\n\n\n\n你也可以引用归一化后的 Rsbuild 配置中各个字段的类型定义：\n\n\n\n\nNormalizedEnvironmentConfig#\n\n指定环境下的 Rsbuild 归一化配置类型，对应 getNormalizedConfig({ environment }) 方法的返回值。\n\n\n\n\nRsbuildContext#\n\nRsbuild 实例中 context 属性的类型定义。\n\n\n\n\nRsbuildPlugin#\n\nRsbuild 插件的类型。\n\n\n\n\nRsbuildPluginAPI#\n\nRsbuild 插件中，setup 函数传入的 api 对象的类型。\n\n\n\n\nRsbuildTarget#\n\nRsbuild 构建产物的类型。\n\n\n\n\nCreateRsbuildOptions#\n\ncreateRsbuild 方法的入参类型。\n\n\n\n\nInspectConfigOptions#\n\nrsbuild.inspectConfig 方法的入参类型。\n\n\n\n\nRspack#\n\n包含 @rspack/core 导出的所有类型，比如 Rspack.Configuration\n\n\n\n\nOthers#\n\n * OnExitFn\n * OnAfterBuildFn\n * OnAfterCreateCompilerFn\n * OnAfterStartDevServerFn\n * OnAfterStartProdServerFn\n * OnBeforeBuildFn\n * OnBeforeStartDevServerFn\n * OnBeforeStartProdServerFn\n * OnBeforeCreateCompilerFn\n * OnCloseDevServerFn\n * OnDevCompileDoneFn\n * ModifyRsbuildConfigFn\n * ModifyBundlerChainFn\n * ModifyRspackConfigFn\n * TransformFn,\n * TransformHandler\n * more...","routePath":"/zh/api/javascript-api/types","lang":"zh","toc":[{"text":"RsbuildInstance","id":"rsbuildinstance","depth":2,"charIndex":30},{"text":"RsbuildConfig","id":"rsbuildconfig","depth":2,"charIndex":91},{"text":"NormalizedConfig","id":"normalizedconfig","depth":2,"charIndex":158},{"text":"NormalizedEnvironmentConfig","id":"normalizedenvironmentconfig","depth":2,"charIndex":267},{"text":"RsbuildContext","id":"rsbuildcontext","depth":2,"charIndex":372},{"text":"RsbuildPlugin","id":"rsbuildplugin","depth":2,"charIndex":422},{"text":"RsbuildPluginAPI","id":"rsbuildpluginapi","depth":2,"charIndex":457},{"text":"RsbuildTarget","id":"rsbuildtarget","depth":2,"charIndex":515},{"text":"CreateRsbuildOptions","id":"creatersbuildoptions","depth":2,"charIndex":552},{"text":"InspectConfigOptions","id":"inspectconfigoptions","depth":2,"charIndex":602},{"text":"Rspack","id":"rspack","depth":2,"charIndex":660},{"text":"Others","id":"others","depth":2,"charIndex":721}],"domain":"","frontmatter":{},"version":""},{"id":186,"title":"JavaScript API","content":"#\n\nRsbuild 提供了一整套 JavaScript API，以便于开发者基于 Rsbuild 开发上层的工具或框架。\n\nRsbuild 的 JavaScript API 可以在 Node.js、Deno 或 Bun 中使用。\n\n\n接入示例#\n\n下面是接入 Rsbuild JavaScript API 的基本示例。\n\n\n1. 安装 Rsbuild#\n\n你需要安装 @rsbuild/core 包：\n\n\n2. 创建 Rsbuild 实例#\n\n你可以调用 createRsbuild 方法来创建一个 Rsbuild 实例对象：\n\n\n\ncreateRsbuild 方法提供了一些选项，你可以在 API - createRsbuild 中进一步了解。\n\n\n3. 调用 Rsbuild 实例方法#\n\nRsbuild 实例提供了与构建相关的各个方法，你可以根据实际场景来进行使用。\n\n在本地开发场景，建议使用 rsbuild.startDevServer 方法，调用后会启动本地 dev server。\n\n\n\n成功启动 dev server 后，可以看到以下日志信息：\n\n\n\n在生产环境部署场景，建议使用 rsbuild.build 方法，调用后会构建出生产模式产物。\n\n\n\n> 关于 Rsbuild 实例方法的更多介绍，请阅读 Rsbuild Instance 章节。\n\n通过以上三个步骤，你已经了解了 Rsbuild 基本的使用方法。接下来你可以通过 Rsbuild 插件和 Rsbuild 配置来对构建流程进行定制。\n\n\n导出格式#\n\nRsbuild 提供 ES modules 和 CommonJS 两种格式的导出：\n\n\n\n\n\n> 推荐使用更符合社区规范的 ES modules 格式。","routePath":"/zh/api/start/","lang":"zh","toc":[{"text":"接入示例","id":"接入示例","depth":2,"charIndex":117},{"text":"1. 安装 Rsbuild","id":"1-安装-rsbuild","depth":3,"charIndex":162},{"text":"2. 创建 Rsbuild 实例","id":"2-创建-rsbuild-实例","depth":3,"charIndex":203},{"text":"3. 调用 Rsbuild 实例方法","id":"3-调用-rsbuild-实例方法","depth":3,"charIndex":326},{"text":"导出格式","id":"导出格式","depth":2,"charIndex":660}],"domain":"","frontmatter":{},"version":""},{"id":187,"title":"社区","content":"#\n\n\n版本#\n\nRsbuild 遵循 Semantic Versioning 语义化版本规范。\n\n请查看 版本发布 了解更多。\n\n\n团队#\n\nRsbuild 的开发是由 ByteDance 的 Rspack 团队和社区贡献者驱动的。\n\n请查看 Rspack - 核心团队 来了解团队成员的信息。\n\n\n交流#\n\n你可以通过以下渠道与 Rsbuild 的开发者进行交流：\n\n * GitHub Discussions\n * Discord\n * Twitter\n\n\n贡献#\n\n欢迎参与 Rsbuild 贡献！\n\n请参考 Rsbuild Contribution Guide。\n\n\n博客#\n\n请访问 Rspack - 博客 来阅读我们的最新文章和发布公告。\n\n\n示例#\n\n请访问 rspack-contrib/rspack-examples 来查看或贡献 Rsbuild 的示例项目。","routePath":"/zh/community/","lang":"zh","toc":[{"text":"版本","id":"版本","depth":2,"charIndex":3},{"text":"团队","id":"团队","depth":2,"charIndex":66},{"text":"交流","id":"交流","depth":2,"charIndex":150},{"text":"贡献","id":"贡献","depth":2,"charIndex":231},{"text":"博客","id":"博客","depth":2,"charIndex":288},{"text":"示例","id":"示例","depth":2,"charIndex":328}],"domain":"","frontmatter":{},"version":""},{"id":188,"title":"总览","content":"#\n\n\n更新日志#\n\n请访问 GitHub - release 来查看 Rsbuild 每个版本的变更内容。\n\n\n语义化版本#\n\nRsbuild 遵循 Semantic Versioning 语义化版本规范。\n\n * 主版本号：包含不兼容的 API 变更。\n * 次版本号：包含向下兼容的功能性变更。\n * 修订号：包含向下兼容的问题修正。\n\n\n发版周期#\n\n * Rsbuild 通常会在每周发布若干个 patch 版本。","routePath":"/zh/community/releases/","lang":"zh","toc":[{"text":"更新日志","id":"更新日志","depth":2,"charIndex":3},{"text":"语义化版本","id":"语义化版本","depth":2,"charIndex":56},{"text":"发版周期","id":"发版周期","depth":2,"charIndex":172}],"domain":"","frontmatter":{},"version":""},{"id":189,"title":"Rsbuild 0.1 发布","content":"#\n\n> November 22, 2023\n\n\n\n我们很高兴地宣布 Rsbuild 0.1 的发布！\n\nRsbuild 是基于 Rspack 的构建工具，旨在成为增强版的 Rspack CLI，更加容易上手和开箱即用。Rsbuild 是 Webpack 应用迁移到\nRspack 的最佳方案，他能帮助你减少 90% 配置并获得 10 倍构建速度。\n\n\n🚀 性能#\n\nRsbuild 能够充分发挥 Rspack 的性能优势。由于 Rsbuild 内置了更多开箱即用的功能，因此性能数据会略微低于 Rspack。\n\n以下是构建 1000 个 React 组件的时间：\n\n> 以上数据基于 Farm 团队搭建的 benchmark，更多信息请参考 performance-compare。\n\n\n🔥 特性#\n\nRsbuild 具备以下特性：\n\n * 易于配置：Rsbuild 的目标之一，是为 Rspack 用户提供开箱即用的构建能力，使开发者能够在零配置的情况下开发 web 项目。同时，Rsbuild\n   提供一套语义化的构建配置，以降低 Rspack 配置的学习成本。\n\n * 性能优先：Rsbuild 集成了社区中基于 Rust 的高性能工具，包括 Rspack，SWC 和 Lightning\n   CSS，以提供一流的构建速度和开发体验。与基于 Webpack 的 Create React App 和 Vue CLI 等工具相比，Rsbuild\n   提供了 5 ~ 10 倍的构建性能，以及更轻量的依赖体积。\n\n * 插件生态：Rsbuild 内置一个轻量级的插件系统，提供一系列高质量的官方插件。此外，Rsbuild 兼容大部分的 webpack 插件和所有的\n   Rspack 插件，这意味着你可以在 Rsbuild 中使用社区或公司内沉淀的现有插件，而无须重写相关代码。\n\n * 产物稳定：Rsbuild 设计时充分考虑了构建产物的稳定性，它的开发和生产构建产物具备较强的一致性，并自动完成语法降级和 polyfill\n   注入。Rsbuild 也提供插件来进行 TypeScript 类型检查和产物语法检查，以避免线上代码的质量问题和兼容性问题。\n\n * 框架无关：Rsbuild 不与前端 UI 框架耦合，并通过插件来支持 React、Vue、Svelte、Solid、Preact\n   等框架，未来也计划支持社区中更多的 UI 框架。\n\n\n💡 下一步#\n\n目前 Rsbuild 仍在快速迭代中，并计划引入更多强大的新特性。\n\n比如，我们正在开发 Rsdoctor，这是一个强大的构建分析工具，可以用于所有 Rspack 和 Webpack 项目。它提供可视化\nUI，来帮助开发者分析项目中的构建耗时、重复依赖、代码转换过程等，使构建问题更加容易被定位和解决。\n\n\n\n我们将在近期发布 Rsdoctor 的第一个可用版本，后续 Rsbuild 会与 Rspack 同步迭代，并计划于 2024 年上半年发布 1.0 版本。","routePath":"/zh/community/releases/v0-1","lang":"zh","toc":[{"text":"🚀 性能","id":"-性能","depth":3,"charIndex":176},{"text":"🔥 特性","id":"-特性","depth":3,"charIndex":345},{"text":"💡 下一步","id":"-下一步","depth":3,"charIndex":1036}],"domain":"","frontmatter":{"published_at":"2023-11-22T08:00:00.000Z"},"version":""},{"id":190,"title":"Rsbuild 0.2 发布","content":"#\n\n> December 11, 2023\n\n\n\nRsbuild 0.2 版本包含一些 API 的不兼容更新，请参考当前文档进行升级。\n\n\nTargets#\n\n我们将 createRsbuild 方法的 target 移动至 rsbuild 配置对象中，这个改动使用户可以在 Rsbuild 配置文件中配置\ntargets。\n\n * before:\n\n\n\n * after:\n\n\n\n> 仅影响 JavaScript API。使用 Rsbuild CLI 的用户不需要做任何改变。\n\n\nEntry#\n\n删除已弃用的 source.entries 配置。\n\n自 Rsbuild 0.1.0 起，source.entries 已更名为 source.entry，我们在 Rsbuild\nv0.2.0中删除了source.entries` 配置。\n\n * before:\n\n\n\n * after:\n\n\n\n\nWrite to Disk#\n\ndev.writeToDisk 的默认值变更为 false.\n\n原因：\n\n * 减少文件系统开销，提升开发服务器性能。\n * 避免触发 UnoCSS 和其他工具的监听器。参考：#654。\n * 使默认行为与 webpack-dev-middleware 及其他社区开发服务器保持一致。\n\n用户可以手动开启写入磁盘：\n\n\n\n\nBabel 插件#\n\n@rsbuild/plugin-babel 将所有的 babel-loader 选项移动到 babelLoaderOptions:\n\n * before:\n\n\n\n * after:\n\n\n\n这种改变使我们能为 pluginBabel 添加更多选项，如 include 和 exclude。\n\n\nSource Map#\n\noutput.disableSourceMap 已经更名为 output.sourceMap.\n\n * before:\n\n\n\n * after:\n\n\n\nsource map 的默认值已更新，以提升构建性能。\n\n * 之前：在开发阶段生成 JS / CSS 的 source map，在生产阶段生成 JS 的 source map。\n * 之后：在开发阶段生成 JS 的 source map，在生产阶段不生成 source map。\n\n\nInject Styles#\n\n将 output.disableCssExtract 更名为 output.injectStyles 以更加直观：\n\n * before:\n\n\n\n * after:\n\n","routePath":"/zh/community/releases/v0-2","lang":"zh","toc":[{"text":"Targets","id":"targets","depth":2,"charIndex":70},{"text":"Entry","id":"entry","depth":2,"charIndex":242},{"text":"Write to Disk","id":"write-to-disk","depth":2,"charIndex":399},{"text":"Babel 插件","id":"babel-插件","depth":2,"charIndex":577},{"text":"Source Map","id":"source-map","depth":2,"charIndex":734},{"text":"Inject Styles","id":"inject-styles","depth":2,"charIndex":966}],"domain":"","frontmatter":{"published_at":"2023-12-11T08:00:00.000Z"},"version":""},{"id":191,"title":"Rsbuild 0.3 发布","content":"#\n\n> January 10, 2024\n\n\n\nRsbuild 0.3 版本升级 Rspack 到 0.5 并支持了模块联邦。此外，还包含一些 API 的不兼容更新，请参考当前文档进行升级。\n\n\nRspack 0.5#\n\n将 Rspack 升级到 v0.5.0，详情见：Rspack 0.5 发布公告\n\n主要变动：\n\n * 支持 Module Federation\n * 移除已弃用的 builtins 选项\n\n\nTOML / YAML 插件#\n\n在 JS 中导入 TOML 和 YAML 的需求并不常见，所以从 v0.3.0 开始，Rsbuild 核心将不再默认支持导入 TOML 和 YAML。\n\nTOML 和 YAML 将变成独立的插件：\n\n * TOML:\n\n\n\n * YAML:\n\n\n\n\nJavaScript API#\n\n包含一些 JavaScript API 的参数变更：\n\n * rsbuild.startDevServer 的 printURLs 选项已被弃用，改用 server.printUrls 代替。\n * rsbuild.startDevServer 的 logger 选项已被弃用，改用 logger.override() 代替。\n\n\nNode 产物#\n\n * 调整针对 Node.js 的默认 browserslist，从 node >= 14 变为 node >= 16。\n * output.distPath.server 的默认值从 'bundles' 改为 'server'。","routePath":"/zh/community/releases/v0-3","lang":"zh","toc":[{"text":"Rspack 0.5","id":"rspack-05","depth":2,"charIndex":98},{"text":"TOML / YAML 插件","id":"toml--yaml-插件","depth":2,"charIndex":207},{"text":"JavaScript API","id":"javascript-api","depth":2,"charIndex":349},{"text":"Node 产物","id":"node-产物","depth":2,"charIndex":532}],"domain":"","frontmatter":{"published_at":"2024-01-10T08:00:00.000Z"},"version":""},{"id":192,"title":"Rsbuild 0.4 发布","content":"#\n\n> February 06, 2024\n\n\n\nRsbuild 0.4 版本提供内置的模块联邦支持。此外，还包含一些 API 的不兼容更新，请参考当前文档进行升级。\n\n\n模块联邦配置#\n\nRsbuild 现在提供一个内置的 moduleFederation 选项，这将使得在 Rsbuild 中配置模块联邦变得更加容易。\n\n * 示例：\n\n\n\n当你使用该选项时，Rsbuild 会自动修改默认的 publicPath 和 splitChunks 配置，使模块联邦可以开箱即用。\n\n> 详见 RFC - Provide first-class support for Module Federation。\n\n\n插件 Hook 顺序#\n\n在 Rsbuild 插件中使用 hook 时，现在可以通过 order 字段来声明 hook 的顺序：\n\n\n\n> 详见 Plugin Hooks。\n\n\n重命名 disableFilenameHash#\n\noutput.disableFilenameHash 配置已被重命名为 output.filenameHash。\n\n * 更改前：\n\n\n\n * 更改后：\n\n\n\n\n移除 postcss-flexbugs-fixes#\n\nRsbuild 0.4 移除了内置的 postcss-flexbugs-fixes 插件。\n\n该插件用于修复 IE 10 / 11 中的一些 flex bug。考虑到现代浏览器已经不再存在这些 flex 问题，我们移除了这个插件以提高构建性能。\n\n如果你的项目需要兼容 IE 10 / 11 ，并且遇到了这些 flex 问题，你可以在 Rsbuild 中手动添加这个插件：\n\n * 安装插件：\n\n\n\n * 在 postcss.config.cjs 中注册插件：\n\n\n\n\nPure React 插件#\n\nReact 插件已移除对 antd v4 和 @arco-design/web-react 的默认 source.transformImport 配置。\n\n与组件库相关的配置应该在组件库相关的插件中提供，如 rsbuild-plugin-antd 或 rsbuild-plugin-arco，而 React\n插件会专注于提供 React 基础的能力。\n\n * 如果你的项目正在使用 antd v3 或 v4，你可以手动添加以下配置：\n\n\n\n * 如果你的项目正在使用 @arco-design/web-react v3 或 v4，你可以手动添加以下配置：\n\n\n\n\nJavaScript API#\n\nloadConfig 方法现在会返回配置内容和配置文件的路径：\n\n","routePath":"/zh/community/releases/v0-4","lang":"zh","toc":[{"text":"模块联邦配置","id":"模块联邦配置","depth":3,"charIndex":86},{"text":"插件 Hook 顺序","id":"插件-hook-顺序","depth":3,"charIndex":305},{"text":"重命名 disableFilenameHash","id":"重命名-disablefilenamehash","depth":3,"charIndex":394},{"text":"移除 postcss-flexbugs-fixes","id":"移除-postcss-flexbugs-fixes","depth":2,"charIndex":501},{"text":"Pure React 插件","id":"pure-react-插件","depth":2,"charIndex":764},{"text":"JavaScript API","id":"javascript-api","depth":2,"charIndex":1062}],"domain":"","frontmatter":{"published_at":"2024-02-06T08:00:00.000Z"},"version":""},{"id":193,"title":"Rsbuild 0.5 发布","content":"#\n\n> March 19, 2024\n\n\n\nRsbuild 0.5 是一个重要的里程碑，从该版本开始，Rsbuild 的绝大部分 API 已经达到稳定状态，我们预计在 2024 年 Q3 发布\nRsbuild v1.0。\n\n主要变更：\n\n * ⚡️ 支持启用 Lightning CSS 以加速 CSS 编译。\n * 🌟 支持基于新的 JavaScript API 实现自定义 server。\n * 🍭 重构 SVGR 插件以支持更丰富的用法。\n * 📍 支持自定义压缩选项。\n\n\n⚡️ 支持 Lightning CSS#\n\nLightning CSS 是一个基于 Rust 编写的高性能 CSS 解析、转译和压缩工具。它支持将许多现代的 CSS\n特性解析并转化为指定浏览器支持的语法，并提供更好的压缩比例。\n\nRsbuild 提供了 Lightning CSS 插件，用于按需开启 Lightning CSS 能力，并替代 Rsbuild 内置的\nPostCSS、autoprefixer 和 SWC CSS minimizer。\n\n只需要在 Rsbuild 配置中注册 Lightning CSS 插件，即可完成切换：\n\n\n\n在一个真实的大型 Web 应用中，我们接入了 Rsbuild Lightning CSS 插件，并使用 Rsdoctor 分析构建耗时的变化：\n\n * CSS 编译耗时由 8.4s 降低到 0.12s，提升 70 倍。\n * 整体构建耗时由 33.1s 降低到 25.4s，提升 30%。\n\n\n🌟 支持自定义 Server#\n\nRsbuild 现在支持将 dev server 替换为自定义的 server，并复用 Rsbuild 提供的页面预览、路由、模块热更新等功能。这将使得\nRsbuild 与其他 Node.js 框架结合使用变得更加容易。\n\n比如基于 express 实现自定义 server：\n\n\n\n详情可参考 Rsbuild - createDevServer。\n\n\n🍭 重构 SVGR 插件#\n\n在 0.5.0 之前的版本中，SVGR 插件的默认用法与 create-react-app 保持一致，允许以混合导入的形式使用 SVG：\n\n\n\n但这种做法存在两个问题：\n\n 1. 包体积增加：混合导入会导致单个 SVG 模块被编译为两种代码（即使部分导出没有被使用），这会增加产物的包体积。\n 2. 编译速度下降：混合导入会产生额外的编译开销。即使代码中未使用到 ReactComponent 导出，SVG 文件仍然会被 SVGR 编译。而 SVGR\n    是基于 Babel 实现的，性能开销较大。\n\n因此，我们重构了 @rsbuild/plugin-svgr 插件，支持通过 ?react query 来将 SVG 转换为 React\n组件，这种用法能够解决以上问题，且更符合当前社区的最佳实践。\n\n\n\nSVGR 插件现在支持在多种 SVGR 用法之间切换，如果项目需要使用之前的混合导入用法，可以手动开启 mixedImport 选项：\n\n\n\n\n📍 自定义压缩选项#\n\noutput.disableMinimize 选项已经被重命名为 output.minify，并允许自定义 JS 和 HTML 的压缩选项。\n\n\n\n使用 output.disableMinimize 的项目可以参考以下示例：\n\n\n\n> 详见 \"allow customize minify options\"。\n\n--------------------------------------------------------------------------------\n\n更多内容请参考：\n\n * Rsbuild 0.5.0 更新日志\n * Rsbuild 0.5.0 不兼容更新","routePath":"/zh/community/releases/v0-5","lang":"zh","toc":[{"text":"⚡️ 支持 Lightning CSS","id":"️-支持-lightning-css","depth":2,"charIndex":244},{"text":"🌟 支持自定义 Server","id":"-支持自定义-server","depth":2,"charIndex":665},{"text":"🍭 重构 SVGR 插件","id":"-重构-svgr-插件","depth":2,"charIndex":860},{"text":"📍 自定义压缩选项","id":"-自定义压缩选项","depth":2,"charIndex":1303}],"domain":"","frontmatter":{"published_at":"2024-03-19T08:00:00.000Z"},"version":""},{"id":194,"title":"Rsbuild 0.6 发布","content":"#\n\n> April 10, 2024\n\n\n\nRsbuild 0.6 已与 Rspack 0.6 同步发布！\n\n主要变更：\n\n * 升级 Rspack 0.6\n * 默认启用 error overlay\n * 支持 Vue JSX HMR\n * 全新的 transform 插件 API\n * 默认端口调整为 3000\n\n\n升级 Rspack 0.6#\n\nRsbuild 已将依赖的 Rspack 升级至 0.6 版本，并适配了 Rspack 0.6 包含的 CSS Modules 不兼容更新。\n\n在新版本中，Rspack 默认开启了新版 tree shaking 算法，使产物体积和产物稳定性得到显著提升。请参考 Rspack 0.6 发布公告 了解更多。\n\n\n默认启用 error overlay#\n\n从 Rsbuild 0.6 开始，dev.client.overlay 的默认值调整为 true。这意味着当出现编译错误时，Rsbuild 将默认弹出\nerror overlay 来展示错误信息：\n\n\n\n如果你不需要此功能，可以将 dev.client.overlay 设置为 false 来禁用：\n\n\n\n\n支持 Vue JSX HMR#\n\n@rsbuild/plugin-vue-jsx 现已支持 JSX HMR，当你在 Vue 3 应用中修改 JSX\n代码时，会自动触发模块热替换，并保留当前页面的状态。\n\n该功能由社区贡献者 @liyincode 实现 ❤️，并且发布为独立的 babel-plugin-vue-jsx-hmr 包，以便在 Rsbuild\n以外的项目中使用。\n\n\n全新的 transform API#\n\nRsbuild 插件现已支持 transform API，这可以理解为 Rspack loader 的一个轻量化实现，它提供了简单易用的\nAPI，并在底层自动调用 Rspack loader 进行代码转换。\n\n在 Rsbuild 插件中，你可以通过 api.transform 快速实现代码转换功能，能够满足大部分常见场景，而无须学习 Rspack loader\n的编写方法。\n\n比如匹配以 .pug 为后缀的模块，并转换为 JavaScript 代码：\n\n\n\n对于一些复杂的代码转换场景，api.transform 可能无法满足，此时你可以使用 Rspack loader 进行实现。\n\n\n默认端口调整为 3000#\n\nRsbuild 已将 server.port 的默认值从 8080 调整到 3000。\n\n端口 3000 通常用于 web 开发领域，也是 create-react-app 等工具默认使用的端口。通过更改默认端口为 3000，可以避免在使用 8080\n时可能遇到的端口冲突问题。\n\n如果你需要使用 8080 端口，可以手动设置：\n\n","routePath":"/zh/community/releases/v0-6","lang":"zh","toc":[{"text":"升级 Rspack 0.6","id":"升级-rspack-06","depth":2,"charIndex":161},{"text":"默认启用 error overlay","id":"默认启用-error-overlay","depth":2,"charIndex":332},{"text":"支持 Vue JSX HMR","id":"支持-vue-jsx-hmr","depth":2,"charIndex":507},{"text":"全新的 transform API","id":"全新的-transform-api","depth":2,"charIndex":696},{"text":"默认端口调整为 3000","id":"默认端口调整为-3000","depth":2,"charIndex":1012}],"domain":"","frontmatter":{"published_at":"2024-04-10T18:00:00.000Z"},"version":""},{"id":195,"title":"Rsbuild 0.7 发布","content":"#\n\n> May 28, 2024\n\n\n\nRsbuild 0.7 已与 Rspack 0.7 同步发布！\n\n这是 Rsbuild 1.0 版本发布前的最后一个 minor 版本，此后 Rspack 团队将投入到 1.0 版本的开发中，并致力于尽快推出 Rspack /\nRsbuild 1.0 alpha 版本。\n\n在 Rsbuild 0.7 中，值得关注的变更有：\n\n * 支持 Storybook\n * 更快的 Sass 编译\n * 更好的 CSS 支持\n * CSS Modules 类型生成\n * ESM/CJS 导出\n * 不兼容更新\n\n\n支持 Storybook#\n\nRsbuild 现已支持 Storybook！\n\nstorybook-builder-rsbuild 是基于 Storybook v8 和 Rsbuild 实现的 Storybook\nbuilder，能够快速构建你的 components 和 stories。\n\n\n\n * 对于使用 Rsbuild 的项目，现在你可以快速集成 Storybook，并复用已有的 Rsbuild 配置。\n * 对于使用 Storybook webpack builder 的项目，现在即可升级到 Rsbuild，并获得约 5 倍的构建性能提升。\n\n我们还提供了 storybook-react-rsbuild 和 storybook-vue3-rsbuild，用于支持 React 和 Vue 3。比如集成\nReact：\n\n\n\n\n\n> 更多用法请参考 storybook-rsbuild 仓库。\n\n\n更快的 Sass 编译#\n\n在 Rsbuild 0.7 中，Sass 编译速度提高了 3~10 倍，在大型项目项目中的性能提升尤为显著。\n\n以编译 Bootstrap 的 Sass 代码为例，Rsbuild 0.6 和 0.7 的构建时间对比：\n\n\n\n这得益于 Rsbuild 默认启用了 sass-embedded，sass-embedded 是一个围绕原生 Dart Sass 可执行文件的\nJavaScript wrapper，具备一致的 API 和更优秀的性能。\n\n此外，Rsbuild 还启用了 sass-loader 最新的 modern-compiler API，这能够开启 Sass 的 shared\nresources 能力，在编译多个文件时重复利用相同的 compiler 进程，从而提升构建速度。\n\n\n更好的 CSS 支持#\n\nRsbuild 现在使用 CssExtractRspackPlugin 来提取 CSS 到单独的文件中，而不是使用 experiments.css 配置来实现。\n\n这允许 Rsbuild 支持更多 CSS 特性，包括：\n\n * 支持在 Vue SFC 中使用\n   * 支持复杂的 CSS Modules :global() 语法\n   \n   \n   \n   * 支持更多的 CSS Modules 选项，如 cssModules.exportGlobals\n   * 现在你可以使用 tools.cssExtract 来配置 CssExtractRspackPlugin。\n   \n   \n   CSS Modules 类型生成#\n   \n   Rsbuild 0.7 新增了 Typed CSS Modules 插件，用于为项目中的 CSS Modules 文件生成类型声明文件。\n   \n   当你在 TypeScript 项目里使用 CSS Modules 时，默认的类型定义如下。它只能提供基本的类型支持，无法准确地提示出 CSS\n   Modules 导出了哪些类名。\n   \n   \n   \n   在使用 Typed CSS Modules 插件后，Rsbuild 会为项目中所有的 CSS Modules 生成类型声明文件，提供准确的类型提示。\n   \n   例如，创建 src/index.ts 和 src/index.module.css 两个文件：\n   \n   \n   \n   \n   \n   构建后，Rsbuild 会自动生成 src/index.module.css.d.ts 类型声明文件：\n   \n   \n   \n   此时再打开 src/index.ts 文件，可以看到 styles 对象已经具备了准确的类型。\n   \n   \n   ESM/CJS 导出#\n   \n   现在，Rsbuild 的所有包均提供了 ES modules 和 CommonJS 两种格式的导出，并在 package.json 中声明了\n   \"type\"=\"module\"`。\n   \n   \n   \n   这使你能够使用 import 或 require 来调用 Rsbuild 的 JavaScript API：\n   \n   \n   \n   ESM/CJS 互操作是一个棘手的问题，因此我们计划长期提供这两种格式，以便于更多用户使用。\n   \n   \n   不兼容更新#\n   \n   \n   升级 Rspack 0.7#\n   \n   Rsbuild 已将依赖的 Rspack 升级至 0.7 版本，并适配了其中包含的不兼容更新，通常你不会受到这些不兼容更新的影响。\n   \n   在新版本中，Rspack 支持了 lazy compilation，可以显著提升大型项目的 dev 启动速度。请参考 Rspack 0.7 发布公告\n   了解更多。\n   \n   在 Rsbuild 中，你可以使用 dev.lazyCompilation 来启用 lazy compilation。\n   \n   \n   Sass 和 Less 插件#\n   \n   Rsbuild 的 Sass 和 Less 插件现在是两个独立的 npm 包，而不是像之前一样内置在 @rsbuild/core\n   中，这允许用户可以按需启用 Sass 和 Less 编译能力。\n   \n   比如，对于使用 Tailwind CSS、CSS-in-JS 等 CSS 方案的项目，现在不再需要安装 Sass 和 Less 所需的依赖，这可以节省约\n   7MB 的磁盘空间。\n   \n   * 如果你的项目需要编译 .scss 或 .sass 文件，请安装并注册 @rsbuild/plugin-sass 插件：\n   \n   \n   \n   * 如果你的项目需要编译 .less 文件，请安装并注册 @rsbuild/plugin-less 插件：\n   \n   \n   \n   \n   dataUriLimit 默认值#\n   \n   output.dataUriLimit 的默认值从 10000 (10kB) 调整为 4096 (4KiB).\n   \n   这是因为目前更多的应用正在使用 HTTP 2.0，所以将资源分割成单独的文件会表现得更好。而且将超过 4KiB 的资源内联可能会使 JS\n   包体积过大，不利于缓存。\n   \n   如果你倾向于之前的默认设置，可以添加以下配置：\n   \n   ","routePath":"/zh/community/releases/v0-7","lang":"zh","toc":[{"text":"支持 Storybook","id":"支持-storybook","depth":2,"charIndex":274},{"text":"更快的 Sass 编译","id":"更快的-sass-编译","depth":2,"charIndex":680},{"text":"更好的 CSS 支持","id":"更好的-css-支持","depth":2,"charIndex":1042},{"text":"CSS Modules 类型生成","id":"css-modules-类型生成","depth":2,"charIndex":-1},{"text":"ESM/CJS 导出","id":"esmcjs-导出","depth":2,"charIndex":-1},{"text":"不兼容更新","id":"不兼容更新","depth":2,"charIndex":-1},{"text":"升级 Rspack 0.7","id":"升级-rspack-07","depth":3,"charIndex":-1},{"text":"Sass 和 Less 插件","id":"sass-和-less-插件","depth":3,"charIndex":-1},{"text":"dataUriLimit 默认值","id":"dataurilimit-默认值","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"published_at":"2024-05-28T18:00:00.000Z"},"version":""},{"id":196,"title":"Rsbuild 1.0 发布","content":"#\n\n> September 10, 2024\n\n\n\n我们很高兴地宣布 Rsbuild 1.0 已经正式发布！\n\n\n为什么是 Rsbuild#\n\n长期以来，使用 webpack 的开发者饱受两个问题的困扰：构建慢和配置复杂。\n\n我们使用 Rust 将 webpack 重写为 Rspack，解决了构建慢的问题。但为了兼容 webpack 生态，Rspack 保留了 webpack\n的配置和 API，这意味着它依然存在一定的复杂度和学习成本。\n\n\n生态的发展#\n\n在早期，webpack 生态中出现了一些优秀的工具，比如 Create React App（简称 CRA）和 Vue CLI，它们为 React 或 Vue\n应用提供最佳实践，隐藏了复杂的 webpack 配置。因此，许多 React 和 Vue 用户使用这些工具来创建应用，不需要从零开始配置 webpack。\n\n随着生态的发展，Next.js、Nuxt 和 Remix 等全栈 web 框架变得流行；Vite 推出后，作为一个轻量化的构建工具，也受到了众多开发者的青睐。而\nCRA、Vue CLI 则是逐渐停止了维护。\n\n当我们查看 webpack、CRA 和 Vue CLI 的 npm 下载量时，会发现仍然有大量项目在使用这些工具。例如，webpack 有约 2500\n万的周下载量，CRA 有近 300 万的周下载量。这些项目有很多是 CSR 应用，不需要使用全栈框架的 SSR 等特性；Vite\n看起来是一个不错的选择，但我们在字节跳动的项目中实践后发现，从 webpack 迁移到 Vite\n存在很高的成本，并且迁移带来了一些新问题，例如开发环境与生产环境的构建产物不一致、大型应用在开发过程中页面刷新缓慢等问题。\n\n对于 webpack 生态，我们发现了一个让人遗憾的事实：webpack 生态缺少一个易于使用且维护良好的构建工具，它既要像 CRA 和 Vue CLI\n一样对用户友好，能够很好地满足 CSR 应用开发的需求，又需要像 Vite 一样具备快速启动、插件化等特性。\n\n\nRsbuild 的诞生#\n\n在开发 Rspack 的过程中，我们意识到了上述问题，并决定在 Rspack 的基础上开发一个现代的构建工具 —— Rsbuild。\n\n\n\nRsbuild 是以 Rspack 为核心实现的，我们为 Rsbuild 设计了易于使用、TypeScript 友好的\nAPI，并内置一套精心设计的构建配置，使它既能充分发挥出 Rspack 的性能优势，也能解决配置复杂、上手成本高的问题。\n\n在实现 Rsbuild 的过程中，我们向社区中优秀的工具学习最佳实践，并聚焦于两个使用场景来设计 Rsbuild：\n\n * 作为一个轻量的构建工具：帮助开发者快速搭建 web 应用，为 CSR 应用提供开箱即用的支持。\n * 作为一个共享的基础设施：为上层工具和框架提供 JavaScript API 和 插件 API，允许开发者基于 Rsbuild\n   来开发属于自己的工具或框架，轻松实现 SSR、SSG 等特性。\n\n\n性能#\n\nRsbuild 是目前 webpack 和 Rspack 生态中最快的构建工具，下面是 Rsbuild 与 Create React\nApp、Vite、Rspack CLI 的对比：\n\n指标                     CREATE REACT APP   VITE (WITH SWC)   RSPACK CLI   RSBUILD   RSBUILD VS CRA\ndev 启动时间（1000 个模块）     5.47s              1.29s             0.66s        0.39s     快 14 倍\nbuild 构建时间（1000 个模块）   5.69s              1.39s             0.51s        0.27s     快 20 倍\nnpm 依赖数量               1241               15                283          14        减少 99%\nnpm 安装体积               146.6MB            56.3MB            75.1MB       59.1MB    减少 60%\n\n与 Rspack CLI 相比，Rsbuild 内置了更丰富的功能，同时具备更好的性能表现。\n\n这是因为 Rspack CLI 需要保持对 webpack-cli 的兼容性，它依赖了 webpack-dev-server，并提供与 webpack\n一致的默认行为，因此性能受到了一定限制。而 Rsbuild 是面向现代 web 开发设计的，我们为 Rsbuild 重新实现了更轻量的\nCLI、开发服务器和构建流程，使其具备更快的启动速度和更少的 npm 依赖。\n\n> 参考 Rsbuild 介绍 了解 Rsbuild 与 webpack、Vue CLI、Vite 的对比。\n\n\n谁在使用#\n\n在 Rspack 1.0 发布公告 中，我们介绍了 Rspack 正在取得快速增长，这其中约有一半的 Rspack 用户已经在使用\nRsbuild，并给予我们很多正向的反馈。\n\n在字节跳动，我们将 Rsbuild 作为内部研发框架的基石，支持了数千个 web 项目，这些项目涵盖了不同的使用场景，包括 desktop web\n应用、mobile web 应用、跨平台 web 应用、文档站等。\n\n在社区中，我们开源了基于 Rsbuild 的高性能工具链，包括静态站点生成器 Rspress，library 开发工具 Rslib，React 全栈框架\nModern.js，Storybook Rsbuild。得益于 Rsbuild 的可扩展性，这些工具能够灵活地集成 Rsbuild，并与它共享插件生态。\n\n在 Rsbuild 1.0 发布后，我们也计划与 Remix 等优秀的团队一起探索，使 Rsbuild 能够与更多 web 框架集成。\n\n\n插件生态#\n\nRsbuild 的插件生态正在不断发展，目前社区中已经有超过 50 个 Rsbuild 插件。我们通过插件提供了一些高级特性，以支持生产级应用的开发，例如\n类型检查、产物语法检查、静态资源重试。此外，受益于 Rspack 对 webpack 的兼容性，Rsbuild 也支持使用大部分 webpack 插件。\n\n与 webpack 或 Rspack 相比，Rsbuild 的插件 API 更加简洁和容易上手，使开发者能够轻松地开发插件来满足自己的需求。\n\n例如，我们来实现一个插件，它的功能是输出一个文件到产物目录，在 Rspack 和 Rsbuild 中的实现对比如下：\n\n\n\n可以看到，Rsbuild 插件的 API 风格与 esbuild 类似，可以通过一个函数来定义。插件的 hooks 经过简化，避免了冗长的\nAPI，使插件的编写更符合直觉。\n\n\n如何使用 1.0#\n\n * 如果你还未使用过 Rsbuild，可以通过 CodeSandbox 示例 来体验，也可以参考 快速上手 来接入 Rsbuild。\n * 如果你正在使用 Rsbuild 0.7 或更早的版本，请留意 1.0 版本包含一些不兼容更新，可参考 从 Rsbuild 0.x 迁移 文档进行升级。\n * Rsbuild 也提供了 webpack、CRA、Vue CLI 等项目的迁移指南，详见 从现有项目迁移。\n\n> 欢迎为 Rsbuild GitHub 仓库 点亮一颗 Star 🌟。\n\n\n下一步#\n\nRsbuild 1.0 为企业级应用和上层工具开发提供了一些高级特性，例如 多环境构建 API、服务端渲染 API、插件 API、模块联邦支持 和\nLibrary 构建（Rslib），我们计划继续完善这些特性，更好地支持 Rsbuild 生态发展。\n\n在接下来的 12～18 个月里，Rsbuild 将与 Rspack 共同演进，在第一时间应用 Rspack 的新特性，例如持久化缓存、更快的 HMR、基于\nTypeScript 的优化等。请参考 Rspack - 下一步 了解更多。\n\n最后，感谢所有为 Rsbuild 贡献过的开发者 ❤️：\n\n","routePath":"/zh/community/releases/v1-0","lang":"zh","toc":[{"text":"为什么是 Rsbuild","id":"为什么是-rsbuild","depth":2,"charIndex":57},{"text":"生态的发展","id":"生态的发展","depth":3,"charIndex":223},{"text":"Rsbuild 的诞生","id":"rsbuild-的诞生","depth":3,"charIndex":881},{"text":"性能","id":"性能","depth":2,"charIndex":1300},{"text":"谁在使用","id":"谁在使用","depth":2,"charIndex":2146},{"text":"插件生态","id":"插件生态","depth":2,"charIndex":2576},{"text":"如何使用 1.0","id":"如何使用-10","depth":2,"charIndex":2962},{"text":"下一步","id":"下一步","depth":2,"charIndex":3218}],"domain":"","frontmatter":{"published_at":"2024-09-10T18:00:00.000Z"},"version":""},{"id":197,"title":"dev.assetPrefix","content":"#\n\n * 类型： boolean | string | 'auto'\n * 默认值： server.base\n\n设置 开发模式 下的静态资源 URL 前缀。\n\nassetPrefix 会影响构建产物中绝大部分静态资源的 URL，包括 JavaScript 文件、CSS\n文件、图片、视频等。如果指定了一个错误的值，则在加载这些资源时可能会出现 404 错误。\n\n该配置项仅用于开发模式。在生产模式下，请使用 output.assetPrefix 配置项进行设置。\n\n\n默认值#\n\ndev.assetPrefix 的默认值与 server.base 相同。\n\n当 server.base 为 /foo 时，可通过 http://localhost:3000/foo/ 访问到 index.html 及其他静态资源产物。\n\n需要注意的是，当自定义 dev.assetPrefix 选项时，如果希望静态资源能够通过 Rsbuild 开发服务器正常访问到，dev.assetPrefix\n应和 server.base 包含相同的 URL 前缀，如：\n\n\n\n\nBoolean 类型#\n\n如果设置 assetPrefix 为 true，Rsbuild 会使用 http://localhost:/ 作为 URL 前缀：\n\n\n\n在浏览器中加载的资源 URL 如下：\n\n\n\n如果设置 assetPrefix 为 false 或不设置，则默认使用 / 作为访问前缀。\n\n\nString 类型#\n\n当 assetPrefix 的值为 string 类型时，字符串会作为前缀，自动拼接到静态资源访问 URL 上。\n\n * 比如设置为相对于根目录的路径：\n\n\n\n在浏览器中加载的资源 URL 如下：\n\n\n\n * 比如设置为完整 URL：\n\n\n\n在浏览器中加载的资源 URL 如下：\n\n\n\n\n端口号占位符#\n\nRsbuild server 监听的端口号可能会发生变更。比如，当端口被占用时，Rsbuild 会自动递增端口号，直至找到一个可用端口。\n\n为了避免端口变化导致 dev.assetPrefix 失效，你可以使用以下方法之一：\n\n * 开启 server.strictPort。\n * 使用 占位符来指代当前端口号，Rsbuild 会将占位符替换为实际监听的端口号。\n\n\n\n\n路径类型#\n\nassetPrefix 可以设置为以下类型的路径：\n\n * 绝对路径：这是最常见的做法，可以为指定服务器路径，比如 /assets/。\n * 'auto'：Rspack 将自动计算路径，并生成基于文件所在位置的相对路径。\n\nTIP\n\n不建议将 assetPrefix 设置为相对路径，比如 './assets/'。因为当资源位于不同的路径深度时，使用相对路径可能会导致资源无法正确加载。\n\n\n对比 publicPath#\n\ndev.assetPrefix 的功能与 Rspack 的 output.publicPath 配置基本一致。\n\n它与原生配置的区别在于：\n\n * dev.assetPrefix 仅在开发模式下生效。\n * dev.assetPrefix 默认值与 server.base 相同。\n * dev.assetPrefix 默认会自动补全尾部的 /。\n * dev.assetPrefix 的值会写入 process.env.ASSET_PREFIX 环境变量（只能在 client 代码中访问）。","routePath":"/zh/config/dev/asset-prefix","lang":"zh","toc":[{"text":"默认值","id":"默认值","depth":2,"charIndex":234},{"text":"Boolean 类型","id":"boolean-类型","depth":2,"charIndex":475},{"text":"String 类型","id":"string-类型","depth":2,"charIndex":627},{"text":"端口号占位符","id":"端口号占位符","depth":3,"charIndex":783},{"text":"路径类型","id":"路径类型","depth":2,"charIndex":979},{"text":"对比 `publicPath`","id":"对比-publicpath","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":198,"title":"dev.cliShortcuts","content":"#\n\n * 类型：\n\n\n\n * 默认值： 当使用 Rsbuild CLI 时默认为 true，否则为 false。\n * 版本： >= 1.0.11\n\n是否启用 CLI 快捷键。\n\n\n所有快捷键#\n\n按 h + Enter 以显示所有快捷键：\n\n\n\n\n示例#\n\n * 启用：\n\n\n\n * 禁用：\n\n\n\n\n自定义快捷键#\n\ncustom 选项可以自定义快捷键，custom 的值是一个函数，接收默认的 shortcuts 列表，并返回一个新的 shortcuts 列表。\n\n * 添加自定义快捷键：\n\n\n\n * 禁用部分快捷键：\n\n\n\n\n打印帮助#\n\nhelp 选项可以控制是否在启动服务器时打印帮助提示：\n\n\n\n * 禁用：\n\n","routePath":"/zh/config/dev/cli-shortcuts","lang":"zh","toc":[{"text":"所有快捷键","id":"所有快捷键","depth":2,"charIndex":91},{"text":"示例","id":"示例","depth":2,"charIndex":125},{"text":"自定义快捷键","id":"自定义快捷键","depth":2,"charIndex":151},{"text":"打印帮助","id":"打印帮助","depth":2,"charIndex":267}],"domain":"","frontmatter":{},"version":""},{"id":199,"title":"dev.client","content":"#\n\n配置 Rsbuild 在开发过程中注入的 client 代码，可以用于设置热更新对应的 WebSocket URL。\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n\n配置 WebSocket URL#\n\n默认情况下，当你启动 dev server，并访问 http://localhost:3000/ 时，页面上会发起一个 WebSocket 请求，指向\nws://localhost:3000/rsbuild-hmr，使页面与开发服务器建立连接。\n\n在某些开发场景下，你可能需要调整 WebSocket URL，来保证 WebSocket 请求能够正确连接。\n\n比如当你使用代理工具进行开发时，实际访问的可能是一个线上域名，此时你可以手动配置 dev.client，将 WebSocket URL\n指向本地的开发服务器。下面是一个示例，WebSocket 请求的地址为 ws://127.0.0.1:3000/rsbuild-hmr：\n\n\n\n\n端口号占位符#\n\nRsbuild server 监听的端口号可能会发生变更。比如，当端口被占用时，Rsbuild 会自动递增端口号，直至找到一个可用端口。\n\n为了避免端口变化导致 client.port 失效，你可以使用以下方法之一：\n\n * 开启 server.strictPort。\n * 使用 占位符来指代当前端口号，Rsbuild 会将占位符替换为实际监听的端口号。\n\n\n\n\nhot-update 文件#\n\n在热更新过程中，页面会发起 GET 请求来获取 hot-update 文件，包括 *.hot-update.json 和\n*.hot-update.js。这些文件包含了热更新所需的信息，比如被更新的模块、模块的代码等。\n\nhot-update 文件属于静态资源，如果你需要配置 hot-update 文件的 URL，请使用 dev.assetPrefix 选项。\n\n\nError overlay#\n\n通过 dev.client.overlay 选项，可以选择是否启用 error overlay。\n\n默认情况下，当编译发生错误时，Rsbuild会在浏览器中显示 error overlay，并提供错误信息和错误堆栈：\n\n\n\n如果需要禁用 error overlay，可以将其设置为 false：\n\n\n\nTIP\n\nError overlay 功能需要当前浏览器版本支持 Web Components。在不支持的浏览器中，overlay 不会展示。","routePath":"/zh/config/dev/client","lang":"zh","toc":[{"text":"配置 WebSocket URL","id":"配置-websocket-url","depth":2,"charIndex":84},{"text":"端口号占位符","id":"端口号占位符","depth":3,"charIndex":424},{"text":"hot-update 文件","id":"hot-update-文件","depth":2,"charIndex":616},{"text":"Error overlay","id":"error-overlay","depth":2,"charIndex":816}],"domain":"","frontmatter":{},"version":""},{"id":200,"title":"dev.hmr","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n是否开启 Hot Module Replacement 热更新能力。\n\n请查看 模块热更新 来了解更多内容。\n\n> 通过 dev.client 可以配置 client 代码的 HMR 行为。\n\n\n禁用 HMR#\n\n当 dev.hmr 设置为 false 时，热更新和 react-refresh 将被禁用，Rsbuild 会自动降级到 dev.liveReload。\n\n","routePath":"/zh/config/dev/hmr","lang":"zh","toc":[{"text":"禁用 HMR","id":"禁用-hmr","depth":2,"charIndex":129}],"domain":"","frontmatter":{},"version":""},{"id":201,"title":"dev.lazyCompilation","content":"#\n\n * 类型：\n\n\n\n * 默认值： false\n * 版本： >= 0.7.1\n\n用于开启 lazy compilation（即按需编译），基于 Rspack 的 experiments.lazyCompilation 实现。\n\n\n介绍#\n\nLazy compilation 是一个提升 dev 启动性能的良好手段，它可以按需编译模块，而不是在启动时就编译所有模块。这意味着开发者在启动 dev\nserver 时，可以很快看到应用运行，并分次构建所需的模块。\n\n尽管 Rspack 本身具备良好的性能，但是面对具有大量模块的应用，其整体构建时间仍然可能不够理想。这是因为应用中的模块需要经过不同 loader 的编译，包括\npostcss-loader、sass-loader、vue-loader 等，它们都会产生额外的编译开销。\n\n在启用 lazy compilation 的情况下，Rspack 仅会编译被请求的「页面入口」和「动态 import\n模块」，这可以显著减少开发启动时编译的模块数量，从而提升启动时间。\n\n\n局限性#\n\n * Lazy compilation 仅对 dev 构建生效。\n * Lazy compilation 仍然是 Rspack 的实验性功能，在部分场景下，lazy compilation\n   可能无法按照预期工作，或是性能提升不明显。\n * Lazy compilation 依赖 Rspack 在本地启动的开发服务器，当你将某个域名代理到 localhost\n   进行开发时，它将无法正常工作。因此，如果你需要使用代理时，请禁用 lazy compilation。\n\n\n示例#\n\n\n启用 Lazy Compilation#\n\n\n\n这等价于以下配置：\n\n\n\n\n入口模块#\n\n通过 lazyCompilation.entries 来控制是否 lazy 编译入口模块：\n\n\n\n在启用 entries 选项后，当你启动 dev server 时， Rsbuild 不会编译所有的页面，而是仅在访问特定的页面时，才对该页面进行编译。\n\nlazy 编译入口模块时，有以下注意事项：\n\n * 只适用于多页应用（MPA），对单页应用（SPA）没有优化效果。\n * 当你访问一个页面时，你需要等待页面编译完成才能看到页面的内容。\n\n\n异步模块#\n\n通过 lazyCompilation.imports 来控制是否 lazy 编译 dynamic import 引入的异步模块：\n\n\n\n开启 imports 选项后，所有的异步模块只有在被请求时才触发编译。如果你的项目是一个单页应用（SPA），并通过 dynamic import\n进行了路由拆分，那么 dev 启动时间会有明显提升。","routePath":"/zh/config/dev/lazy-compilation","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":118},{"text":"局限性","id":"局限性","depth":2,"charIndex":465},{"text":"示例","id":"示例","depth":2,"charIndex":710},{"text":"启用 Lazy Compilation","id":"启用-lazy-compilation","depth":3,"charIndex":716},{"text":"入口模块","id":"入口模块","depth":3,"charIndex":754},{"text":"异步模块","id":"异步模块","depth":3,"charIndex":983}],"domain":"","frontmatter":{},"version":""},{"id":202,"title":"dev.liveReload","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n是否在源文件变更时自动刷新页面。\n\n默认情况下，Rsbuild 会优先使用 HMR 来更新模块。当 HMR 功能被禁用，或者某些场景 HMR 无法生效时，会自动降级到 liveReload。\n\n请查看 模块热更新 来了解更多内容。\n\n\n禁用 liveReload#\n\n如果你需要禁用 liveReload，可以将 dev.hmr 和 dev.liveReload 同时设置为 false，此时页面上不会发起 Web Socket\n请求到 dev server，也不会在文件变更时自动刷新页面。\n\n","routePath":"/zh/config/dev/live-reload","lang":"zh","toc":[{"text":"禁用 liveReload","id":"禁用-livereload","depth":2,"charIndex":149}],"domain":"","frontmatter":{},"version":""},{"id":203,"title":"dev.progressBar","content":"#\n\n * 类型：\n\n\n\n * 默认值： rsbuildConfig.mode === 'production'\n\n是否在编译过程中展示进度条。\n\n默认情况下，Rsbuild 仅会在生产模式构建时开启进度条。\n\n * 示例： 开启进度条。\n\n\n\n * 示例： 禁用进度条。\n\n\n\n * 示例： 修改进度条 id\n\n如果你需要修改进度条左侧显示的文本内容，可以设置 id 选项：\n\n","routePath":"/zh/config/dev/progress-bar","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":204,"title":"dev.setupMiddlewares","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n提供执行自定义函数和应用自定义中间件的能力。\n\n\n执行顺序#\n\n中间件的执行顺序是: unshift => 内置中间件 => push。\n\n\n\n\nServer API#\n\n在 setupMiddlewares 函数中，你可以访问到 server 对象，该对象提供了一些服务器 API。\n\n\nsockWrite#\n\nsockWrite 允许中间件向 HMR 客户端传递一些消息，HMR 客户端将根据接收到的消息类型进行不同的处理。\n\n例如，如果你发送一个 'content-changed' 的消息，页面将会重新加载。\n\n\n\n\nenvironments#\n\nenvironments 包含 Rsbuild 的 environment API，这允许你在服务端获取特定环境下的构建产物信息。\n\n","routePath":"/zh/config/dev/setup-middlewares","lang":"zh","toc":[{"text":"执行顺序","id":"执行顺序","depth":2,"charIndex":56},{"text":"Server API","id":"server-api","depth":2,"charIndex":104},{"text":"sockWrite","id":"sockwrite","depth":3,"charIndex":176},{"text":"environments","id":"environments","depth":3,"charIndex":294}],"domain":"","frontmatter":{},"version":""},{"id":205,"title":"dev.watchFiles","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n监听指定文件和目录的变化。当文件发生变化时，可以触发页面的重新加载，或者触发 dev server 重新启动。\n\n\npaths#\n\n * 类型： string | string[]\n * 默认值： undefined\n\n监视的文件或目录的路径，支持 glob 语法。可以是单个路径，也可以是多个路径组成的数组。\n\n * 监听单个文件：\n\n\n\n * 使用 glob 匹配多个文件：\n\n\n\n * 监听多个文件路径：\n\n\n\n\ntype#\n\n * 类型： 'reload-page' | 'reload-server'\n * 默认值： 'reload-page'\n\n指定当文件发生变化时，是触发页面重新加载，还是触发 dev server 重新启动。\n\n\nreload-page#\n\nreload-page 表示当文件发生变化时，浏览器打开的页面会自动重新加载。如果未明确指定 type，Rsbuild 会默认采用 reload-page\n行为。\n\n这可以用于监听一些静态资源文件的变化，例如 public 目录下的文件。\n\n\n\n> 如果 dev.hmr 和 dev.liveReload 都设置为 false，则页面将不会自动重新加载。\n\n\nreload-server#\n\nreload-server 表示当文件发生变化时，dev server 会自动重新启动。这可以用于监听一些配置文件的变化，例如被\nrsbuild.config.ts 文件 import 的模块。\n\n例如，你在 config 目录下维护了一些公共配置文件，例如 common.ts，你希望当这些文件发生变化时，dev server 可以自动重新启动。示例配置：\n\n\n\n需要注意的是，reload-server 功能由 Rsbuild CLI 提供。如果你使用的是自定义 server 或基于 Rsbuild\n封装的上层框架，目前暂不支持此配置。\n\n\noptions#\n\n * 类型： ChokidarOptions\n * 默认值： undefined\n\nwatchFiles 是基于 chokidar v4 实现的，你可以通过 options 传入 chokidar 的选项。\n\n\n\n\n传入数组#\n\ndev.watchFiles 支持传入一个数组，这允许你同时配置不同 type 的监听器，或是为不同的目录配置不同的 watchOptions。\n\n\n\n\n说明#\n\nwatchFiles 不适用于监听构建依赖的文件。当 Rsbuild 构建开始时，底层的 Rspack\n默认会监听所有构建依赖，当这些文件发生变化时，会触发一次新的构建。\n\n如果你希望当某些文件变化时，不触发重新构建，可以使用 Rspack 的 watchOptions.ignored 配置项。\n\n> 详见 模块热更新 - 文件监听。","routePath":"/zh/config/dev/watch-files","lang":"zh","toc":[{"text":"paths","id":"paths","depth":2,"charIndex":89},{"text":"type","id":"type","depth":2,"charIndex":241},{"text":"reload-page","id":"reload-page","depth":3,"charIndex":355},{"text":"reload-server","id":"reload-server","depth":3,"charIndex":549},{"text":"options","id":"options","depth":2,"charIndex":839},{"text":"传入数组","id":"传入数组","depth":2,"charIndex":957},{"text":"说明","id":"说明","depth":2,"charIndex":1041}],"domain":"","frontmatter":{},"version":""},{"id":206,"title":"dev.writeToDisk","content":"#\n\n * 类型： boolean | ((filename: string) => boolean)\n * 默认值： false\n\n用于控制是否将开发模式的构建产物写入到磁盘上。\n\nTIP\n\n在开发模式下，Rsbuild 默认会将构建产物保存在 dev server 的内存中，而不是写入磁盘，这样可以减少 fs 操作产生的开销。你可以参考\n查看静态资源 查看当前构建生成的所有静态资源。\n\n\n写入磁盘#\n\n你可以选择将构建产物写入到磁盘，这通常用于排查构建产物的内容，或是配置静态资源的代理规则。\n\n只需要将 dev.writeToDisk 配置项设置为 true 即可：\n\n\n\nTIP\n\nwriteToDisk: true 用于在开发模式下查看构建产物，它不会改变 dev server 的行为，通过浏览器访问文件时，dev server\n仍将从内存中读取文件内容。\n\n\n匹配部分文件#\n\n你也可以将 dev.writeToDisk 设置为函数来匹配一部分文件，函数返回 false 时不会写入文件，返回值 true 时会将文件写入磁盘。\n\n例如将文件写入磁盘，并排除热更新临时文件：\n\n","routePath":"/zh/config/dev/write-to-disk","lang":"zh","toc":[{"text":"写入磁盘","id":"写入磁盘","depth":2,"charIndex":197},{"text":"匹配部分文件","id":"匹配部分文件","depth":2,"charIndex":388}],"domain":"","frontmatter":{},"version":""},{"id":207,"title":"environments","content":"#\n\nRsbuild 支持同时为多个环境构建产物。你可以使用 environments 为每个环境定义不同的 Rsbuild 配置。\n\n> 请查看 多环境构建 了解更多。\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n\n示例#\n\n分别为 web (client) 和 node (SSR) 环境配置 Rsbuild：\n\n\n\n对于 web 环境，合并后的 Rsbuild 配置为：\n\n\n\n对于 node 环境，合并后的 Rsbuild 配置为：\n\n","routePath":"/zh/config/environments","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":116}],"domain":"","frontmatter":{},"version":""},{"id":208,"title":"html.appIcon","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n设置 Web 应用的图标，用于在添加到移动设备的主屏幕时显示：\n\n * 生成 web app manifest 文件和其中的 icons 字段。\n * 生成 HTML 文件中的 apple-touch-icon 标签和 manifest 标签。\n\nTIP\n\n参考以下文档来了解更多信息：\n\n * MDN - Web app manifests\n * How to Favicon: Six files that fit most needs\n\n\n示例#\n\n你需要准备多个不同大小的图标，以便在不同设备上显示。\n\n最常用的图标大小是 192x192 和 512x512，你也可以根据需要来自定义图标大小和图标数量。\n\n\n\n编译后，HTML 中自动生成了以下标签：\n\n\n\n其中，manifest.webmanifest 是一个 JSON 文件，包含了应用的名称和图标等信息。\n\n\n\n图标大小\n\n对于 Chrome，你至少需要提供 192x192 像素的图标和 512x512 像素的图标。如果仅提供这两种图标大小，Chrome\n会自动缩放图标以适应设备大小。如果你希望缩放自己的图标，并调整图标以实现像素完美，请以 48dp 为增量提供图标。\n\n\nname#\n\n * 类型： string\n * 默认值： undefined\n\n应用的名称，用于在添加到移动设备的主屏幕时显示。如果未设置，则不会生成 manifest.webmanifest 文件。\n\n> 详见 Web app manifests - name。\n\n\nicons#\n\n * 类型： AppIconItem[]\n * 默认值： undefined\n\n图标列表，其中：\n\n * src 是图标的路径，可以是 URL 地址、文件的绝对路径，或是相对于项目 root 的相对路径。\n * size 是图标的大小，以像素为单位。\n * target 是图标的目标，可以是 apple-touch-icon 或 web-app-manifest。如果未设置\n   target，默认情况下，manifest 文件会包含所有的图标，而 apple-touch-icon 标签只会包含小于 200x200 的图标。\n\n\n示例#\n\nsrc 可以设置为绝对路径：\n\n\n\n使用 target 选项来指定图标的目标：\n\n\n\n\nfilename#\n\n * 类型： string\n * 默认值： 'manifest.webmanifest'\n\nmanifest 文件的文件名。\n\n","routePath":"/zh/config/html/app-icon","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":254},{"text":"name","id":"name","depth":2,"charIndex":553},{"text":"icons","id":"icons","depth":2,"charIndex":688},{"text":"示例","id":"示例-1","depth":3,"charIndex":964},{"text":"filename","id":"filename","depth":3,"charIndex":1013}],"domain":"","frontmatter":{},"version":""},{"id":209,"title":"html.crossorigin","content":"#\n\n * 类型： boolean | 'anonymous' | 'use-credentials'\n * 默认值： false\n\n用于设置\n\n","routePath":"/zh/config/html/crossorigin","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":-1},{"text":"可选值","id":"可选值","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":210,"title":"html.favicon","content":"#\n\n * 类型： string ｜ Function\n * 默认值： undefined\n\n设置页面的 favicon 图标，可以设置为：\n\n * URL 地址。\n * 文件的绝对路径。\n * 相对于项目 root 的相对路径。\n\n配置该选项后，在编译过程中会自动将图标拷贝至 dist 目录下，并在 HTML 中添加相应的 link 标签。\n\nTIP\n\nRsbuild 还提供了 html.appIcon 来设置 Web 应用的图标。\n\n\n示例#\n\n设置为相对路径：\n\n\n\n设置为绝对路径：\n\n\n\n设置为 URL：\n\n\n\n重新编译后，HTML 中自动生成了以下标签：\n\n\n\n\n函数用法#\n\n * 类型：\n\n\n\n当 html.favicon 为 Function 类型时，函数接收一个对象作为入参，对象的值包括：\n\n * value：Rsbuild 的默认 favicon 配置。\n * entryName: 当前入口的名称。\n\n在 MPA（多页面应用）场景下，你可以基于入口名称返回不同的 favicon，从而为每个页面生成不同的标签：\n\n","routePath":"/zh/config/html/favicon","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":221},{"text":"函数用法","id":"函数用法","depth":2,"charIndex":289}],"domain":"","frontmatter":{},"version":""},{"id":211,"title":"html.inject","content":"\n<%= htmlPlugin.tags.bodyTags %>","routePath":"/zh/config/html/inject","lang":"zh","toc":[{"text":"默认插入位置","id":"默认插入位置","depth":2,"charIndex":-1},{"text":"插入至 body 标签","id":"插入至-body-标签","depth":2,"charIndex":-1},{"text":"函数用法","id":"函数用法","depth":2,"charIndex":-1},{"text":"手动注入","id":"手动注入","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":212,"title":"html.meta","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n配置 HTML 页面的 标签。\n\nTIP\n\n如果当前项目使用的 HTML 模板中已经包含了 charset 或 viewport meta 标签，那么 HTML 模板中的标签优先级更高。\n\n\nString 类型#\n\n * 类型：\n\n\n\n当 meta 对象的 value 为字符串时，会自动将对象的 key 映射为 name，value 映射为 content。\n\n比如设置 description：\n\n\n\n最终在 HTML 中生成的 meta 标签为：\n\n\n\n\nObject 类型#\n\n * 类型：\n\n\n\n当 meta 对象的 value 为对象时，会将该对象的 key: value 映射为 meta 标签的属性。\n\n比如设置 charset：\n\n\n\n最终在 HTML 中生成的 meta 标签为：\n\n\n\n\n函数用法#\n\n * 类型：\n\n\n\n当 html.meta 为 Function 类型时，函数接收一个对象作为入参，对象的值包括：\n\n * value：Rsbuild 的默认 meta 配置。\n * entryName: 当前入口的名称。\n\n你可以直接修改配置对象不做返回，也可以返回一个对象作为最终的配置。\n\n比如，你可以直接修改内置的 meta 配置对象：\n\n\n\n在 MPA（多页面应用）场景下，你可以基于入口名称返回不同的 meta 配置，从而为每个页面生成不同的 meta 标签：\n\n\n\n\n移除默认值#\n\n将 meta 对象的 value 设置为 false，则表示不生成对应的 meta 标签。\n\n比如移除 Rsbuild 预设的 viewport：\n\n","routePath":"/zh/config/html/meta","lang":"zh","toc":[{"text":"String 类型","id":"string-类型","depth":2,"charIndex":134},{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":269},{"text":"函数用法","id":"函数用法","depth":2,"charIndex":393},{"text":"移除默认值","id":"移除默认值","depth":2,"charIndex":641}],"domain":"","frontmatter":{},"version":""},{"id":213,"title":"html.mountId","content":"","routePath":"/zh/config/html/mount-id","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":-1},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":-1},{"text":"更新相关代码","id":"更新相关代码","depth":3,"charIndex":-1},{"text":"自定义模板","id":"自定义模板","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":214,"title":"html.outputStructure","content":"#\n\n * Type: 'flat' | 'nested'\n * Default: 'flat'\n\n用于定义 HTML 产物文件的目录结构。\n\n\n示例#\n\n默认情况下，HTML 产物在 dist 目录下的结构为 flat：\n\n\n\n你可以将 html.outputStructure 配置为 nested:\n\n\n\n重新构建后，HTML 产物的目录结构如下：\n\n\n\n> 如果你需要设置 HTML 文件在 dist 目录中的父级路径，请使用 output.distPath.html 配置。","routePath":"/zh/config/html/output-structure","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":72}],"domain":"","frontmatter":{},"version":""},{"id":215,"title":"html.scriptLoading","content":"","routePath":"/zh/config/html/script-loading","lang":"zh","toc":[{"text":"defer","id":"defer","depth":3,"charIndex":-1},{"text":"blocking","id":"blocking","depth":3,"charIndex":-1},{"text":"module","id":"module","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":216,"title":"html.tags","content":"","routePath":"/zh/config/html/tags","lang":"zh","toc":[{"text":"对象形式","id":"对象形式","depth":2,"charIndex":-1},{"text":"设置标签插入位置","id":"设置标签插入位置","depth":3,"charIndex":-1},{"text":"函数形式","id":"函数形式","depth":2,"charIndex":-1},{"text":"限制","id":"限制","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":217,"title":"html.templateParameters","content":"#\n\n * 类型： Record | Function\n * 默认值：\n\n\n\n定义 HTML 模板中的参数，详细用法请参考 配置 HTML 模板 - 模板参数。\n\n\n对象用法#\n\n如果 templateParameters 的值是一个对象，它会和默认参数通过 Object.assign 合并。\n\n比如，如果你需要在 HTML 模板中使用 foo 参数，可以添加如下设置：\n\n\n\n接下来，你可以在 HTML 模板中，通过 <%= foo %> 来读取参数：\n\n\n\n编译后的 HTML 代码如下：\n\n\n\n\n函数用法#\n\n * 类型：\n\n\n\n当 html.templateParameters 为 Function 类型时，函数接收两个参数：\n\n * value：Rsbuild 的默认 templateParameters 配置。\n * utils: 一个对象，其中包含了 entryName 字段，对应当前入口的名称。\n\n在 MPA（多页面应用）场景下，你可以基于入口名称设置不同的 templateParameters 参数：\n\n","routePath":"/zh/config/html/template-parameters","lang":"zh","toc":[{"text":"对象用法","id":"对象用法","depth":2,"charIndex":82},{"text":"函数用法","id":"函数用法","depth":2,"charIndex":251}],"domain":"","frontmatter":{},"version":""},{"id":218,"title":"html.template","content":"","routePath":"/zh/config/html/template","lang":"zh","toc":[{"text":"字符串用法","id":"字符串用法","depth":3,"charIndex":-1},{"text":"函数用法","id":"函数用法","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":219,"title":"html.title","content":"#\n\n * 类型： string ｜ Function\n * 默认值： 'Rsbuild App'\n\n配置 HTML 页面的 title 标签。\n\nTIP\n\n如果当前项目使用的 HTML 模板中已经包含了 </code> 标签，那么 <code>html.title</code> 将不会生效。\n</p></div></div> <h2 id=\"字符串用法\">字符串用法<a aria-hidden=\"true\"\nhref=\"#字符串用法\">#</a></h2> <p>当 <code>html.title</code> 可以直接设置为一个字符串：</p>\n<pre><code>export default { html: { title: 'Example', }, }; </code></pre> <p>最终在\nHTML 中生成的 <code>title</code> 标签为：</p> <pre><code><title>Example\n\n\n函数用法#\n\n * 类型：\n\n\n\n当 html.title 为 Function 类型时，函数接收一个对象作为入参，对象的值包括：\n\n * value：Rsbuild 的默认 title 配置。\n * entryName: 当前入口的名称。\n\n在 MPA（多页面应用）场景下，你可以基于入口名称返回不同的 title 字符串，从而为每个页面生成不同的 title 标签：\n\n\n\n\n不注入 title 标签#\n\n当 html.title 设置为空字符串时，Rsbuild 不会注入 </code> 标签：</p> <pre><code>export default {\nhtml: { title: '', }, }; </code></pre>","routePath":"/zh/config/html/title","lang":"zh","toc":[{"text":"字符串用法","id":"字符串用法","depth":2,"charIndex":-1},{"text":"函数用法","id":"函数用法","depth":2,"charIndex":425},{"text":"不注入 title 标签","id":"不注入-title-标签","depth":2,"charIndex":615}],"domain":"","frontmatter":{},"version":""},{"id":220,"title":"Config 总览","content":"#\n\n当前页面列出了 Rsbuild 所有的配置项，请查看 「配置 Rsbuild」 了解使用方式。","routePath":"/zh/config/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":221,"title":"mode","content":"#\n\n * 类型： 'production' | 'development' | 'none'\n * 版本： >= 1.0.0\n\n指定 Rsbuild 构建的模式，各个模式默认的行为和优化不同，比如 production 模式默认会压缩代码。\n\nRsbuild mode 的值也会传递给 Rspack 的 mode 配置。\n\nTIP\n\nmode 的值不会影响 .env 文件的加载结果， 因为 .env 文件早于 Rsbuild 的配置文件被解析。\n\nRsbuild CLI 支持使用 --env-mode 选项来指定 env 模式，详见 \"Env 模式\"。\n\n\n默认值#\n\nmode 的默认值取决于 process.env.NODE_ENV 环境变量：\n\n * 如果 NODE_ENV 为 production，则默认值为 production。\n * 如果 NODE_ENV 为 development，则默认值为 development。\n * 如果 NODE_ENV 为其他值，则默认值为 none。\n\n如果你设置了 mode 的值，则 NODE_ENV 的值会被忽略。\n\n\n\n\n命令行#\n\n当你使用 Rsbuild 的命令行时：\n\n * rsbuild dev 会将 NODE_ENV 和 mode 的默认值设置为 development。\n * rsbuild build 和 rsbuild preview 会将 NODE_ENV 和 mode 的默认值设置为 production。\n\n\nJavaScript API#\n\n当你使用 Rsbuild 的 JavaScript API 时：\n\n * rsbuild.startDevServer 和 rsbuild.createDevServer 会将 NODE_ENV 和 mode 的默认值设置为\n   development。\n * rsbuild.build 和 rsbuild.preview 会将 NODE_ENV 和 mode 的默认值设置为 production。\n\n\nDevelopment 模式#\n\n当 mode 的值为 development 时：\n\n * 开启 HMR，注册 HotModuleReplacementPlugin。\n * 生成 JavaScript 的 source map，不生成 CSS 的 source map，详见 output.sourceMap。\n * 源代码中的 process.env.NODE_ENV 会被替换为 'development'。\n * 源代码中的 import.meta.env.MODE 会被替换为 'development'。\n * 源代码中的 import.meta.env.DEV 会被替换为 true。\n * 源代码中的 import.meta.env.PROD 会被替换为 false。\n\n\nProduction 模式#\n\n当 mode 的值为 production 时：\n\n * 开启 JavaScript 代码压缩，注册 SwcJsMinimizerRspackPlugin。\n * 开启 CSS 代码压缩，注册 LightningCssMinimizerRspackPlugin。\n * 生成的 JavaScript 和 CSS 文件名会带有 hash 后缀，详见 output.filenameHash。\n * 生成的 CSS Modules 类名更简短，详见 cssModules.localIdentName。\n * 不生成 JavaScript 和 CSS 的 source map，详见 output.sourceMap。\n * 源代码中的 process.env.NODE_ENV 会被替换为 'production'。\n * 源代码中的 import.meta.env.MODE 会被替换为 'production'。\n * 源代码中的 import.meta.env.DEV 会被替换为 false。\n * 源代码中的 import.meta.env.PROD 会被替换为 true。\n\n\nNone 模式#\n\n当 mode 的值为 none 时：\n\n * 不开启任何优化。\n * 源代码中的 process.env.NODE_ENV 不会被替换。\n * 源代码中的 import.meta.env.MODE 会被替换为 'none'。\n * 源代码中的 import.meta.env.DEV 会被替换为 false。\n * 源代码中的 import.meta.env.PROD 会被替换为 false。","routePath":"/zh/config/mode","lang":"zh","toc":[{"text":"默认值","id":"默认值","depth":2,"charIndex":281},{"text":"命令行","id":"命令行","depth":3,"charIndex":493},{"text":"JavaScript API","id":"javascript-api","depth":3,"charIndex":651},{"text":"Development 模式","id":"development-模式","depth":2,"charIndex":873},{"text":"Production 模式","id":"production-模式","depth":2,"charIndex":1218},{"text":"None 模式","id":"none-模式","depth":2,"charIndex":1728}],"domain":"","frontmatter":{},"version":""},{"id":222,"title":"moduleFederation.options","content":"#\n\n * 类型： Rspack.ModuleFederationPluginOptions\n * 默认值： undefined\n\n用于配置 Rspack 模块联邦插件（对应模块联邦 v1.5）。\n\nTIP\n\n模块联邦的实现有多个版本。在使用 moduleFederation.options 之前，请阅读 模块联邦指南 来了解不同版本之间的差异，以及如何进行选择，\n\n\n介绍#\n\n在使用模块联邦时，我们推荐你使用 Rsbuild 提供的 moduleFederation.options\n选项，这个选项会自动调整一些相关的配置，以保证模块联邦应用可以正确运行。\n\n当你设置 moduleFederation.options 选项后，Rsbuild 会执行以下操作：\n\n * 自动注册 ModuleFederationPlugin 插件，并将 options 的值透传给插件。\n * 将 provider 的 dev.assetPrefix 配置的默认值设置为 true，这可以确保 remote modules 的静态资源 URL\n   是正确的。\n * 将 Rspack output.uniqueName 配置的默认值设置为 moduleFederation.options.name，使 HMR\n   可以正常工作。\n * 关闭 Rsbuild performance.chunkSplit 中 split-by-experience 相关的规则，因为这可能会与 shared\n   modules 冲突，参考 #3161。\n * 关闭 remote entry 的 splitChunks 规则。\n\n\n用法#\n\nmoduleFederation.options 的类型与 Rspack 的 ModuleFederationPlugin 插件完全一致：\n\n\n\n请参考 ModuleFederationPlugin 文档来了解所有可用的选项。\n\n\n示例#\n\n下面是一个最小示例：\n\n * Remote App\n\n\n\n * Host App\n\n\n\n更多示例请查看：\n\n * Rsbuild - module-federation example\n * module-federation/module-federation-examples","routePath":"/zh/config/module-federation/options","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":185},{"text":"用法","id":"用法","depth":2,"charIndex":705},{"text":"示例","id":"示例","depth":2,"charIndex":826}],"domain":"","frontmatter":{},"version":""},{"id":223,"title":"output.assetPrefix","content":"#\n\n * 类型： string | 'auto'\n * 默认值： server.base\n\n在 生产模式 下，可以使用该选项设置静态资源的 URL 前缀，比如设置为 CDN 地址。\n\nassetPrefix 会影响构建产物中绝大部分静态资源的 URL，包括 JavaScript 文件、CSS\n文件、图片、视频等。如果指定了一个错误的值，则在加载这些资源时可能会出现 404 错误。\n\n该配置项仅用于生产模式。在开发模式下，请使用 dev.assetPrefix 配置项进行设置。\n\n\n示例#\n\n设置 output.assetPrefix 后，JavaScript、CSS、图片等静态资源的 URL 都会加上 output.assetPrefix\n的值作为前缀。\n\n * 例如，设置为一个 CDN 地址：\n\n\n\n构建后，JS 文件的 URL 如下：\n\n\n\n * 设置为相对路径：\n\n\n\n构建后，JS 文件的 URL 如下：\n\n\n\n\n默认值#\n\noutput.assetPrefix 的默认值与 server.base 相同。\n\n当 server.base 为 /foo 时，可通过 http://localhost:3000/foo/ 访问到 index.html 及静态资源产物。\n\n需要注意的是，当自定义 output.assetPrefix 选项时，如果希望静态资源能够通过 Rsbuild\n预览服务器正常访问，output.assetPrefix 应和 server.base 包含相同的 URL 前缀，如：\n\n\n\n\n路径类型#\n\nassetPrefix 可以设置为以下类型的路径：\n\n * 绝对路径：这是最常见的做法，可以为指定服务器路径，比如 /assets/，或是设置为 CDN 路径，比如\n   https://cdn.example.com/assets/。\n * 相对路径：比如 ./assets/。\n * 'auto'：Rspack 将自动计算路径，并生成基于文件所在位置的相对路径。\n\nTIP\n\n通常不建议将 assetPrefix 设置为相对路径，因为当资源位于不同的路径深度时，使用相对路径可能会导致资源无法正确加载。\n\n\n对比 publicPath#\n\noutput.assetPrefix 的功能与 Rspack 的 output.publicPath 配置基本一致。\n\n它与原生配置的区别在于：\n\n * output.assetPrefix 仅在生产模式下生效。\n * output.assetPrefix 默认值与 server.base 相同。\n * output.assetPrefix 默认会自动补全尾部的 /。\n * output.assetPrefix 的值会写入 process.env.ASSET_PREFIX 环境变量（只能在 client 代码中访问）。","routePath":"/zh/config/output/asset-prefix","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":243},{"text":"默认值","id":"默认值","depth":2,"charIndex":416},{"text":"路径类型","id":"路径类型","depth":2,"charIndex":663},{"text":"对比 `publicPath`","id":"对比-publicpath","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":224,"title":"output.charset","content":"#\n\n * 类型： 'ascii' | 'utf8'\n * 默认值： 'utf8'\n\ncharset 配置项允许你指定输出文件的字符编码，以确保它们在不同的环境中能够正确显示。\n\n\nUTF8#\n\n默认情况下，Rsbuild 的输出是 UTF-8 编码，这是 Web 应用中最常用的字符编码。\n\n当你的 web 服务器返回资源时，请确保发送正确的 Content-Type 响应头，使浏览器能够正确解析。\n\n\nASCII#\n\n如果你希望输出文件使用 ASCII 编码，可以在配置文件中这样设置：\n\n\n\n使用 ASCII 编码时，任何非 ASCII 字符都使用反斜杠进行转义，这通常会生成稍大一点的文件，也使其更难阅读。\n\n\n注意事项#\n\n目前 charset 选项仅会影响经过 SWC 编译的文件，默认为 JavaScript 和 TypeScript 文件，而 HTML、CSS 文件则不受\ncharset 选项的影响。\n\n对于 HTML 文件，Rsbuild 默认会添加 标签，你可以通过 html.meta 选项来修改它。","routePath":"/zh/config/output/charset","lang":"zh","toc":[{"text":"UTF8","id":"utf8","depth":2,"charIndex":90},{"text":"ASCII","id":"ascii","depth":2,"charIndex":203},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":310}],"domain":"","frontmatter":{},"version":""},{"id":225,"title":"output.cleanDistPath","content":"#\n\n * 类型： boolean | 'auto'\n * 默认值： 'auto'\n\n是否在构建开始前清理产物目录下的所有文件（产物目录默认为 dist）。\n\n\n默认行为#\n\noutput.cleanDistPath 的默认值为 'auto'。如果产物目录是项目根路径的子目录，Rsbuild 会自动清空产物目录下的文件。\n\n当 output.distPath.root 为外部目录，或等于项目根目录时，cleanDistPath 不会默认开启，这是为了避免误删其他目录的文件。\n\n\n\n\n强制开关#\n\n你可以把 cleanDistPath 设置为 true 来强制开启，也可以设置为 false 来强制关闭该行为。\n\n\n\n\n条件判断#\n\n如果你只需要在生产模式构建前清理文件，而在开发模式构建前不需要，那么可以配置为：\n\n","routePath":"/zh/config/output/clean-dist-path","lang":"zh","toc":[{"text":"默认行为","id":"默认行为","depth":2,"charIndex":80},{"text":"强制开关","id":"强制开关","depth":2,"charIndex":243},{"text":"条件判断","id":"条件判断","depth":2,"charIndex":311}],"domain":"","frontmatter":{},"version":""},{"id":226,"title":"output.copy","content":"#\n\n * 类型： Rspack.CopyRspackPluginOptions |\n   Rspack.CopyRspackPluginOptions['patterns']\n * 默认值： undefined\n\n将指定的文件或目录拷贝到构建输出目录中，基于 rspack.CopyRspackPlugin 实现。\n\n> 配置项请参考：rspack.CopyRspackPlugin。\n\n\n示例#\n\n将 ./src/assets 下的文件拷贝到 ./dist 目录：\n\n\n\n将 ./src/assets 下的文件拷贝到 ./dist/assets 目录：\n\n","routePath":"/zh/config/output/copy","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":195}],"domain":"","frontmatter":{},"version":""},{"id":227,"title":"output.cssModules","content":"#\n\n * 类型： CSSModules\n\n用于自定义 CSS Modules 配置。\n\nRsbuild 的 CSS Modules 功能是基于 css-loader 的 modules 选项实现的，你可以参考 css-loader -\nmodules 来了解更多。\n\n\ncssModules.auto#\n\nauto 配置项允许基于文件名自动启用 CSS Modules。\n\n * 类型：\n\n\n\n * 默认值： true\n\n类型说明：\n\n * true: 为所有匹配 /\\.module\\.\\w+$/i.test(filename) 正则表达式的文件启用 CSS Modules。\n * false: 禁用 CSS Modules。\n * RegExp: 为所有匹配 /RegExp/i.test(filename) 正则表达式的文件启用 CSS Modules。\n * function: 为所有通过基于文件名的过滤函数校验的文件启用 CSS Modules。\n\n\n\n\ncssModules.exportLocalsConvention#\n\n导出的 class 名称的命名风格。\n\n * 类型：\n\n\n\n * 默认值： 'camelCase'\n\n类型说明：\n\n * asIs：类名将按原样导出。\n * camelCase：类名将被驼峰化，然后被导出。原始类名也会被导出。\n * camelCaseOnly：类名将被驼峰化，然后被导出。原始类名不会被导出。\n * dashes：只有类名中的破折号会被驼峰化，然后被导出。原始类名也会被导出。\n * dashesOnly：类名中的破折号会被驼峰化，然后被导出。原始类名不会被导出。\n\n\n\n\ncssModules.exportGlobals#\n\n * 类型： boolean\n * 默认值： false\n\n允许从 global class names 导出名称，以便你可以通过 import 使用它们。\n\n\n示例#\n\n将 exportGlobals 设置为 true：\n\n\n\n在 CSS Modules 中使用 :global()：\n\n\n\n然后你可以导入 :global() 包裹的类名：\n\n\n\n\ncssModules.localIdentName#\n\n * 类型： string\n * 默认值：\n\n\n\n设置 CSS Modules 编译后生成的 class names 格式。\n\n\n默认值#\n\nlocalIdentName 在开发模式和生产模式有不同的默认值。\n\n在生产模式，Rsbuild 会生成更简短的类名，从而减少构建产物的体积。\n\n\n\n\n模板字符串#\n\n在 localIdentName 中，你可以使用以下模板字符串：\n\n * [name] - 源文件名称。\n * [local] - 原始类名。\n * [hash] - 字符串的哈希值。\n * [folder] - 文件夹的相对路径。\n * [path] - 源文件的相对路径。\n * [file] - 文件名和路径。\n * [ext] - 文件后缀名，包含点号。\n * [hash::] - 带有哈希设置的哈希。\n\n\n示例#\n\n将 localIdentName 设置为其他值：\n\n\n\n\ncssModules.mode#\n\n * 类型：\n\n\n\n * 默认值： 'local'\n\n控制 CSS Modules 的编译模式。\n\n\n可选值#\n\ncssModules.mode 可以取以下值之一：\n\n 1. 'local' (默认值)：启用 CSS Modules 规范和局部作用域。类名和 ID 选择器会被重写为模块作用域，并注入 @value 绑定。\n 2. 'global'：不启用 CSS Modules 的行为，禁用局部作用域和 @value 绑定注入。全局选择器将按照原样保留。\n 3. 'pure'：通过删除最终 CSS 中未使用的本地类名和值来实现死代码消除。仍然执行局部作用域和 @value 注入。\n 4. 'icss'：编译成 low-level 可互操作的 CSS 格式，该格式提供在 CSS 和其他语言之间声明 :import 和 :export\n    依赖项的语法。它不执行任何作用域或 @value 注入。\n\n'local' 模式是 CSS Modules 最常见的用法，在组件内启用模块化和局部作用域样式。其他模式可能在特定场景下被使用。\n\n例如：\n\n\n\n\n函数#\n\n你还可以传递一个函数给 cssModules.mode，并根据资源路径、query 或 fragment 确定 mode。这允许你为不同的文件使用不同的\nmode。\n\n例如，对 .module.css 文件使用局部作用域，对其他文件使用全局样式：\n\n\n\n\ncssModules.namedExport#\n\n * 类型： boolean\n * 默认值： false\n\n是否具名导出 class names。\n\n\n\n\n示例#\n\n\n\n * namedExport: false:\n\n\n\n * namedExport: true:\n\n\n\nTIP\n\n当 namedExport 为 true 时，CSS Modules 导出的 default class 会被自动重命名为 _default class，因为\ndefault 是 ECMA modules 的保留字。","routePath":"/zh/config/output/css-modules","lang":"zh","toc":[{"text":"cssModules.auto","id":"cssmodulesauto","depth":2,"charIndex":135},{"text":"cssModules.exportLocalsConvention","id":"cssmodulesexportlocalsconvention","depth":2,"charIndex":435},{"text":"cssModules.exportGlobals","id":"cssmodulesexportglobals","depth":2,"charIndex":717},{"text":"示例","id":"示例","depth":3,"charIndex":825},{"text":"cssModules.localIdentName","id":"cssmoduleslocalidentname","depth":2,"charIndex":920},{"text":"默认值","id":"默认值","depth":3,"charIndex":1013},{"text":"模板字符串","id":"模板字符串","depth":3,"charIndex":1095},{"text":"示例","id":"示例-1","depth":3,"charIndex":1312},{"text":"cssModules.mode","id":"cssmodulesmode","depth":2,"charIndex":1346},{"text":"可选值","id":"可选值","depth":3,"charIndex":1415},{"text":"函数","id":"函数","depth":3,"charIndex":1844},{"text":"cssModules.namedExport","id":"cssmodulesnamedexport","depth":2,"charIndex":1977},{"text":"示例","id":"示例-2","depth":3,"charIndex":2056}],"domain":"","frontmatter":{},"version":""},{"id":228,"title":"output.dataUriLimit","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n设置图片、字体、媒体等静态资源被自动内联为 base64 的体积阈值。\n\n默认情况下，体积小于 4KiB 的图片、字体、媒体等文件，会自动经过 Base64 编码，内联到页面中，不再会发送独立的 HTTP 请求。\n\n你可以通过修改 dataUriLimit 参数来调整这个阈值。\n\n其中：\n\n * svg：表示 SVG 图片的体积阈值。\n * font：表示字体文件的体积阈值。\n * image：表示非 SVG 图片的体积阈值。\n * media：表示视频等媒体资源的体积阈值。\n * assets：其他静态资源的体积阈值。例如 扩展静态资源类型 中定义的资源。\n\n\n示例#\n\n * 内联小于 10KiB 的所有静态资源：\n\n\n\n * 禁用静态资源内联：\n\n\n\n * 内联所有静态资源：\n\n\n\n * 设置图片资源的阈值为 5KiB，不内联视频资源：\n\n","routePath":"/zh/config/output/data-uri-limit","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":308}],"domain":"","frontmatter":{},"version":""},{"id":229,"title":"output.distPath","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n设置构建产物的输出目录，Rsbuild 会根据产物的类型输出到对应的子目录下。\n\n其中：\n\n * root: 表示所有构建产物输出的根目录。\n * html：表示 HTML 文件的输出目录。\n * js：表示 JavaScript 文件的输出目录。\n * jsAsync：表示异步 JavaScript 文件的输出目录，默认会输出到 distPath.js 的 async 子目录。\n * css：表示 CSS 文件的输出目录。\n * cssAsync：表示异步 CSS 文件的输出目录，默认会输出到 distPath.css 的 async 子目录。\n * svg：表示 SVG 图片的输出目录。\n * font：表示字体文件的输出目录。\n * wasm：表示 WebAssembly 文件的输出目录。\n * image：表示非 SVG 图片的输出目录。\n * media：表示视频等媒体资源的输出目录。\n * assets：其他静态资源的输出目录。例如 扩展静态资源类型 中定义的资源。\n\n\n根目录#\n\nroot 是构建产物的根目录，可以为相对路径或绝对路径。如果 root 的值为相对路径，则会基于当前项目的根目录拼接为绝对路径。\n\n其他目录只能为相对路径，并且会相对于 root 进行输出。\n\n\n示例#\n\n以 JavaScript 文件为例，会输出到 distPath.root + distPath.js 目录，即为 dist/static/js。\n\n如果需要将 JavaScript 文件输出到 build/resource/js 目录，可以这样设置：\n\n","routePath":"/zh/config/output/dist-path","lang":"zh","toc":[{"text":"根目录","id":"根目录","depth":3,"charIndex":471},{"text":"示例","id":"示例","depth":3,"charIndex":575}],"domain":"","frontmatter":{},"version":""},{"id":230,"title":"output.emitAssets","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n用于控制是否输出图片、字体、音频、视频等静态资源。\n\n在 SSR 等场景下，你可能不需要输出重复的静态资源，因此你可以在 emitAssets 返回 false 来避免资源输出。\n\n\n示例#\n\n比如，以下例子会在构建 web 产物时输出静态资源，而在构建 node 产物时避免输出。\n\n","routePath":"/zh/config/output/emit-assets","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":123}],"domain":"","frontmatter":{},"version":""},{"id":231,"title":"output.emitCss","content":"#\n\n * 类型： boolean\n * 默认值： 当 output.target 为 web 时为 true，否则为 false\n\n是否将 CSS 输出到产物中。\n\n如果 false，CSS 将不会被提取为单独的 .css 文件，也不会通过 output.injectStyles 注入到 JavaScript 产物中。\n\nTIP\n\n当 output.emitCss 为 false 时，CSS Modules 的类名信息仍然会被注入到 JS 产物中，这有助于保证 SSR 时 CSS\nModules 类名的正确性。\n\n\n示例#\n\n当构建 Node.js 产物时，如果你需要输出 CSS 文件，可以设置 output.emitCss 为 true：\n\n","routePath":"/zh/config/output/emit-css","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":261}],"domain":"","frontmatter":{},"version":""},{"id":232,"title":"output.externals","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n在构建时，防止将代码中某些 import 的依赖包打包到 bundle 中，而是在运行时再去从外部获取这些依赖。\n\n> 更多用法供参考：Rspack Externals。\n\n\n示例#\n\n将 react-dom 依赖从构建产物中剔除。为了在运行时获取这个模块, react-dom 的值将全局检索 ReactDOM 变量。\n\n\n\nTIP\n\n当 output.target 为 web-worker 时，externals 将不会生效。这是因为 Web Worker 环境不支持通过访问全局变量。","routePath":"/zh/config/output/externals","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":119}],"domain":"","frontmatter":{},"version":""},{"id":233,"title":"output.filenameHash","content":"#\n\n * 类型： boolean | string\n * 默认值： true\n\n在生产模式构建后，是否在产物的文件名中添加 hash 值。\n\n\n禁用 hash#\n\n默认情况下，构建后的产物名称会包含 hash 值：\n\n\n\n你可以将 output.filenameHash 设置为 false 来禁用这个行为：\n\n\n\n重新构建后，产物的名称变为：\n\n\n\n\nhash 格式#\n\nhash 的默认格式为 contenthash:8，即基于文件内容生成 8 位 hash。\n\n你可以将 output.filenameHash 设置为 Rspack 支持的其他格式，并自定义长度。\n\n\n\n可选的 hash 格式为：\n\n * fullhash：整个编译过程的哈希值，如果任何一个文件发生变动，整个项目的所有输出文件的哈希值都会改变\n * chunkhash：chunk 的哈希值，如果 chunk 内容（及其包含的模块）发生改变，哈希值才会改变。\n * contenthash：文件内容的哈希值，只有当文件本身的内容发生变更时，哈希值才会改变。\n\n\n注意事项#\n\n * output.filename 的优先级高于 output.filenameHash。\n * 默认情况下，当 target 不是 web 时，产物的文件名不会包含 hash，比如 Node.js 产物。\n * 默认情况下，开发模式构建产物的文件名不会包含 hash。","routePath":"/zh/config/output/filename-hash","lang":"zh","toc":[{"text":"禁用 hash","id":"禁用-hash","depth":3,"charIndex":72},{"text":"hash 格式","id":"hash-格式","depth":3,"charIndex":177},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":469}],"domain":"","frontmatter":{},"version":""},{"id":234,"title":"output.filename","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n设置构建产物的名称。\n\n在生产模式构建后，Rsbuild 会自动在文件名中间添加 hash 值，如果不需要添加，可以将 output.filenameHash 设置为 false\n来禁用该行为。\n\n下面是各个文件类型的说明：\n\n * html：表示 HTML 文件的名称。\n * js：表示 JavaScript 文件的名称。\n * css：表示 CSS 样式文件的名称。\n * svg：表示 SVG 图片的名称。\n * font：表示字体文件的名称。\n * image：表示非 SVG 图片的名称。\n * media：表示视频等媒体资源的名称。\n * assets：其他静态资源的名称。例如 扩展静态资源类型 中定义的资源。\n\n> 查看 构建产物目录 了解更多。\n\n\n示例#\n\n修改 JavaScript 文件的名称为 [name]_script.js：\n\n\n\n文件名中的 hash 值\n\n通常来说，Rsbuild 只会在生产模式下设置文件名的 hash 值（即 process.env.NODE_ENV === 'production' 时）。\n\n如果你在开发模式下设置了文件名的 hash，那么可能会导致热更新不生效（尤其是 CSS 文件）。这是因为每次文件内容变化时，都会引起 hash\n变化，导致打包工具无法读取到最新的文件内容。\n\n\n模板字符串#\n\n在 output.filename 的值中，你可以使用模板字符串来动态生成文件名。\n\n常用的模板字符串有：\n\n * [name] - entry 名称，即 source.entry 的 key。\n * [contenthash] - 基于文件内容生成的 hash 值。\n * [contenthash:] - 基于文件内容生成的 hash 值，并指定 hash 长度。\n * [ext] - 文件后缀名，包含点号。\n\n> 更多模板字符串可以参考 Rspack - Template String。\n\nTIP\n * filename.html 只能使用部分模板字符串，如 [name]、[contenthash:]。\n * filename.js 和 filename.css 不支持 [ext]。\n\n\n异步模块文件名#\n\n当你在代码中通过 dynamic import 的方式引入模块时，该模块会被单独打包成一个文件，它默认的命名规则如下：\n\n * 在开发模式下会基于模块路径生成名称，比如 dist/static/js/async/src_add_ts.js。\n * 在生产模式下会是一个随机的数字 id，比如\n   dist/static/js/async/798.27e3083e.js，这是为了避免在生产模式中泄露源代码的路径，同时字符数也更少。\n\n\n\n如果你希望为异步模块指定一个固定的名称，可以通过 Rspack 提供的 magic comments 来实现，通过 webpackChunkName\n指定模块名称：\n\n\n\n通过以上写法指定模块名称后，生成的文件会是 dist/static/js/async/my-chunk-name.js。\n\n\n使用函数#\n\noutput.filename.js 和 output.filename.css 可以传入一个函数，这允许你根据文件信息动态生成文件名：\n\n\n\nTIP\n\n除了 output.filename.js 以外，其他类型的文件目前暂不支持使用函数。\n\n\nQuery Hash#\n\n如果你需要在资源的 URL query 上生成 hash 值，可以参考以下配置：\n\n\n\n在这种情况下，JS、CSS 的文件名将不包含 hash，而 HTML 中的 URL 将包含 hash query。\n\n","routePath":"/zh/config/output/filename","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":358},{"text":"模板字符串","id":"模板字符串","depth":2,"charIndex":596},{"text":"异步模块文件名","id":"异步模块文件名","depth":2,"charIndex":955},{"text":"使用函数","id":"使用函数","depth":2,"charIndex":1334},{"text":"Query Hash","id":"query-hash","depth":2,"charIndex":1464}],"domain":"","frontmatter":{},"version":""},{"id":235,"title":"output.injectStyles","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否将 CSS 样式插入到 DOM 中。\n\n默认情况下，Rsbuild 会把 CSS 提取为独立的 .css 文件，并输出到构建产物目录。设置该选项为 true 后，CSS 文件会被内联到 JS\n文件中，并在运行时通过","routePath":"/zh/config/output/inject-styles","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":-1},{"text":"配置 style-loader","id":"配置-style-loader","depth":2,"charIndex":-1},{"text":"使用场景","id":"使用场景","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":236,"title":"output.inlineScripts","content":"","routePath":"/zh/config/output/inline-scripts","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":-1},{"text":"script 标签位置","id":"script-标签位置","depth":3,"charIndex":-1},{"text":"通过正则匹配","id":"通过正则匹配","depth":3,"charIndex":-1},{"text":"通过函数匹配","id":"通过函数匹配","depth":3,"charIndex":-1},{"text":"异步 Chunks","id":"异步-chunks","depth":3,"charIndex":-1},{"text":"选项","id":"选项","depth":2,"charIndex":-1},{"text":"enable","id":"enable","depth":3,"charIndex":-1},{"text":"test","id":"test","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":237,"title":"output.inlineStyles","content":"","routePath":"/zh/config/output/inline-styles","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":-1},{"text":"通过正则匹配","id":"通过正则匹配","depth":3,"charIndex":-1},{"text":"通过函数匹配","id":"通过函数匹配","depth":3,"charIndex":-1},{"text":"选项","id":"选项","depth":2,"charIndex":-1},{"text":"enable","id":"enable","depth":3,"charIndex":-1},{"text":"test","id":"test","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":238,"title":"output.legalComments","content":"#\n\n * 类型： 'linked' | 'inline' | 'none'\n * 默认值： 'linked'\n\n配置 legal comment 的处理方式。\n\nlegal comment 是 JS 或 CSS 文件中的一些特殊注释，这些注释包含 @license 或 @preserve，或是以 //!\n开头。默认情况下，这些注释保留在输出文件中，因为这遵循了代码原作者的意图。\n\n你可以通过 legalComments 来配置相关行为：\n\n * linked：将所有 legal comments 移至 .LEGAL.txt 文件并通过注释链接到它们。\n * inline：保留所有 legal comments。\n * none：移除所有 legal comments。\n\n\n示例#\n\n移除所有 legal comments。\n\n","routePath":"/zh/config/output/legal-comments","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":341}],"domain":"","frontmatter":{},"version":""},{"id":239,"title":"output.manifest","content":"#\n\n * 类型： string | boolean\n * 默认值： false\n\n是否生成 manifest 文件，该文件包含所有构建产物的信息、以及入口模块与构建产物间的映射关系。\n\n当 output.manifest 设置为 true 时，Rsbuild 会在构建后生成一个 manifest.json 文件。当\noutput.manifest 的值是一个字符串时，它将作为 manifest 文件的名称或路径。\n\n\n输出内容#\n\nmanifest 文件默认输出的结构为：\n\n\n\n\n基础示例#\n\n添加以下配置来开启：\n\n\n\n当构建完成后，会自动生成 dist/manifest.json 文件：\n\n\n\n\n设置路径#\n\noutput.manifest 可以是一个相对于 dist 目录的路径，比如输出为 dist/static/my-manifest.json：\n\n","routePath":"/zh/config/output/manifest","lang":"zh","toc":[{"text":"输出内容","id":"输出内容","depth":2,"charIndex":211},{"text":"基础示例","id":"基础示例","depth":2,"charIndex":243},{"text":"设置路径","id":"设置路径","depth":2,"charIndex":304}],"domain":"","frontmatter":{},"version":""},{"id":240,"title":"output.minify","content":"#\n\n * 类型：\n\n\n\n * 默认值： true\n\n用于设置是否在生产模式下开启代码压缩，或是配置压缩工具的选项。\n\n默认情况下，JS 和 CSS 代码会在生产模式构建时被自动压缩，从而提升页面性能。如果你不希望执行代码压缩，可以将 minify 设置为 false\n关闭对所有代码的压缩。或者可以通过 minify 选项的详细配置来控制代码压缩的行为。\n\n下面是各个字段的说明：\n\n * js: 是否开启对 JavaScript 代码的压缩。\n * jsOptions: JS 代码压缩配置，将会与默认配置合并传给 SWC。\n * css: 是否开启对 CSS 代码的压缩。\n * cssOptions: CSS 代码压缩配置，将会与默认配置合并传给 Lightning CSS。\n\n\n示例#\n\n\n禁用所有压缩#\n\n\n\nTIP\n\n该配置项通常用于代码调试和问题排查，不建议在生产模式禁用代码压缩，否则会导致页面性能显著下降。\n\n\n禁用 JavaScript 压缩#\n\n\n\n\nJavaScript 压缩选项#\n\noutput.minify.jsOptions 用于配置 SWC 的压缩选项，具体配置项请参考 SwcJsMinimizerRspackPlugin 文档。\n\n例如，关闭变量和函数名的重命名：\n\n\n\n> 参考 配置 SWC 了解更多。\n\n\nCSS 压缩选项#\n\noutput.minify.cssOptions 用于配置 Lightning CSS 的压缩选项，具体配置项请参考\nLightningCssMinimizerRspackPlugin 文档。\n\n","routePath":"/zh/config/output/minify","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":344},{"text":"禁用所有压缩","id":"禁用所有压缩","depth":3,"charIndex":350},{"text":"禁用 JavaScript 压缩","id":"禁用-javascript-压缩","depth":3,"charIndex":416},{"text":"JavaScript 压缩选项","id":"javascript-压缩选项","depth":3,"charIndex":438},{"text":"CSS 压缩选项","id":"css-压缩选项","depth":3,"charIndex":576}],"domain":"","frontmatter":{},"version":""},{"id":241,"title":"output.overrideBrowserslist","content":"#\n\n * 类型： string[]\n * 默认值： undefined\n\n指定项目兼容的目标浏览器范围。\n\n该值会被 SWC 和 autoprefixer 等工具读取，用来确定需要转换的 JavaScript 语法特性和需要添加的 CSS 浏览器前缀。\n\n\n优先级#\n\noverrideBrowserslist 配置的优先级高于项目中的 .browserslistrc 配置文件和 package.json 中的\nbrowserslist 字段。\n\n大多数场景下，推荐优先使用 .browserslistrc 文件，而不是使用 overrideBrowserslist 配置。因为\n.browserslistrc 文件是官方定义的配置文件，通用性更强，可以被社区中的其他库识别。\n\n> 详见 设置浏览器范围。\n\n\n默认值#\n\n如果项目中没有定义任何 browserslist 相关的配置，也没有定义 overrideBrowserslist，那么 Rsbuild 会设置默认值为：\n\n\n\n\n示例#\n\n下面是兼容移动端 H5 场景的示例：\n\n\n\n查看 browserslist 文档 来了解如何自定义浏览器范围。\n\n\n基于 environment 设置#\n\n当你面向多个 environments 构建时，可以为每个 environment 设置不同的 browserslist：\n\n比如为 web 和 node 环境设置不同的 browserslist：\n\n","routePath":"/zh/config/output/override-browserslist","lang":"zh","toc":[{"text":"优先级","id":"优先级","depth":2,"charIndex":129},{"text":"默认值","id":"默认值","depth":2,"charIndex":357},{"text":"示例","id":"示例","depth":2,"charIndex":445},{"text":"基于 environment 设置","id":"基于-environment-设置","depth":2,"charIndex":508}],"domain":"","frontmatter":{},"version":""},{"id":242,"title":"output.polyfill","content":"#\n\n * 类型： 'entry' | 'usage' | 'off'\n * 默认值： 'off'\n\n控制 polyfills 的注入方式。\n\n> 请查看 Polyfill 方案 了解详细内容。\n\n\n可选值#\n\n\nusage#\n\n当 output.polyfill 配置为 'usage' 时，Rsbuild 会在每个文件中根据代码中使用的 API 注入 polyfills。\n\n\n\n\nentry#\n\n当 output.polyfill 配置为 'entry' 时，Rsbuild 会在每个入口文件中注入 polyfills。\n\n\n\n\noff#\n\n当 output.polyfill 配置为 'off' 时，Rsbuild 不会注入 polyfills，开发者需要自行保证代码的兼容性。\n\n","routePath":"/zh/config/output/polyfill","lang":"zh","toc":[{"text":"可选值","id":"可选值","depth":2,"charIndex":99},{"text":"usage","id":"usage","depth":3,"charIndex":106},{"text":"entry","id":"entry","depth":3,"charIndex":192},{"text":"off","id":"off","depth":3,"charIndex":267}],"domain":"","frontmatter":{},"version":""},{"id":243,"title":"output.sourceMap","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n用于设置是否生成 source map 文件，以及生成哪一种格式的 source map。\n\n什么是 source map\n\nsource map 是保存源代码映射关系的信息文件，它记录了编译后的代码的每一个位置，以及所对应的编译前的位置。通过 source\nmap，可以在调试编译后的代码时，直接查看对应的源代码。\n\n\n默认行为#\n\n默认情况下，Rsbuild 的 source map 生成规则如下：\n\n * 在开发模式构建时，会生成 JS 文件的 source map，便于进行开发调试；不会生成 CSS 文件的 source map。\n * 在生产模式构建时，不会生成 JS 和 CSS 文件的 source map，以提供最佳的构建性能。\n\n\n布尔值#\n\n如果 output.sourceMap 为 true，则会根据 mode 生成 JS 和 CSS 文件的 source map，等价于：\n\n\n\n如果 output.sourceMap 为 false，则不会生成 JS 和 CSS 文件的 source map，等价于：\n\n\n\n\nJS Source Map#\n\nJS 文件的 source map 通过 sourceMap.js 来控制，可以传入 Rspack devtool 选项支持的所有 source map\n格式，设置为 false 为关闭。\n\n比如，如果你需要在所有模式生成高质量的 source map，可以设置为：\n\n\n\n你也可以根据 NODE_ENV 来设置不同的 source map 格式：\n\n\n\n\nCSS Source Map#\n\nCSS 文件的 source map 通过 sourceMap.css 来控制，设置为 true 为开启，设置为 false 为关闭。\n\n比如，如果需要生成 CSS 文件的 source map，可以设置为：\n\n\n\n在生产构建时，我们不推荐同时开启 output.injectStyles 和 output.sourceMap.css，因为\noutput.injectStyles 会将 source map 注入到 JS 文件中，这会增加文件的体积并导致页面加载变慢。\n\n你可以仅在开发模式下开启 CSS 文件的 source map：\n\n","routePath":"/zh/config/output/source-map","lang":"zh","toc":[{"text":"默认行为","id":"默认行为","depth":2,"charIndex":184},{"text":"布尔值","id":"布尔值","depth":2,"charIndex":350},{"text":"JS Source Map","id":"js-source-map","depth":2,"charIndex":495},{"text":"CSS Source Map","id":"css-source-map","depth":2,"charIndex":690}],"domain":"","frontmatter":{},"version":""},{"id":244,"title":"output.target","content":"#\n\n * 类型：\n\n\n\n * 默认值： 'web'\n * 版本： >= 1.0.0\n\n用于设置 Rsbuild 的构建产物类型。\n\nRsbuild 支持多种构建产物类型，分别适用于不同的目标运行环境。在设置产物类型后，Rsbuild 的默认配置会有所变化。\n\n\n默认产物#\n\n默认情况下，target 会被设置为 'web'，并构建出运行在浏览器里的产物。\n\nRsbuild 会读取项目中的 Browserslist 配置，以确定需要兼容的浏览器范围。\n\n\n可选类型#\n\n除了 'web' 外，target 还可以设置为以下值：\n\n * 'node'：构建出运行在 Node.js 环境的产物，通常用于 SSR 等场景。\n * 'web-worker'：构建出运行在 web worker 里的产物。\n\n比如构建出适用于 Node.js 环境的产物：\n\n\n\n\n并行构建#\n\n你可以使用 environments 来并行构建多种 targets。\n\n比如同时构建 web 产物和 node 产物：\n\n\n\n\nNode 产物#\n\n指运行在 Node.js 环境的产物，通常用于 SSR 等场景。\n\n当 target 设置为 'node' 时，Rsbuild 会进行以下处理：\n\n * 将 Rspack 的 target 设置为 'node'。\n * 不会生成 HTML 文件，与 HTML 相关的逻辑也不会执行，因为 Node.js 环境不需要 HTML。\n * 不会开启默认的拆包策略，但 dynamic import 依然可以生效。\n * 不会开启热更新相关的能力。\n * 将 Browserslist 的默认值设置为 ['node >= 16']。\n * 将 output.emitCss 的默认值设置为 false。这意味着 CSS 代码不会被抽取为单独的文件，但产物中会包含 CSS Modules 的\n   id 信息。\n\n\nNode Addons#\n\n当 target 为 'node' 时，Rsbuild 允许你在 JavaScript 文件中引入 Node.js Addons。\n\n例如：\n\n\n\n被引用的 addons 文件会被输出到 dist 目录下：\n\n\n\n\nWeb Worker 产物#\n\n指运行在 Web Worker 环境的产物。\n\n当 target 设置为 'web-worker' 时，Rsbuild 会进行以下处理：\n\n * 将 Rspack 的 target 设置为 'webworker'。\n * 不会生成 HTML 文件，与 HTML 相关的逻辑也不会执行，因为 Web Worker 环境不需要 HTML。\n * 不会开启默认的拆包策略，并且 dynamic import 也不会生效，因为 Web Worker 仅运行支持单个 JavaScript 文件。\n * 将 output.emitCss 的默认值设置为 false。这意味着 CSS 代码不会被抽取为单独的文件，但产物中会包含 CSS Modules 的\n   id 信息。\n * 不会开启热更新相关的能力。\n\n更多信息可参考 使用 Web Workers。\n\n\n其他 target#\n\nRspack 支持的 target 类型更为丰富，比如 electron-main 和 electron-renderer 等。\n\n目前 Rsbuild 暂未支持这些 target，你可以通过 tools.rspack 来配置这些 target。\n\n例如设置 target 为 'electron-main'，这会覆盖 Rsbuild 默认设置的 'web'。\n\n","routePath":"/zh/config/output/target","lang":"zh","toc":[{"text":"默认产物","id":"默认产物","depth":2,"charIndex":131},{"text":"可选类型","id":"可选类型","depth":2,"charIndex":229},{"text":"并行构建","id":"并行构建","depth":2,"charIndex":380},{"text":"Node 产物","id":"node-产物","depth":2,"charIndex":452},{"text":"Node Addons","id":"node-addons","depth":3,"charIndex":816},{"text":"Web Worker 产物","id":"web-worker-产物","depth":2,"charIndex":938},{"text":"其他 target","id":"其他-target","depth":2,"charIndex":1331}],"domain":"","frontmatter":{},"version":""},{"id":245,"title":"performance.bundleAnalyze","content":"#\n\n * 类型： Object | undefined\n\n用于开启 webpack-bundle-analyzer 插件来分析产物体积。\n\n默认情况下，Rsbuild 不会开启 webpack-bundle-analyzer。当开启该功能后，内部的默认配置如下:\n\n\n\n\n启用 Bundle Analyze#\n\n你有两种方式开启 webpack-bundle-analyzer 来分析构建产物的体积。\n\n\n通过环境变量#\n\n添加环境变量 BUNDLE_ANALYZE=true，比如：\n\n\n\n由于 Windows 系统不支持上述用法，你也可以使用 cross-env 来设置环境变量，这可以确保在不同的操作系统中都能正常使用：\n\n\n\n\n通过配置项#\n\n配置 performance.bundleAnalyze 来固定开启：\n\n\n\n\n分析结果#\n\n在启用后，Rsbuild 会生成一个分析构建产物体积的 HTML 文件，并在 Terminal 中打印以下日志：\n\n\n\n手动在浏览器中打开该文件，可以看到打包产物的瓦片图；区块的面积越大，说明该模块的体积越大。\n\n\n\n\n覆盖默认配置#\n\n你可以通过 performance.bundleAnalyze 来覆盖默认配置，比如开启 server 模式：\n\n\n\n\nSize 类型#\n\n在 webpack-bundle-analyzer 的面板中，你可以在左上角控制 Size 类型（默认为 Parsed）：\n\n * Stat：从打包工具的 stats 对象中获取的体积，它反映了代码在压缩之前的体积。\n * Parsed：磁盘上的文件体积，它反映了代码在压缩之后的体积。\n * Gzipped：浏览器里请求的文件体积，它反映了代码在压缩和 gzip 后的体积。\n\n\n生成 stats.json#\n\ngenerateStatsFile 设置为 true 时，将会生成 stats JSON 文件。\n\n\n\n\n注意事项#\n\n 1. 开启 Server 模式会导致 build 进程不能正常退出。\n 2. 开启 bundleAnalyzer 会降低构建性能。因此，在日常开发过程中不应该开启此配置项，建议通过 BUNDLE_ANALYZE\n    环境变量来按需开启。\n 3. 由于 dev 阶段不会进行代码压缩等优化，无法反映真实的产物体积，因此建议在 build 阶段分析产物体积。\n 4. 如果在 dev 阶段开启 bundleAnalyzer，为了保证 webpack-bundle-analyzer\n    可以读取到静态资源的内容，Rsbuild 会自动开启 dev.writeToDisk 选项。","routePath":"/zh/config/performance/bundle-analyze","lang":"zh","toc":[{"text":"启用 Bundle Analyze","id":"启用-bundle-analyze","depth":2,"charIndex":136},{"text":"通过环境变量","id":"通过环境变量","depth":3,"charIndex":203},{"text":"通过配置项","id":"通过配置项","depth":3,"charIndex":318},{"text":"分析结果","id":"分析结果","depth":3,"charIndex":366},{"text":"覆盖默认配置","id":"覆盖默认配置","depth":2,"charIndex":483},{"text":"Size 类型","id":"size-类型","depth":2,"charIndex":552},{"text":"生成 stats.json","id":"生成-statsjson","depth":2,"charIndex":753},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":822}],"domain":"","frontmatter":{},"version":""},{"id":246,"title":"performance.chunkSplit","content":"#\n\n * 类型： ChunkSplit\n * 默认值： { strategy: 'split-by-experience' }\n\nperformance.chunkSplit 用于配置 Rsbuild 的拆包策略。\n\nTIP\n\n请参考 代码拆分 来了解完整的用法。\n\n\nchunkSplit.strategy#\n\nRsbuild 支持设置以下几种拆包策略：\n\n * split-by-experience: 根据经验制定的拆分策略，自动将一些常用的 npm 包拆分为体积适中的 chunk。\n * split-by-module: 按 NPM 包的粒度拆分，每个 NPM 包对应一个 chunk。\n * split-by-size：根据模块大小自动进行拆分。\n * all-in-one: 将所有代码全部打包到一个 chunk 中。\n * single-vendor: 将所有 NPM 包的代码打包到一个单独的 chunk 中。\n * custom: 自定义拆包配置。\n\n\n类型定义#\n\nperformance.chunkSplit 的类型定义如下:\n\n\n\n\n默认策略#\n\nRsbuild 默认采用 split-by-experience 策略，如果你想使用其他拆包策略，可以通过 strategy 选项来指定，比如：\n\n\n\n\nchunkSplit.minSize#\n\n * 类型： number\n * 默认值： 10000\n\n当 chunkSplit.strategy 为 split-by-size 时，可以通过 chunkSplit.minSize 配置项来指定 chunk\n的最小大小，单位为字节。默认值为 10000。比如:\n\n\n\n\nchunkSplit.maxSize#\n\n * 类型： number\n * 默认值： Number.POSITIVE_INFINITY\n\n当 chunkSplit.strategy 为 split-by-size 时，可以通过 chunkSplit.maxSize 配置项来指定 chunk\n的最大大小，单位为字节。默认值为 Number.POSITIVE_INFINITY。比如:\n\n\n\n\nchunkSplit.forceSplitting#\n\n * 类型： RegExp[] | Record\n * 默认值： []\n\n通过 chunkSplit.forceSplitting 配置项可以将指定的模块强制拆分为一个独立的 chunk。\n\n比如将 node_modules 下的 axios 库拆分到 axios.js 中：\n\n\n\n相比直接配置 Rspack 的 splitChunks，这是一个更加简便的方式。\n\nTIP\n\n注意，通过 forceSplitting 配置拆分的 chunk 会通过","routePath":"/zh/config/performance/chunk-split","lang":"zh","toc":[{"text":"chunkSplit.strategy","id":"chunksplitstrategy","depth":2,"charIndex":135},{"text":"类型定义","id":"类型定义","depth":2,"charIndex":437},{"text":"默认策略","id":"默认策略","depth":3,"charIndex":480},{"text":"chunkSplit.minSize","id":"chunksplitminsize","depth":2,"charIndex":564},{"text":"chunkSplit.maxSize","id":"chunksplitmaxsize","depth":2,"charIndex":722},{"text":"chunkSplit.forceSplitting","id":"chunksplitforcesplitting","depth":2,"charIndex":918},{"text":"chunkSplit.splitChunks","id":"chunksplitsplitchunks","depth":2,"charIndex":-1},{"text":"chunkSplit.override","id":"chunksplitoverride","depth":2,"charIndex":-1},{"text":"产物类型","id":"产物类型","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":247,"title":"performance.dnsPrefetch","content":"#\n\n * Type: string[] | undefined\n * 默认值： undefined\n\n注入 标签到 HTML 文件中。\n\n\n何时使用#\n\n当浏览器从（第三方）服务器请求资源时，必须先将该跨源域名解析为 IP 地址，然后浏览器才能发出请求。此过程称为 DNS 解析。虽然 DNS\n缓存可以帮助减少此延迟，但 DNS 解析可能会给请求增加明显的延迟。\n\n配置 dns-prefetch 可以在请求资源之前解析域名，降低请求延迟，提升加载性能。\n\n更多信息请参考：使用 dns-prefetch。\n\n\n示例#\n\n\n\n在 HTML 中生成的标签为：\n\n\n\n\n注意事项#\n\n一般来说，网站不应该配置超过 10 个 DNS prefetch。\n\n使用过多的 DNS prefetch 可能会导致性能问题，因为浏览器对维持的 DNS 请求数量有限制。进行过多的 DNS 预解析，或者对最终没有使用的\ndomain 进行 DNS 预解析，会造成资源争用，并可能使浏览器运行效率降低。\n\n详见 What Is a DNS Prefetch?。","routePath":"/zh/config/performance/dns-prefetch","lang":"zh","toc":[{"text":"何时使用","id":"何时使用","depth":2,"charIndex":70},{"text":"示例","id":"示例","depth":2,"charIndex":256},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":283}],"domain":"","frontmatter":{},"version":""},{"id":248,"title":"performance.preconnect","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n注入 标签到 HTML 文件中。\n\n\n何时使用#\n\n元素的 rel 属性的 preconnect\n关键字是对浏览器的一种提示，即用户很可能需要来自目标来源的资源，因此浏览器很可能通过抢先启动与该源的连接来改善用户体验。通过抢先执行部分或全部握手（HTTP 为\nDNS+TCP，HTTPS 为 DNS+TCP+TLS），预连接可加快未来从给定源加载的速度。\n\n将为未来的跨源 HTTP 请求、导航或子资源带来好处。它对同源请求没有好处，因为连接已经打开。\n\n如果一个页面需要与许多第三方域建立连接，将它们全部预连接可能会适得其反。 提示最好只用于最关键的连接。对于其他连接，只需使用 ，以节省第一步 DNS\n查询的时间。\n\n\n示例#\n\n\n\n生成的 HTML 标签如下：\n\n\n\n\n选项#\n\n\nhref#\n\n * 类型： string\n * 默认值： undefined\n\n指定要预连接的 URL。\n\n\n\n\ncrossorigin#\n\n * 类型： boolean\n * 默认值： false\n\n指定是否添加 crossorigin 属性。\n\n\n\n生成的 HTML 标签如下：\n\n\n\nTIP\n\n参考该 链接 了解 crossorigin 属性的使用场景。","routePath":"/zh/config/performance/preconnect","lang":"zh","toc":[{"text":"何时使用","id":"何时使用","depth":2,"charIndex":50},{"text":"示例","id":"示例","depth":2,"charIndex":343},{"text":"选项","id":"选项","depth":2,"charIndex":369},{"text":"href","id":"href","depth":3,"charIndex":375},{"text":"crossorigin","id":"crossorigin","depth":3,"charIndex":432}],"domain":"","frontmatter":{},"version":""},{"id":249,"title":"performance.prefetch","content":"#\n\n * 类型： undefined | true | PrefetchOption\n\n\n\n * 默认值： undefined\n\n为 Rsbuild 构建生成的静态资源注入 标签。\n\n\n什么是 prefetch#\n\n元素的 rel 属性中的 prefetch\n关键字是为了提示浏览器，用户未来的浏览有可能需要加载目标资源，所以浏览器有可能通过事先获取和缓存对应资源，优化用户体验。\n\n\n启用 prefetch#\n\n当设置 performance.prefetch 为 true 时，Rsbuild 将使用以下默认选项，对资源进行预获取，这表示 prefetch\n当前页面的所有异步资源，包含异步 JS 及其关联的 CSS、image、font 等资源。\n\n\n\n比如，在入口文件中动态引入了其他模块：\n\n\n\n在 HTML 中注入的标签为：\n\n\n\n\n手动注入#\n\nperformance.prefetch 只能为 Rsbuild 构建生成的静态资源注入 prefetch 标签，如果你需要 prefetch\n其他资源，可以通过 html.tags 手动添加标签：\n\n\n\n注入的 HTML 标签如下：\n\n\n\n\n选项#\n\n当 performance.prefetch 的值为 object 类型时，Rsbuild 会根据当前选项对指定资源开启 prefetch 能力。\n\n\nprefetch.type#\n\ntype 字段控制了哪些资源会被预获取，同时支持通过 include 和 exclude 对指定资源进行二次过滤。\n\n目前支持的资源类型如下：\n\n * async-chunks: prefetch 所有异步资源（当前页面），包含异步 JS 及其关联的 CSS、image、font 等资源。\n * initial: prefetch 所有非异步资源（当前页面）。需要注意的是，如果当前脚本已经被添加到 HTML 模版中，则不会进行额外的预获取。\n * all-chunks: prefetch 所有资源（当前页面），包含所有异步和非异步资源。\n * all-assets: prefetch 所有资源，MPA 场景下会包含其他页面的资源。\n\n\n示例#\n\n当你希望对当前页面中所有 png 格式的图片资源进行 prefetch 时，可以配置如下：\n\n","routePath":"/zh/config/performance/prefetch","lang":"zh","toc":[{"text":"什么是 prefetch","id":"什么是-prefetch","depth":2,"charIndex":93},{"text":"启用 prefetch","id":"启用-prefetch","depth":2,"charIndex":193},{"text":"手动注入","id":"手动注入","depth":2,"charIndex":373},{"text":"选项","id":"选项","depth":2,"charIndex":502},{"text":"prefetch.type","id":"prefetchtype","depth":3,"charIndex":583},{"text":"示例","id":"示例","depth":3,"charIndex":921}],"domain":"","frontmatter":{},"version":""},{"id":250,"title":"performance.preload","content":"#\n\n * 类型： undefined | true | PreloadOption\n\n\n\n * 默认值： undefined\n\n为 Rsbuild 构建生成的静态资源注入 标签。\n\n\n什么是 preload#\n\n元素的 rel 属性的 preload 值允许你在 HTML 的\n中声明获取请求，指定页面很快就需要的资源，这些资源是你希望在页面生命周期的早期就开始加载的，早于浏览器的主要渲染机制启动。\n\n这可以确保它们更早可用，并且不太可能阻塞页面的渲染，从而提高性能。尽管名称中包含 \"load\"\n一词，但它并不加载和执行脚本，而只是安排脚本以更高的优先级进行下载和缓存。\n\n\n启用 preload#\n\n当设置 performance.preload 为 true 时，Rsbuild 将使用以下默认选项，对资源进行预获取，这表示 preload\n当前页面的所有异步资源，包含异步 JS 及其关联的 CSS、image、font 等资源。\n\n\n\n比如，在入口文件中动态引入了其他模块：\n\n\n\n在 HTML 中注入的标签为：\n\n\n\n\n手动注入#\n\nperformance.preload 只能为 Rsbuild 构建生成的静态资源注入 preload 标签，如果你需要 preload 其他资源，可以通过\nhtml.tags 手动添加标签：\n\n\n\n注入的 HTML 标签如下：\n\n\n\n\n选项#\n\n当 performance.preload 的值为 object 类型时，Rsbuild 会根据当前选项对指定资源开启 preload 能力。\n\n\npreload.type#\n\ntype 字段控制了哪些资源会被预加载，同时支持通过 include 和 exclude 对指定资源进行二次过滤。\n\n目前支持的资源类型如下：\n\n * async-chunks: preload 所有异步资源（当前页面），包含异步 JS 及其关联的 CSS、image、font 等资源。\n * initial: preload 所有非异步资源（当前页面）。需要注意的是，如果当前脚本已经被添加到 HTML 模版中，则不会进行额外的预加载。\n * all-chunks: preload 所有资源（当前页面），包含所有异步和非异步资源。\n * all-assets: preload 所有资源，MPA 场景下会包含其他页面的资源。\n\n\n示例#\n\n当你希望对当前页面中所有 png 格式的图片资源进行 preload 时，可以配置如下：\n\n","routePath":"/zh/config/performance/preload","lang":"zh","toc":[{"text":"什么是 preload","id":"什么是-preload","depth":2,"charIndex":92},{"text":"启用 preload","id":"启用-preload","depth":2,"charIndex":290},{"text":"手动注入","id":"手动注入","depth":2,"charIndex":467},{"text":"选项","id":"选项","depth":2,"charIndex":593},{"text":"preload.type","id":"preloadtype","depth":3,"charIndex":672},{"text":"示例","id":"示例","depth":3,"charIndex":1005}],"domain":"","frontmatter":{},"version":""},{"id":251,"title":"performance.printFileSize","content":"#\n\n * 类型：\n\n\n\n * 默认值： true\n\n是否在生产模式构建后输出所有静态资源文件的体积。\n\n\n默认输出#\n\n默认输出的日志如下：\n\n\n\n\n禁用输出#\n\n如果不需要输出任何信息，可以将 printFileSize 置为 false 将其禁用：\n\n\n\n\n选项#\n\n你可以通过选项来自定义输出的格式。\n\n\ntotal#\n\n * 类型： boolean\n * 默认值： true\n\n是否输出所有静态资源的总体积。\n\n\n\nTIP\n\n如果本次构建只生成了一个静态资源，则不会输出总体积。\n\n\ndetail#\n\n * 类型： boolean\n * 默认值： true\n\n是否输出每个静态资源的体积。\n\n如果你不需要查看每个静态资源文件的体积，可以把 detail 设置为 false，此时仅输出总体积：\n\n\n\n\ncompressed#\n\n * 类型： boolean\n * 默认值： 当 output.target 为 node 时为 false，否则为 true\n\n是否输出 gzip 压缩后的体积。\n\n如果你不需要查看 gzip 压缩后的体积，可以把 compressed 设置为 false，这在大型项目中可以节省一些 gzip 计算的耗时：\n\n\n\nTIP\n\n该数据仅用于参考 gzip 压缩后的体积，Rsbuild 并不会对静态资源开启 gzip 压缩。通常，你需要在服务器端开启 gzip 压缩，例如使用 nginx\n的 gzip 模块。\n\n\ninclude#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n一个过滤函数，用于确定哪些静态资源需要输出。\n\n如果返回 false，则该静态资源将被排除，不会被包含在总体积或详细体积中。\n\n例如，只输出体积大于 10kB 的静态资源：\n\n\n\n或者只输出体积大于 10kB 的 .js 文件：\n\n\n\n\nexclude#\n\n * 类型：\n\n\n\n * 默认值： (asset) => /\\.(?:map|LICENSE\\.txt)$/.test(asset.name)\n\n一个过滤函数，用于确定哪些静态资源需要被排除。如果同时设置了 include 和 exclude，则 exclude 优先级更高。\n\nRsbuild 默认排除 source map 和 license 文件，因为这些文件不会影响页面加载的性能。\n\n例如，额外再排除 .html 文件：\n\n","routePath":"/zh/config/performance/print-file-size","lang":"zh","toc":[{"text":"默认输出","id":"默认输出","depth":2,"charIndex":53},{"text":"禁用输出","id":"禁用输出","depth":2,"charIndex":75},{"text":"选项","id":"选项","depth":2,"charIndex":131},{"text":"total","id":"total","depth":3,"charIndex":156},{"text":"detail","id":"detail","depth":3,"charIndex":246},{"text":"compressed","id":"compressed","depth":3,"charIndex":355},{"text":"include","id":"include","depth":3,"charIndex":626},{"text":"exclude","id":"exclude","depth":3,"charIndex":784}],"domain":"","frontmatter":{},"version":""},{"id":252,"title":"performance.profile","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否捕获每个模块的耗时信息，对应 Rspack 的 profile 配置。\n\n开启后：\n\n * Rsbuild 会通过 bundle analyzer 自动生成 dist/stats.json 文件。\n * Rspack 在生成 stats.json 等统计文件时，会将构建的耗时信息也包含进去。\n\n\n示例#\n\n\n\n\n指南#\n\n请参考 构建性能分析 章节来了解更多分析构建性能方法。","routePath":"/zh/config/performance/profile","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":183},{"text":"指南","id":"指南","depth":2,"charIndex":191}],"domain":"","frontmatter":{},"version":""},{"id":253,"title":"performance.removeConsole","content":"#\n\n * 类型： boolean | ConsoleType[]\n * 默认值： false\n\n在生产模式构建时，是否自动移除代码中的 console.[methodName]。\n\n\n全部移除#\n\n当 removeConsole 被设置为 true 时，会移除所有类型的 console.[methodName]：\n\n\n\n\n指定类型#\n\n你也可以指定仅移除特定类型的 console.[methodName]，比如移除 console.log 和 console.warn：\n\n\n\n目前支持配置以下类型的 console：\n\n","routePath":"/zh/config/performance/remove-console","lang":"zh","toc":[{"text":"全部移除","id":"全部移除","depth":2,"charIndex":92},{"text":"指定类型","id":"指定类型","depth":2,"charIndex":162}],"domain":"","frontmatter":{},"version":""},{"id":254,"title":"performance.removeMomentLocale","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否移除 moment.js 的语言包文件。\n\nmoment.js 默认包含了大量的语言包文件，会导致打包后的包体积增大。\n\n当项目中使用了 moment.js 时，推荐开启此选项，自动排除所有的语言包文件：\n\n\n\n开启后，可以通过以下方式来加载语言包文件：\n\n","routePath":"/zh/config/performance/remove-moment-locale","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":255,"title":"plugins","content":"#\n\n用于注册 Rsbuild 插件。\n\n插件数组中的异步插件（promise）会自动被 resolve，falsy value 会被忽略。\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n> 请查看 插件列表 页面来发现所有可用的插件。\n\n\n示例#\n\n比如注册 Rsbuild 的 Stylus 插件。\n\n * 安装插件：\n\n * 注册插件：\n\n\n\n\n执行顺序#\n\n默认情况下，插件会按照 plugins 数组的顺序依次执行，Rsbuild 内置插件的执行时机早于用户注册的插件。\n\n当插件内部使用了控制顺序的相关字段，比如 pre、post 时，执行顺序会基于它们进行调整，详见 前置插件。\n\n\n嵌套插件#\n\nRsbuild 还支持添加嵌套插件，你可以传入一个包含多个插件的数组，类似于一个插件预设集合，这对于实现需要多个插件组合的复杂功能（例如框架集成）很有帮助。\n\n\n\n\n本地插件#\n\n如果本地代码仓库中包含了一些 Rsbuild 插件，你可以直接通过相对路径引入。\n\n\n\n\n插件选项#\n\n如果插件提供了一些选项，你可以通过插件函数的参数传入配置。\n\n\n\n\n插件注册时机#\n\n需要注意的是，插件的注册只能在 Rsbuild 初始化阶段进行，你不能在一个插件内通过插件 API 动态地添加其他插件：\n\n\n\n\nRspack 插件#\n\nplugins 选项用于注册 Rsbuild 插件，如果你需要注册 Rspack 或 Webpack 插件，请使用 tools.rspack。\n\n\n\n\nUnplugin#\n\nunplugin 是一个适用于不同构建工具的统一插件系统。你可以在 Rsbuild 中使用基于 unplugin 实现的插件，只需要引入插件的 /rspack\n子路径，并通过 tools.rspack 注册即可。\n\n下面是使用 unplugin-vue-components 的示例：\n\n\n\nTIP\n\n在使用 unplugin 的 transform hook 时，请使用 transformInclude hook 来匹配指定的模块。当 transform\nhook 会匹配到 .html 模块时，会代替 html-rspack-plugin 默认的 EJS 转换。\n\n> 请确保依赖的 unplugin 包版本 >= v1.6.0。","routePath":"/zh/config/plugins","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":127},{"text":"执行顺序","id":"执行顺序","depth":2,"charIndex":182},{"text":"嵌套插件","id":"嵌套插件","depth":2,"charIndex":305},{"text":"本地插件","id":"本地插件","depth":2,"charIndex":395},{"text":"插件选项","id":"插件选项","depth":2,"charIndex":447},{"text":"插件注册时机","id":"插件注册时机","depth":2,"charIndex":488},{"text":"Rspack 插件","id":"rspack-插件","depth":2,"charIndex":562},{"text":"Unplugin","id":"unplugin","depth":2,"charIndex":650}],"domain":"","frontmatter":{},"version":""},{"id":256,"title":"resolve.aliasStrategy","content":"#\n\n * 类型： 'prefer-tsconfig' | 'prefer-alias'\n * 默认值： 'prefer-tsconfig'\n * 版本： >=1.1.7\n\n控制 tsconfig.json 中的 paths 选项与 Rsbuild 的 resolve.alias 选项的优先级。\n\n\nprefer-tsconfig#\n\nresolve.aliasStrategy 默认为 'prefer-tsconfig'，此时 tsconfig.json 中的 paths 选项和打包工具的\nalias 选项都会生效，但 tsconfig paths 选项的优先级更高。\n\n比如同时配置以下内容：\n\n * tsconfig paths:\n\n\n\n * resolve.alias:\n\n\n\n由于 tsconfig paths 的优先级更高，所以：\n\n * @common 会使用 tsconfig paths 定义的值，指向 ./src/common-1\n * @utils 会使用 resolve.alias 定义的值，指向 ./src/utils\n\n\nprefer-alias#\n\n当 resolve.aliasStrategy 的值为 prefer-alias 时，tsconfig.json 中的 paths 选项只用于提供\nTypeScript 类型定义，而不会对打包结果产生任何影响。此时，构建工具只会读取 alias 选项作为路径别名。\n\n\n\n比如同时配置以下内容：\n\n * tsconfig paths:\n\n\n\n * resolve.alias:\n\n\n\n由于 tsconfig paths 只用于提供类型，所以最终只有 @common 别名生效，并指向 ./src/common-2 目录。\n\n大部分情况下你不需要使用 prefer-alias，但当你需要动态生成一些别名配置时，可以考虑使用它。比如，基于环境变量来生成 alias 选项：\n\n","routePath":"/zh/config/resolve/alias-strategy","lang":"zh","toc":[{"text":"prefer-tsconfig","id":"prefer-tsconfig","depth":3,"charIndex":150},{"text":"prefer-alias","id":"prefer-alias","depth":3,"charIndex":477}],"domain":"","frontmatter":{},"version":""},{"id":257,"title":"resolve.alias","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n * 版本： >=1.1.7\n\n设置文件引用的别名，对应 Rspack 的 resolve.alias 配置。\n\n对于 TypeScript 项目，你只需要在 tsconfig.json 中配置 compilerOptions.paths 即可，Rsbuild\n会自动识别它，不需要额外配置 resolve.alias 字段，详见 「路径别名」。\n\nTIP\n\n在 Rsbuild 1.1.7 之前的版本，你可以使用 source.alias 来设置 alias，但该字段将在下一个大版本中被移除。\n\n\nObject 类型#\n\nalias 的值可以定义为 Object 类型，其中的相对路径会自动被 Rsbuild 转换为绝对路径。\n\n\n\n以上配置完成后，如果你在代码中引用 @common/Foo.tsx, 则会映射到 /src/common/Foo.tsx 路径上。\n\n\nFunction 类型#\n\nalias 的值定义为函数时，可以接受预设的 alias 对象，并对其进行修改。\n\n\n\n如果你需要移除 Rsbuild 内置的 @swc/helpers 别名，可以在函数中删除它：\n\n\n\n你也可以在函数中返回一个新对象作为最终结果，新对象会覆盖预设的 alias 对象。\n\n\n\n\n基于 environment 设置#\n\n当你面向多个 environments 构建时，可以为每个 environment 设置不同的 alias：\n\n比如为 web 和 node 环境设置不同的 alias：\n\n\n\n\n精确匹配#\n\n默认情况，resolve.alias 会自动匹配子路径，比如以下配置：\n\n\n\n它的匹配结果如下：\n\n\n\n你可以添加 $ 符号来开启精确匹配，开启后将不会自动匹配子路径。\n\n\n\n它的匹配结果如下：\n\n\n\n\n处理 npm 包#\n\n你可以使用 alias 将某个 npm 包指向统一的目录。\n\n比如项目中安装了多份 react，你可以将 react 统一指向根目录的 node_modules 中安装的版本，避免出现打包多份 React 代码的问题。\n\n\n\n当你在使用 alias 处理 npm 包时，请留意项目中是否使用了这个包不同的 major 版本。\n\n比如你的项目中某个模块或 npm 依赖使用了 React 19 的 API，如果你将 React alias 到 17 版本，就会导致该模块无法引用到\nReact 19 的 API，导致代码异常。\n\n\n处理 Loader#\n\nresolve.alias 不支持为 loader 设置别名。如果你需要为 loader 设置别名，可以使用 Rspack 的 resolveLoader\n配置项。\n\n","routePath":"/zh/config/resolve/alias","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":274},{"text":"Function 类型","id":"function-类型","depth":2,"charIndex":410},{"text":"基于 environment 设置","id":"基于-environment-设置","depth":2,"charIndex":564},{"text":"精确匹配","id":"精确匹配","depth":2,"charIndex":674},{"text":"处理 npm 包","id":"处理-npm-包","depth":2,"charIndex":783},{"text":"处理 Loader","id":"处理-loader","depth":2,"charIndex":1059}],"domain":"","frontmatter":{},"version":""},{"id":258,"title":"resolve.dedupe","content":"#\n\n * 类型： string[]\n * 默认值： undefined\n * 版本： >= 1.1.7\n\n强制 Rsbuild 从项目根目录解析指定的包，这可以用于移除重复包和减少包大小。\n\n\n示例#\n\n例如，假设你的项目是基于 React 19 开发的，而你正在使用的 foo 包依赖了 React 17，那么你的项目中就会存在两个不同版本的 React：\n\n\n\n在这种情况下，你可以使用 resolve.dedupe 配置项来移除重复的 React 包，将所有 react 和 react-dom 包都解析到\n/node_modules/react 和 /node_modules/react-dom：\n\n\n\n注意，如果使用 resolve.dedupe 将一个包的不同 major 版本统一为同一个，可能导致一些包无法正常工作，因为它们可能依赖于特定版本的 API\n或功能。\n\n例如，如果 foo 依赖了一个 React 17 特有的 API 或功能，此时将 React 17 和 React 19 统一为 React 19，就可能会导致\nfoo 无法正常工作。\n\n\n实现原理#\n\nresolve.dedupe 是基于 resolve.alias 实现的，它会在当前项目的根目录下通过 require.resolve\n获取指定包的路径，并设置到 alias 中。\n\n在上述的例子中，resolve.dedupe 会被转换为以下 alias 配置：\n\n\n\nresolve.dedupe 生成的 alias 会与项目中配置的 resolve.alias 合并，当两者配置了相同的 key 时，resolve.alias\n的优先级更高。","routePath":"/zh/config/resolve/dedupe","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":97},{"text":"实现原理","id":"实现原理","depth":2,"charIndex":487}],"domain":"","frontmatter":{},"version":""},{"id":259,"title":"resolve.extensions","content":"#\n\n * 类型： string[]\n * 默认值： ['.ts', '.tsx', '.mjs', '.js', '.jsx', '.json']\n * 版本： >= 1.1.9\n\n自动添加导入文件的扩展名。这意味着你可以导入文件，而不需要显式地写它们的扩展名。\n\n例如，如果导入 './index'，Rsbuild 将尝试按以下顺序解析：\n\n * ./index.ts\n * ./index.tsx\n * ./index.mjs\n * ./index.js\n * ./index.jsx\n * ./index.json\n\nTIP\n\n不建议使用 resolve.extensions 来省略 .vue 等自定义的扩展名，因为这可能会干扰 IDE 和类型支持。\n\n\n示例#\n\nresolve.extensions 配置的值会覆盖 Rsbuild 的默认值：\n\n\n\n\nRspack 配置#\n\nresolve.extensions 是 Rspack 提供的配置，参考 Rspack - resolve.extensions。\n\n事实上，你也可以使用 tools.rspack 来配置它：\n\n\n\n这两种用法的区别在于配置合并的方式。\n\ntools.rspack 基于 webpack-merge 来合并配置中的数组，这意味着 tools.rspack.resolve.extensions 会与\nRsbuild 的默认值合并，而不是覆盖它。","routePath":"/zh/config/resolve/extensions","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":332},{"text":"Rspack 配置","id":"rspack-配置","depth":2,"charIndex":382}],"domain":"","frontmatter":{},"version":""},{"id":260,"title":"root","content":"#\n\n * 类型： string\n * 默认值： process.cwd()\n * 版本： >= 1.0.0\n\n指定项目根目录。可以是绝对路径，也可以是相对于 process.cwd() 的路径。\n\nRsbuild root 的值也会传递给 Rspack 的 context 配置。\n\nTIP\n\nroot 的值不会影响 .env 文件的加载路径，因为 .env 文件早于 Rsbuild 的配置文件被解析。\n\nRsbuild CLI 支持使用 --root 选项来指定根目录，它可以影响 .env 文件的加载路径，详见 \"CLI\"。\n\n\n示例#\n\n * 相对路径：\n\n\n\n * 绝对路径：\n\n","routePath":"/zh/config/root","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":268}],"domain":"","frontmatter":{},"version":""},{"id":261,"title":"security.nonce","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n为 HTML 所引入的脚本资源添加随机属性值 nonce，使浏览器在解析到带有匹配 nonce 值的内联脚本时，能判断该脚本是否能执行。\n\n\n什么是 nonce#\n\nnonce 机制在 Content Security Policy（CSP，内容安全策略）中起到关键作用，用于提升网页安全性。其允许开发者在 CSP 中为内联","routePath":"/zh/config/security/nonce","lang":"zh","toc":[{"text":"什么是 nonce","id":"什么是-nonce","depth":2,"charIndex":102},{"text":"示例","id":"示例","depth":2,"charIndex":-1},{"text":"生效范围","id":"生效范围","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":262,"title":"security.sri","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n为 HTML 所引入的\n\n\n注意#\n\nRsbuild 的 security.sri 仅会作用于 Rsbuild 生成的标签，不会作用于：\n\n * HTML 模板中原有的标签。\n * Rspack 异步注入的标签。\n * 通过客户端 JavaScript 代码插入的标签。\n\nRsbuild 会处理以下几种 标签：\n\n * \n * \n * \n\n\n选项#\n\n\nenable#\n\n * 类型： 'auto' | boolean\n * 默认值： false\n\n是否启用 SRI。'auto' 表示在生产构建时开启，开发构建时关闭。\n\n\n\n> 通常你不需要在开发阶段开启 SRI。\n\n\nalgorithm#\n\n * 类型： 'sha256' | 'sha384' | 'sha512'\n * 默认值： 'sha384'\n\n指定用于计算 integrity hash 的算法。\n\n比如设置为 sha512：\n\n\n\n生成的 integrity 属性的值会以 sha512- 为前缀：\n\n\n\n> 参考：Cryptographic hash functions。","routePath":"/zh/config/security/sri","lang":"zh","toc":[{"text":"什么是 SRI","id":"什么是-sri","depth":2,"charIndex":-1},{"text":"示例","id":"示例","depth":2,"charIndex":-1},{"text":"注意","id":"注意","depth":2,"charIndex":45},{"text":"选项","id":"选项","depth":2,"charIndex":203},{"text":"enable","id":"enable","depth":3,"charIndex":209},{"text":"algorithm","id":"algorithm","depth":3,"charIndex":319}],"domain":"","frontmatter":{},"version":""},{"id":263,"title":"server.base","content":"#\n\n * 类型： string\n * 默认值： /\n * 版本： >= 1.0.10\n\nserver.base 用于配置服务端的基础路径。\n\n\n示例#\n\n默认情况下，服务端的基础路径为 /，用户可通过 http://localhost:3000 访问到 index.html。\n\n当你希望通过 http://localhost:3000/foo/ 访问到 index.html 时，可以将 server.base 修改为 /foo。\n\n\n\n\n静态资源 URL 前缀#\n\n默认情况下，dev.assetPrefix 和 output.assetPrefix 会读取 server.base 的值作为 assetPrefix\n的默认值。\n\n当 server.base 为 /foo 时，默认在浏览器中加载的资源 URL 如下：\n\n\n\n此时，可以通过 http://localhost:3000/foo/ 访问到 index.html 以及其他静态资源产物。\n\n如果您不希望使用此默认行为，可以通过显式设置 dev.assetPrefix / output.assetPrefix 来覆盖：\n\n","routePath":"/zh/config/server/base","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":72},{"text":"静态资源 URL 前缀","id":"静态资源-url-前缀","depth":2,"charIndex":221}],"domain":"","frontmatter":{},"version":""},{"id":264,"title":"server.compress","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n是否对静态资源启用 gzip 压缩。\n\n如果你需要禁用 gzip 压缩，可以将 compress 设置为 false：\n\n","routePath":"/zh/config/server/compress","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":265,"title":"server.cors","content":"#\n\n * 类型： boolean | import('cors').CorsOptions\n * 默认值： true\n * 版本： >= 1.1.11\n\n为开发服务器和预览服务器配置 CORS 选项，基于 cors 中间件实现。\n\n * true：启用 CORS 并使用默认选项。\n * false：禁用 CORS。\n * object：启用 CORS 并使用指定的选项。\n\n\n示例#\n\n仅为开发服务器启用 CORS：\n\n\n\n禁用 CORS：\n\n\n\n\n选项#\n\ncors 选项可以是一个对象，与 cors 中间件的选项相同。\n\n默认配置等同于：\n\n\n\n例如，使用 origin 选项配置 Access-Control-Allow-Origin 头：\n\n","routePath":"/zh/config/server/cors","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":189},{"text":"选项","id":"选项","depth":2,"charIndex":226}],"domain":"","frontmatter":{},"version":""},{"id":266,"title":"server.headers","content":"#\n\n * 类型： Record\n * 默认值： undefined\n\n设置自定义响应头。\n\n","routePath":"/zh/config/server/headers","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":267,"title":"server.historyApiFallback","content":"#\n\n * 类型： boolean | ConnectHistoryApiFallbackOptions\n * 默认值： false\n\n当 Rsbuild 默认的 页面路由 行为无法满足你的需求时，例如，希望在访问 / 时可以访问 main.html，可通过\nserver.historyApiFallback 进行设置。\n\n\n示例#\n\n将 historyApiFallback.index 设置为 main.html，此时在访问 / 或其他原本会 404 的路由时可以访问到 main.html。\n\n\n\n当你的应用包含多个 entry 时，你可能希望不同的访问可以 fallback 到不同的页面上。此时，你可以通过 rewrites 选项来设置更复杂的规则：\n\n\n\n更多选项和详细信息可参考 connect-history-api-fallback 文档。","routePath":"/zh/config/server/history-api-fallback","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":163}],"domain":"","frontmatter":{},"version":""},{"id":268,"title":"server.host","content":"#\n\n * 类型： string\n * 默认值： 0.0.0.0\n\n指定 Rsbuild Server 启动时监听的 host。\n\n默认情况下，Rsbuild Server 会监听 0.0.0.0，这代表监听所有 IPv4 的网络接口，包括 localhost 和公网地址。\n\n你可以使用 server.host 配置或 --host 参数来指定 host (--host 参数的优先级高于 server.host 配置)。\n\n如果你希望 Rsbuild Server 只监听 localhost，可以设置为：\n\n\n\n\nIPv6 支持#\n\n如果你希望监听所有 IPv6 的网络接口，可以设置为：\n\n\n\n如果你希望监听 IPv6 指定的 host，可以设置为：\n\n\n\n此时，你可以通过 http://[::1]:3000/ 访问页面。","routePath":"/zh/config/server/host","lang":"zh","toc":[{"text":"IPv6 支持","id":"ipv6-支持","depth":2,"charIndex":259}],"domain":"","frontmatter":{},"version":""},{"id":269,"title":"server.htmlFallback","content":"#\n\n * 类型： false | 'index'\n * 默认值： 'index'\n\n是否支持页面回退。默认情况下，当请求满足以下条件且未找到对应资源时，会回退到 index.html：\n\n * 当前请求是 GET 或 HEAD 请求\n * 当前请求头接受 text/html (请求头 accept 类型为 text/html 或 */*)\n\n\n\nTIP\n\n当 htmlFallback 无法满足你的需求时，可通过 server.historyApiFallback 进行更灵活的设置。","routePath":"/zh/config/server/html-fallback","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":270,"title":"server.https","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n配置该选项后，可以开启 Rsbuild Server 对 HTTPS 的支持，同时会禁用 HTTP 服务器。\n\n开启前：\n\n\n\n开启后：\n\n\n\nTIP\n\nRsbuild 默认会启用 HTTP/2 server。但当你使用 server.proxy 时，server 会降级到 HTTP/1，这是因为底层使用的\nhttp-proxy 不支持 HTTP/2。\n\n\n设置证书#\n\n你可以在 server.https 选项中手动传入 HTTPS 服务器所需要的证书和对应的私钥，这个参数将直接传递给 Node.js 中 https 模块的\ncreateServer 方法。\n\n具体可以参考 https.createServer。\n\n\n\nTIP\n\n本地开发所使用的证书通常使用 mkcert 生成，请阅读 \"如何使用 HTTPS 进行本地开发\" 来了解如何使用。\n\n\n自签名证书#\n\n对基本的配置需求，你可以添加 @rsbuild/plugin-basic-ssl 插件，它会自动创建一个自签名的证书，并默认设置 server.https\n选项。\n\n","routePath":"/zh/config/server/https","lang":"zh","toc":[{"text":"设置证书","id":"设置证书","depth":2,"charIndex":211},{"text":"自签名证书","id":"自签名证书","depth":2,"charIndex":410}],"domain":"","frontmatter":{},"version":""},{"id":271,"title":"server.open","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\nserver.open 用于配置一组页面 URL，Rsbuild 会在启动 server 后自动在浏览器中打开这些页面。\n\n> 你也可以使用 Rsbuild CLI 的 --open 选项来打开页面。当同时使用 server.open 和 --open 时，--open\n> 的优先级更高。\n\n\n示例#\n\nserver.open 可以设置为如下的值。\n\n * 打开项目的默认页面，默认为 http://localhost:。如果配置了 server.host，则默认为 http://:。\n\n\n\n * 打开指定的页面：\n\n\n\n * 打开指定的路径，等价于 http://localhost:/home：\n\n\n\n * 打开多个页面：\n\n\n\n * 打开一个非 localhost URL（配合 proxy 使用）：\n\n\n\n\n端口号占位符#\n\nRsbuild server 监听的端口号可能会发生变更。比如，当端口被占用时，Rsbuild 会自动递增端口号，直至找到一个可用端口。\n\n为了避免端口变化导致 server.open 失效，你可以使用以下方法之一：\n\n * 开启 server.strictPort。\n * 使用 占位符来指代当前端口号，Rsbuild 会将占位符替换为实际监听的端口号。\n\n\n\n\n打开指定浏览器#\n\nRsbuild 默认会在当前系统的默认浏览器中打开页面。\n\n在 macOS 上，通过设置环境变量 BROWSER，你可以指定 dev server 在启动时打开的浏览器，支持如下的值：\n\n * Google Chrome Canary\n * Google Chrome Dev\n * Google Chrome Beta\n * Google Chrome\n * Microsoft Edge\n * Brave Browser\n * Vivaldi\n * Chromium\n\n比如：\n\n\n\nTIP\n\n你可以将 BROWSER 设置在本地的 .env.local 文件中，这样能够避免影响其他开发者。\n\n\n回调函数#\n\n通过 open.before，可以在打开页面之前触发一个回调函数。\n\n\n\n当使用 open.before 时，你可以通过 open.target 来配置页面的 URLs。\n\n","routePath":"/zh/config/server/open","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":179},{"text":"端口号占位符","id":"端口号占位符","depth":2,"charIndex":391},{"text":"打开指定浏览器","id":"打开指定浏览器","depth":2,"charIndex":583},{"text":"回调函数","id":"回调函数","depth":2,"charIndex":894}],"domain":"","frontmatter":{},"version":""},{"id":272,"title":"server.port","content":"#\n\n * 类型： number\n * 默认值： 3000\n\n设置 Rsbuild Server 监听的端口号。\n\n默认情况下，Rsbuild Server 会监听 3000 端口，并在端口被占用时自动递增端口号。当你开启 server.strictPort\n配置时，如果端口被占用，Rsbuild Server 会抛出异常，而不是递增端口号。\n\nRsbuild CLI 提供了 --port 选项来设置端口号，--port 选项的优先级高于 server.port 配置。\n\n\n\n\n示例#\n\n将端口设置为 8080：\n\n\n\n为开发服务器和预览服务器设置不同的端口号：\n\n","routePath":"/zh/config/server/port","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":241}],"domain":"","frontmatter":{},"version":""},{"id":273,"title":"server.printUrls","content":"#\n\n * 类型：\n\n\n\n * 默认值： true\n\n是否输出 server 的 URL 地址。\n\n默认情况下，当你启动 dev server 或 preview server 后，Rsbuild 会输出以下日志信息：\n\n\n\n\n自定义日志#\n\nserver.printUrls 可以设置为一个函数，函数的入参包括 port，protocol、urls 和 routes。\n\n\n修改 URL#\n\n如果 printUrls 函数返回了一组新的 URLs，那么 Rsbuild 将会把这组 URLs 按照默认格式输出到 terminal：\n\n\n\n输出为：\n\n\n\n\n完全自定义#\n\n如果 printUrls 函数没有返回值，Rsbuild 将不会输出 server 的 URL 地址，你可以基于入参来自定义日志内容，并自行输出到\nterminal。\n\n\n\n\n多页面输出#\n\n如果当前项目包含多个页面，你可以基于 routes 参数，为每个页面单独输出一份 URL。\n\n比如项目包含 index 和 detail 两个页面时，routes 的内容如下：\n\n\n\n\n禁用输出#\n\n将 server.printUrls 设置为 false，Rsbuild 将不会输出 server 的 URL 地址。\n\n\n\n\n禁用 HTML#\n\n当 tools.htmlPlugin 被设置为 false 时，Rsbuild 不会生成 HTML 文件，也不会输出 server 的 URL 地址。\n\n但你仍然可以通过 server.printUrls 函数来输出 URL 地址，它具有更高的优先级。\n\n\n\n输出：\n\n","routePath":"/zh/config/server/print-urls","lang":"zh","toc":[{"text":"自定义日志","id":"自定义日志","depth":2,"charIndex":113},{"text":"修改 URL","id":"修改-url","depth":3,"charIndex":187},{"text":"完全自定义","id":"完全自定义","depth":3,"charIndex":278},{"text":"多页面输出","id":"多页面输出","depth":3,"charIndex":374},{"text":"禁用输出","id":"禁用输出","depth":2,"charIndex":475},{"text":"禁用 HTML","id":"禁用-html","depth":3,"charIndex":546}],"domain":"","frontmatter":{},"version":""},{"id":274,"title":"server.proxy","content":"#\n\n * 类型： Record | Record | ProxyOptions[] | ProxyOptions\n * 默认值： undefined\n\n为开发服务器或预览服务器配置代理规则，将请求代理到指定的服务上。\n\n\n示例#\n\n\n基础用法#\n\n\n\n此时，/api/users 请求将会代理到 http://localhost:3000/api/users。\n\n你也可以代理到线上域名，比如:\n\n\n\n\n重写路径#\n\n如果你不想传递 /api，可以通过 pathRewrite 重写请求路径：\n\n\n\n\n代理 WebSocket 请求#\n\n如果你希望代理 WebSocket 请求，可以通过 ws 开启：\n\n\n\n\n选项#\n\nRsbuild server proxy 基于 http-proxy-middleware 实现。你可以使用 http-proxy-middleware\n的所有配置项，具体可以查看文档。\n\nRsbuild server proxy 完整类型定义为：\n\n\n\n除了 http-proxy-middleware 的选项外，Rsbuild 还支持 bypass 和 context 两个选项。\n\n\nbypass#\n\n根据函数的返回值绕过代理。\n\n * 返回 null 或 undefined 会继续用代理处理请求。\n * 返回 true 会跳过代理继续处理请求。\n * 返回 false 会返回 404 错误。\n * 返回一个具体的服务路径，将会使用此路径替代原请求路径。\n\n\n\n\ncontext#\n\n用于代理多个指定的路径到同一个目标。\n\n","routePath":"/zh/config/server/proxy","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":111},{"text":"基础用法","id":"基础用法","depth":3,"charIndex":117},{"text":"重写路径","id":"重写路径","depth":3,"charIndex":202},{"text":"代理 WebSocket 请求","id":"代理-websocket-请求","depth":3,"charIndex":251},{"text":"选项","id":"选项","depth":2,"charIndex":306},{"text":"bypass","id":"bypass","depth":3,"charIndex":506},{"text":"context","id":"context","depth":3,"charIndex":648}],"domain":"","frontmatter":{},"version":""},{"id":275,"title":"server.publicDir","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n默认情况下，Rsbuild 会将 public 目录作为静态资源服务的文件夹，该目录中的文件可在 server.base 路径下访问（默认 /）。\n\n> 相关文档：public 目录。\n\n\n选项#\n\n\nname#\n\n * 类型： string\n * 默认值： 'public'\n\npublic 目录名称。name 的值可以设置为相对路径或绝对路径，相对路径将会相对于项目根目录进行解析。\n\n * 相对路径示例：\n\n\n\n * 绝对路径示例：\n\n\n\n\ncopyOnBuild#\n\n * 类型： boolean\n * 默认值： true\n\n在生产构建时，是否将文件从 public 目录复制到构建产物目录。\n\n比如关闭 copyOnBuild：\n\n\n\n需要注意的是，将 copyOnBuild 的值为 false 后，如果执行 rsbuild preview 进行生产环境预览，将无法访问对应的静态资源文件。\n\nTIP\n\n在 dev 构建时，如果你需要拷贝一些静态资源到构建产物目录，可以使用 output.copy 选项代替。\n\n\nwatch#\n\n * 类型： boolean\n * 默认值： false\n\n是否监听 public 目录，并在文件发生变化时重新加载页面。\n\n设置 watch 为 true 后，开发服务器会监听指定公共目录下的文件变化，并在文件发生变化时重新加载页面：\n\n\n\n需要注意的是，watch 选项仅在开发模式下有效。如果 dev.hmr 和 dev.liveReload 都设置为 false，则 watch 将被忽略。\n\n\n多目录#\n\nserver.publicDir 可以配置为一个数组，这允许你将多个目录作为静态资源服务的文件夹：\n\n\n\n\n禁用#\n\n你可以将 publicDir 设置成 false 来禁用静态资源服务：\n\n","routePath":"/zh/config/server/public-dir","lang":"zh","toc":[{"text":"选项","id":"选项","depth":2,"charIndex":118},{"text":"name","id":"name","depth":3,"charIndex":124},{"text":"copyOnBuild","id":"copyonbuild","depth":3,"charIndex":247},{"text":"watch","id":"watch","depth":3,"charIndex":487},{"text":"多目录","id":"多目录","depth":2,"charIndex":697},{"text":"禁用","id":"禁用","depth":2,"charIndex":757}],"domain":"","frontmatter":{},"version":""},{"id":276,"title":"server.strictPort","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n当端口被占用时，Rsbuild 会自动递增端口号，直至找到一个可用端口。\n\n如果你希望在端口被占用时抛出异常，可以将 strictPort 设置为 true。\n\n\n示例#\n\n","routePath":"/zh/config/server/strict-port","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":114}],"domain":"","frontmatter":{},"version":""},{"id":277,"title":"source.assetsInclude","content":"#\n\n * 类型： Rspack.RuleSetCondition\n * 默认值： undefined\n * 版本： >= 1.0.18\n\n指定需要被视为静态资源的额外文件类型。\n\nRsbuild 默认会将常见的图片、字体、音频、视频等文件视为静态资源。通过配置\nsource.assetsInclude，你可以添加更多的文件类型，这些新增的静态资源将按照与内置静态资源相同的规则进行处理，详见 引用静态资源。\n\nsource.assetsInclude 的值与 Rspack loader 的 test 选项相同，可以是正则表达式、字符串、数组、逻辑条件等，详见\nRspack RuleSetCondition。\n\n\n示例#\n\n * 将 .json5 文件视为静态资源：\n\n\n\n * 将多种文件类型视为静态资源：\n\n\n\n * 将指定文件视为静态资源：\n\n","routePath":"/zh/config/source/assets-include","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":309}],"domain":"","frontmatter":{},"version":""},{"id":278,"title":"source.decorators","content":"#\n\n * 类型：\n\n\n\n用于配置装饰器语法。\n\n\ndecorators.version#\n\n * 类型： 'legacy' | '2022-03'\n * 默认值： '2022-03'\n\n指定需要使用的装饰器语法版本。\n\n\n2022-03#\n\n2022-03 对应装饰器 Stage 3 提案，等价于 TypeScript 5.0 默认支持的装饰器语法。\n\n\n\n参考文档：\n\n * JavaScript meta programming with the 2022-03 decorators API\n * TypeScript 5.0 Decorators\n\n\nlegacy#\n\n等价于 TypeScript 的 experimentalDecorators: true。\n\n\n\n参考文档：\n\n * A Complete Guide to TypeScript Decorators\n * TypeScript Decorators","routePath":"/zh/config/source/decorators","lang":"zh","toc":[{"text":"decorators.version","id":"decoratorsversion","depth":2,"charIndex":25},{"text":"2022-03","id":"2022-03","depth":3,"charIndex":111},{"text":"legacy","id":"legacy","depth":3,"charIndex":281}],"domain":"","frontmatter":{},"version":""},{"id":279,"title":"source.define","content":"#\n\n * 类型： Record\n * 默认值： {}\n\n构建时将代码中的变量替换成其它值或者表达式，可以用于在代码逻辑中区分开发模式与生产模式等场景。\n\n传入的配置对象的键名是需要替换变量的名称，或者是用 . 连接的多个标识符，配置项的值则根据类型进行不同的处理：\n\n * 字符串会被当作代码片段。\n * 包括函数在内的其他类型会被转换成字符串。\n * 嵌套对象的父子键名之间会用 . 连接作为需要替换的变量名。\n * 以 typeof 开头的键名会用来替换 typeof 调用。\n\n> 更多用法请参考 使用 define 和 Rspack - DefinePlugin。\n\n\n示例#\n\n\n\n表达式会被替换为对应的代码段：\n\n","routePath":"/zh/config/source/define","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":289}],"domain":"","frontmatter":{},"version":""},{"id":280,"title":"source.entry","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n用于设置构建的入口模块。\n\nsource.entry 的用法与 Rspack 的 entry 选项类似，它们的主要区别在于，Rsbuild 会为 source.entry\n中的每一个入口注册 html-rspack-plugin，从而生成对应的 HTML 文件。\n\n * 示例：\n\n\n\n生成的目录结构如下：\n\n\n\n如果你不需要生成 HTML 文件，可以将 tools.htmlPlugin 设置为 false 来禁用这一行为。\n\n\n描述对象#\n\nsource.entry 同样支持 Rspack 的 entry 描述对象写法，比如：\n\n\n\nRsbuild 为描述对象添加了 html 属性，用于控制是否生成 HTML 文件。\n\n例如，bar 入口不生成 HTML 文件：\n\n\n\n> 关于描述对象的完整用法，请参考 Rspack - 入口描述对象。\n\n\n基于 environment 设置#\n\n当你面向多个 environments 构建时，可以为每个 environment 设置不同的 entry：\n\n比如为 web 和 node 环境设置不同的 entry：\n\n","routePath":"/zh/config/source/entry","lang":"zh","toc":[{"text":"描述对象","id":"描述对象","depth":2,"charIndex":239},{"text":"基于 environment 设置","id":"基于-environment-设置","depth":2,"charIndex":399}],"domain":"","frontmatter":{},"version":""},{"id":281,"title":"source.exclude","content":"#\n\n * 类型： RuleSetCondition\n * 默认值： []\n\n指定不需要编译的 JavaScript/TypeScript 文件。用法与 Rspack 中的 Rule.exclude\n一致，支持传入字符串或正则表达式来匹配模块的路径。\n\n比如:\n\n\n\n> 参考 source.include 来了解更多。\n\n\n不编译 vs 不打包#\n\nsource.exclude 用于指定不需要编译的 JavaScript/TypeScript 文件。这意味着这些文件不会经过 SWC 或 Babel\n转译，但这些文件仍然会被打包到产物中（如果被引用）。\n\n如果你希望某些文件在打包过程中被忽略，不被打包到产物中，可以使用 Rspack 的 IgnorePlugin。\n\n","routePath":"/zh/config/source/exclude","lang":"zh","toc":[{"text":"不编译 vs 不打包","id":"不编译-vs-不打包","depth":3,"charIndex":162}],"domain":"","frontmatter":{},"version":""},{"id":282,"title":"source.include","content":"#\n\n * 类型： RuleSetCondition\n * 默认值：\n\n\n\nsource.include 用于指定额外需要编译的 JavaScript 文件。\n\n为了避免二次编译，默认情况下，Rsbuild 只会编译当前目录下的 JavaScript 文件，以及所有目录下的 TypeScript 和 JSX\n文件，不会编译 node_modules 下的 JavaScript 文件。\n\n通过 source.include 配置项，可以指定需要 Rsbuild 额外进行编译的目录或模块。source.include 的用法与 Rspack 中的\nRule.include 一致，支持传入字符串、正则表达式来匹配模块的路径。\n\n比如:\n\n\n\n\n编译 npm 包#\n\n比较典型的使用场景是编译 node_modules 下的 npm 包，因为某些第三方依赖存在 ESNext\n的语法，这可能导致在低版本浏览器上无法运行，你可以通过该选项指定需要编译的依赖，从而解决此类问题。\n\nTIP\n\n如果你不确定 node_modules 中的哪些第三方依赖存在 ESNext 的语法，可以使用 @rsbuild/plugin-check-syntax\n进行检查，插件可以帮助你找到存在 ESNext 语法的模块。\n\n以 query-string 为例，你可以做如下的配置：\n\n\n\n上述两种方法分别通过 \"路径前缀\" 和 \"正则表达式\"\n来匹配文件的绝对路径，值得留意的是，项目中所有被引用的模块都会经过匹配，因此你不能使用过于松散的值进行匹配，避免造成编译性能问题或编译异常。\n\nTIP\n\n在上述正则表达式的例子中，我们使用 [\\\\/] 来匹配路径分隔符，这是因为不同的操作系统使用了不同的路径分隔符，使用 [\\\\/] 可以保证\nmacOS、Linux 和 Windows 的路径都被匹配到。\n\n\n编译间接依赖#\n\n当你通过 source.include 编译一个 npm 包时，Rsbuild 默认只会编译匹配到的模块，不会编译对应模块的子依赖。\n\n以 query-string 为例，它依赖的 decode-uri-component 包中同样存在 ESNext 代码，因此你需要将\ndecode-uri-component 也加入到 source.include 中：\n\n\n\n\n编译 Monorepo 中的其他库#\n\n在 Monorepo 中进行开发时，如果需要引用 Monorepo 中其他库的 JavaScript 代码，也可以直接在 source.include\n进行配置:\n\n\n\n\n匹配 Symlink#\n\n如果你匹配的模块是通过 symlink 链接到当前项目中的，那么需要匹配这个模块的真实路径，而不是 symlink 后的路径。\n\n比如，你将 Monorepo 中的 packages/foo 路径 symlink 到当前项目的 node_modules/foo 路径下，则需要去匹配\npackages/foo 路径，而不是 node_modules/foo 路径。\n\n\n编译 node_modules#\n\n通常来说，source.include 不应该用于编译整个 node_modules 目录，比如下面的写法是不推荐的：\n\n\n\n这是因为 node_modules 中的大部分 npm 包发布的已经是编译后的产物，通常没必要经过二次编译。如果你对整个 node_modules\n进行编译，会使编译时间增加，并且个别的 npm 包可能会产生不可预期的错误，比如 core-js 被编译后会出现运行时异常。\n\n如果你可以接受编译时间的增加，可以通过下面的配置来编译所有 JavaScript 文件，但是需要排除 core-js：\n\n","routePath":"/zh/config/source/include","lang":"zh","toc":[{"text":"编译 npm 包","id":"编译-npm-包","depth":2,"charIndex":322},{"text":"编译间接依赖","id":"编译间接依赖","depth":2,"charIndex":793},{"text":"编译 Monorepo 中的其他库","id":"编译-monorepo-中的其他库","depth":2,"charIndex":986},{"text":"匹配 Symlink","id":"匹配-symlink","depth":2,"charIndex":1092},{"text":"编译 node_modules","id":"编译-node_modules","depth":2,"charIndex":1290}],"domain":"","frontmatter":{},"version":""},{"id":283,"title":"source.preEntry","content":"#\n\n * 类型： string | string[]\n * 默认值： undefined\n\n在每个页面的入口文件前添加一段代码，这段代码会早于页面的代码执行，因此可以用于执行一些全局的代码逻辑，比如注入 polyfill、设置全局样式等。\n\n\n添加单个脚本#\n\n首先创建一个 src/polyfill.ts 文件：\n\n\n\n然后将 src/polyfill.ts 配置到 source.preEntry 上：\n\n\n\n重新运行编译并访问任意页面，可以看到 src/polyfill.ts 中的代码已经执行，并在 console 中输出了对应的内容。\n\n\n添加全局样式#\n\n你也可以通过 source.preEntry 来配置全局样式，这段 CSS 代码会早于页面代码加载，比如引入一个 normalize.css 文件：\n\n\n\n\n添加多个脚本#\n\n你可以将 preEntry 设置为数组来添加多个脚本，它们会按数组顺序执行：\n\n","routePath":"/zh/config/source/pre-entry","lang":"zh","toc":[{"text":"添加单个脚本","id":"添加单个脚本","depth":2,"charIndex":122},{"text":"添加全局样式","id":"添加全局样式","depth":2,"charIndex":275},{"text":"添加多个脚本","id":"添加多个脚本","depth":2,"charIndex":363}],"domain":"","frontmatter":{},"version":""},{"id":284,"title":"source.transformImport","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n转换 import 的路径，可以用于模块化引用三方包的子路径，能力类似于 babel-plugin-import。\n\n\n示例#\n\n\n按需引入 antd 组件#\n\n在使用 antd 组件库时（低于 v5 版本），你可以通过以下配置来按需引入组件：\n\n\n\n源代码如下：\n\n\n\n会被转换成：\n\n\n\n\n按需引入 lodash#\n\n在使用 lodash 时，你可以通过 transformImport 来自动引用子路径，减小包体积。\n\n\n\n源代码如下：\n\n\n\n会被转换成：\n\n\n\n请避免以下用法，否则会引入所有的 lodash 代码：\n\n\n\n\n适用范围#\n\ntransformImport 只适用于经过 Rsbuild 编译的模块。需要注意的是，Rsbuild 默认并不会编译位于 node_modules 目录下的\nJavaScript 文件。这意味着，node_modules 目录内的代码将不会被 transformImport 处理。\n\n如果你希望通过 transformImport 对 node_modules 下的代码进行处理，请将相关模块添加到 source.include 配置中。\n\n\n\n\n选项#\n\n\nlibraryName#\n\n * 类型： string\n\n用于指定需要按需加载的模块名称。当 Rsbuild 遍历代码时，如果遇到了对应模块的 import 语句，则会对其进行转换。\n\n\nlibraryDirectory#\n\n * 类型： string\n * 默认值： 'lib'\n\n用于拼接转换后的路径，拼接规则为 ${libraryName}/${libraryDirectory}/${member}，其中 member 为引入成员。\n\n示例：\n\n\n\n转换结果:\n\n\n\n\nstyle#\n\n * 类型： boolean\n * 默认值： undefined\n\n确定是否需要引入相关样式，若为 true，则会引入路径\n${libraryName}/${libraryDirectory}/${member}/style。若为 false 或 undefined 则不会引入样式。\n\n当配置为 true 时：\n\n\n\n转换结果:\n\n\n\n\nstyleLibraryDirectory#\n\n * 类型： string\n * 默认值： undefined\n\n该配置用于拼接引入样式时的引入路径，若该配置被指定，则 style 配置项会被忽略。拼接引入路径为\n${libraryName}/${styleLibraryDirectory}/${member}。\n\n当配置为 styles 时：\n\n\n\n转换结果:\n\n\n\n\ncamelToDashComponentName#\n\n * 类型： boolean\n * 默认值： true\n\n是否需要将 camelCase 的引入转换成 kebab-case。\n\n示例：\n\n\n\n转换结果：\n\n\n\n\ntransformToDefaultImport#\n\n * 类型： boolean\n * 默认值： true\n\n是否将导入语句转换成默认导入。\n\n示例：\n\n\n\n转换结果：\n\n\n\n\ncustomName#\n\n * 类型： string\n * 默认值： undefined\n\n自定义转换后的导入路径。\n\n比如下面的配置，会将 转换为 。\n\n\n\n此外，你还可以声明转换后的路径格式，例如设置为 my-lib/{{ camelCase member }}，来将 member 转换成驼峰格式。\n\n支持以下格式：\n\n * kebabCase：字母小写，单词之间使用连字符连接。例如：my-variable-name。\n * snakeCase：字母小写，单词之间使用下划线连接。例如：my_variable_name。\n * camelCase：首字母小写，随后每个单词的首字母大写。例如：myVariableName。\n * upperCase：字母大写，其他字符不变。例如：MY-VARIABLE-NAME。\n * lowerCase：字母小写，其他字符不变。例如：my-variable-name。\n\n\ncustomStyleName#\n\n * 类型： string\n * 默认值： undefined\n\n自定义转换后的样式导入路径，用法与 customName 一致。\n\n\nFunction 类型#\n\ntransformImport 的值定义为函数时，可以接受原本的 transformImport 配置，并对其进行修改。\n\n\n\n也可以在函数中返回一个新数组作为最终结果，新数组会覆盖原本的 transformImport 配置。\n\n","routePath":"/zh/config/source/transform-import","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":91},{"text":"按需引入 antd 组件","id":"按需引入-antd-组件","depth":3,"charIndex":97},{"text":"按需引入 lodash","id":"按需引入-lodash","depth":3,"charIndex":178},{"text":"适用范围","id":"适用范围","depth":2,"charIndex":298},{"text":"选项","id":"选项","depth":2,"charIndex":531},{"text":"libraryName","id":"libraryname","depth":3,"charIndex":537},{"text":"libraryDirectory","id":"librarydirectory","depth":3,"charIndex":631},{"text":"style","id":"style","depth":3,"charIndex":776},{"text":"styleLibraryDirectory","id":"stylelibrarydirectory","depth":3,"charIndex":954},{"text":"camelToDashComponentName","id":"cameltodashcomponentname","depth":3,"charIndex":1141},{"text":"transformToDefaultImport","id":"transformtodefaultimport","depth":3,"charIndex":1250},{"text":"customName","id":"customname","depth":3,"charIndex":1340},{"text":"customStyleName","id":"customstylename","depth":3,"charIndex":1750},{"text":"Function 类型","id":"function-类型","depth":2,"charIndex":1836}],"domain":"","frontmatter":{},"version":""},{"id":285,"title":"source.tsconfigPath","content":"#\n\n * 类型： string\n * 默认值： 'tsconfig.json'\n\n配置自定义的 tsconfig.json 文件路径，可以是相对路径或绝对路径。\n\n\n作用#\n\ntsconfig.json 配置文件影响 Rsbuild 的以下行为：\n\n * paths 字段用于配置 路径别名。\n * 设置 @rsbuild/plugin-type-check 的检查范围和规则。\n\n\n示例#\n\nsource.tsconfigPath 的值可以设置为相对路径或绝对路径，相对路径将会相对于项目根目录进行解析。\n\n * 相对路径示例：\n\n\n\n * 绝对路径示例：\n\n","routePath":"/zh/config/source/tsconfig-path","lang":"zh","toc":[{"text":"作用","id":"作用","depth":2,"charIndex":83},{"text":"示例","id":"示例","depth":2,"charIndex":192}],"domain":"","frontmatter":{},"version":""},{"id":286,"title":"tools.bundlerChain","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n你可以通过 tools.bundlerChain 来调用 rspack-chain 以修改默认的 Rspack 配置，它的值是一个函数，接收两个参数：\n\n * 第一个参数为 rspack-chain 实例，你可以通过它来修改 Rspack 配置。\n * 第二个参数为一个工具对象，包括 env、isProd、CHAIN_ID 等。\n\n> tools.bundlerChain 会早于 tools.rspack 被执行，因此会被 tools.rspack 覆盖。\n\nTIP\n\nRsbuild 内置的 Rspack 配置会随着迭代而发生变化，这些变化不会反映在 semver 中，因此在升级 Rsbuild 时，你的自定义配置可能会失效。\n\n\n示例#\n\n参考：RspackChain 示例。\n\n\n工具对象#\n\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test，比如：\n\n\n\n\nisDev#\n\n * 类型： boolean\n\n用于判断当前是否为开发模式构建，比如：\n\n\n\n\nisProd#\n\n * 类型： boolean\n\n用于判断当前是否为生产模式构建，比如：\n\n\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'web-worker'\n\n通过 target 参数可以判断构建的目标运行时环境。比如：\n\n\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\n\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\n\n\n\nHtmlPlugin#\n\n * 类型： typeof import('html-rspack-plugin')\n\n通过这个参数你可以拿到 html-rspack-plugin 插件的实例。\n\n\n\n\nCHAIN_ID#\n\nRsbuild 中预先定义了一些常用的 Chain ID，你可以通过这些 ID 来定位到内置的 Rule 或 Plugin。\n\nTIP\n\n请留意，下列的一部分 Rule 或 Plugin 并不是默认存在的，当你开启特定配置项、或是注册某些插件后，它们才会被包含在 Rspack 或 webpack\n配置中。\n\n比如，RULE.STYLUS 仅在注册了 Stylus 插件后才会存在。\n\n\nCHAIN_ID.RULE#\n\nID            描述\nRULE.JS       处理 js 和 ts 的规则\nRULE.SVG      处理 svg 的规则\nRULE.CSS      处理 css 的规则\nRULE.LESS     处理 less 的规则\nRULE.SASS     处理 sass 的规则\nRULE.WASM     处理 wasm 的规则\nRULE.FONT     处理 font 的规则\nRULE.IMAGE    处理 image 的规则\nRULE.MEDIA    处理 media 的规则\nRULE.VUE      处理 vue 的规则（依赖 Vue 插件）\nRULE.SVELTE   处理 svelte 的规则（依赖 Svelte 插件）\nRULE.STYLUS   处理 stylus 的规则（依赖 Stylus 插件）\n\n\nCHAIN_ID.ONE_OF#\n\n通过 ONE_OF.[ID] 可以匹配到规则数组中的某一类规则。\n\nID                  描述\nONE_OF.SVG_URL      处理 SVG 的规则，输出为单独文件\nONE_OF.SVG_INLINE   处理 SVG 的规则，作为 data URI 内联到 bundle 中\nONE_OF.SVG_ASSETS   处理 SVG 的规则，在 data URI 和单独文件之间自动选择\n\n\nCHAIN_ID.USE#\n\n通过 USE.[ID] 可以匹配到对应的 loader。\n\nID                描述\nUSE.SWC           对应 builtin:swc-loader\nUSE.POSTCSS       对应 postcss-loader\nUSE.STYLE         对应 style-loader\nUSE.LESS          对应 less-loader（依赖 Less 插件）\nUSE.SASS          对应 sass-loader（依赖 Sass 插件）\nUSE.RESOLVE_URL   对应 resolve-url-loader（依赖 Sass 插件）\nUSE.VUE           对应 vue-loader（依赖 Vue 插件）\nUSE.SVGR          对应 svgr-loader（依赖 Svgr 插件）\nUSE.BABEL         对应 babel-loader（依赖 Babel 插件）\nUSE.SVELTE        对应 svelte-loader（依赖 Svelte 插件）\nUSE.STYLUS        对应 stylus-loader（依赖 Stylus 插件）\n\n\nCHAIN_ID.PLUGIN#\n\n通过 PLUGIN.[ID] 可以匹配到特定的 Rspack 或 Webpack plugin。\n\nID                         描述\nPLUGIN.HTML                对应 HtmlRspackPlugin，使用时需要拼接 entry\n                           名称：${PLUGIN.HTML}-${entryName}\nPLUGIN.BUNDLE_ANALYZER     对应 WebpackBundleAnalyzer\nPLUGIN.VUE_LOADER_PLUGIN   对应 VueLoaderPlugin（依赖 Vue 插件）\n\n\nCHAIN_ID.MINIMIZER#\n\n通过 MINIMIZER.[ID] 可以匹配到对应的压缩工具。\n\nID              描述\nMINIMIZER.JS    对应 SwcJsMinimizerRspackPlugin\nMINIMIZER.CSS   对应 LightningCssMinimizerRspackPlugin","routePath":"/zh/config/tools/bundler-chain","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":351},{"text":"工具对象","id":"工具对象","depth":2,"charIndex":377},{"text":"env","id":"env","depth":3,"charIndex":385},{"text":"isDev","id":"isdev","depth":3,"charIndex":495},{"text":"isProd","id":"isprod","depth":3,"charIndex":543},{"text":"target","id":"target","depth":3,"charIndex":592},{"text":"isServer","id":"isserver","depth":3,"charIndex":674},{"text":"isWebWorker","id":"iswebworker","depth":3,"charIndex":751},{"text":"HtmlPlugin","id":"htmlplugin","depth":3,"charIndex":843},{"text":"CHAIN_ID","id":"chain_id","depth":2,"charIndex":942},{"text":"CHAIN_ID.RULE","id":"chain_idrule","depth":3,"charIndex":1147},{"text":"CHAIN_ID.ONE_OF","id":"chain_idone_of","depth":3,"charIndex":1539},{"text":"CHAIN_ID.USE","id":"chain_iduse","depth":3,"charIndex":1765},{"text":"CHAIN_ID.PLUGIN","id":"chain_idplugin","depth":3,"charIndex":2318},{"text":"CHAIN_ID.MINIMIZER","id":"chain_idminimizer","depth":3,"charIndex":2646}],"domain":"","frontmatter":{},"version":""},{"id":287,"title":"tools.cssExtract","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n * 版本： >= 0.7.0\n\nRsbuild 默认使用 CssExtractRspackPlugin 插件将 CSS 提取为独立的文件。\n\n通过 tools.cssExtract 可以更改 CssExtractRspackPlugin 的选项。\n\n\npluginOptions#\n\n * 类型： CssExtractRspackPluginOptions\n * 示例：\n\n\n\n\nloaderOptions#\n\n * 类型： CssExtractRspackLoaderOptions\n * 示例：\n\n\n\n> 请参考 CssExtractRspackPlugin 插件文档来了解所有可用的选项。","routePath":"/zh/config/tools/css-extract","lang":"zh","toc":[{"text":"pluginOptions","id":"pluginoptions","depth":2,"charIndex":150},{"text":"loaderOptions","id":"loaderoptions","depth":2,"charIndex":214}],"domain":"","frontmatter":{},"version":""},{"id":288,"title":"tools.cssLoader","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\nRsbuild 默认使用 css-loader 来处理 CSS 资源。你可以通过 tools.cssLoader 来修改 css-loader 的选项。\n\nTIP\n\n如果你需要修改 CSS Modules 相关的选项，推荐优先使用 output.cssModules 配置项。\n\n\nObject 类型#\n\n当此值为 Object 类型时，会与默认配置进行深层合并 (deep merge)。比如：\n\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\n","routePath":"/zh/config/tools/css-loader","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":179},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":241}],"domain":"","frontmatter":{},"version":""},{"id":289,"title":"tools.htmlPlugin","content":"#\n\n * 类型： boolean | Object | Function\n * 默认值：\n\n\n\n通过 tools.htmlPlugin 可以修改 html-rspack-plugin 的配置项。\n\nRsbuild 内部基于 html-rspack-plugin 实现 HTML 相关的能力。它是 html-webpack-plugin 的一个 fork\n版本，具备完全一致的功能和选项。\n\nTIP\n\n如果你需要修改 title、template、templateParameters、meta 等选项，推荐优先使用 Rsbuild 提供的对应 HTML\n配置项，如 html.title、html.template 等。\n\n这是因为这些配置间存在一些关联关系，Rsbuild 对于 HTML 配置项提供了一些内部的优化处理，例如，如果当前项目使用的 HTML 模板中已经包含了\n</code> 标签，那么 <code>html.title</code> 将不会生效。 </p></div></div> <h2\nid=\"object-类型\">Object 类型<a aria-hidden=\"true\" href=\"#object-类型\">#</a></h2> <p>当\n<code>tools.htmlPlugin</code> 的值为 <code>Object</code> 类型时，会与默认配置通过\n<code>Object.assign</code> 合并。</p> <pre><code>export default { tools: {\nhtmlPlugin: { scriptLoading: 'blocking', }, }, }; </code></pre> <h2\nid=\"function-类型\">Function 类型<a aria-hidden=\"true\" href=\"#function-类型\">#</a></h2>\n<p>当 <code>tools.htmlPlugin</code> 为 Function 类型时：</p> <ul>\n<li>第一个参数是默认配置的对象，可以直接修改该对象。</li> <li>第二个参数是也是一个对象，包含了 entry 的名称和 entry 的值。</li>\n<li>函数可以 return 一个新的对象作为最终的配置。</li> </ul> <pre><code>export default { tools: {\nhtmlPlugin(config, { entryName, entryValue }) { if (entryName === 'main') {\nconfig.scriptLoading = 'blocking'; } }, }, }; </code></pre> <h2 id=\"禁用-html\">禁用\nHTML<a aria-hidden=\"true\" href=\"#禁用-html\">#</a></h2> <p>将\n<code>tools.htmlPlugin</code> 配置为 <code>false</code>，可以禁用 Rsbuild 内置的\n<code>html-rspack-plugin</code> 插件，此时将不会生成 HTML 产物。</p> <pre><code>export\ndefault { tools: { htmlPlugin: false, }, }; </code></pre> <h2 id=\"示例\">示例<a\naria-hidden=\"true\" href=\"#示例\">#</a></h2> <h3 id=\"修改-html-文件名\">修改 HTML 文件名<a\naria-hidden=\"true\" href=\"#修改-html-文件名\">#</a></h3> <p>通过 <code>filename</code>\n选项可以修改 HTML 产物的文件名。</p> <p>例如，在生产模式构建时，可以在文件名上添加 <code>hash</code>：</p>\n<pre><code>export default { tools: { htmlPlugin(config, { entryName }) { if\n(process.env.NODE_ENV === 'production') { config.filename =\n`${entryName}.[contenthash:8].html`; } }, }, }; </code></pre> <h2\nid=\"html-压缩\">HTML 压缩<a aria-hidden=\"true\" href=\"#html-压缩\">#</a></h2> <p>Rsbuild\n目前不对 HTML 文件进行压缩，如果你需要压缩 HTML 文件，可以使用 <a\nhref=\"https://github.com/rspack-contrib/rsbuild-plugin-html-minifier-terser\"\ntarget=\"_blank\" rel=\"noopener noreferrer\">rsbuild-plugin-html-minifier-terser\n插件</a>。</p>","routePath":"/zh/config/tools/html-plugin","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":-1},{"text":"Function 类型","id":"function-类型","depth":2,"charIndex":-1},{"text":"禁用 HTML","id":"禁用-html","depth":2,"charIndex":-1},{"text":"示例","id":"示例","depth":2,"charIndex":-1},{"text":"修改 HTML 文件名","id":"修改-html-文件名","depth":3,"charIndex":-1},{"text":"HTML 压缩","id":"html-压缩","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":290,"title":"tools.lightningcssLoader","content":"#\n\n * 类型： Rspack.LightningcssLoaderOptions | Function | boolean\n * 默认值：\n\n\n\n * 版本： >= 1.0.0\n\n通过 tools.lightningcssLoader 可以设置 builtin:lightningcss-loader 的选项。\n\n\nObject 类型#\n\n当 tools.lightningcssLoader 是一个 object 时，它会与默认配置通过 Object.assign 合并。\n\n比如，你可以通过 tools.lightningcssLoader.exclude 来关闭 vendor prefixes 的添加，此时你可以使用\nPostCSS 的 autoprefixer 插件来添加 vendor prefixes。\n\n\n\n\nFunction 类型#\n\n当 tools.lightningcssLoader 是一个 function\n时，默认选项会作为第一个参数传入，你可以直接修改这个对象，也可以返回一个新的对象作为最终使用的选项。比如：\n\n\n\n\n禁用 loader#\n\n将 tools.lightningcssLoader 设置为 false，可以禁用 Rsbuild 内置的 lightningcss-loader：\n\n\n\nTIP\n\n将 tools.lightningcssLoader 设置为 false 仅用于禁用 lightningcss-loader。如果你需要禁用 Lightning\nCSS 完整功能，请参考 禁用 Lightning CSS。","routePath":"/zh/config/tools/lightningcss-loader","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":159},{"text":"Function 类型","id":"function-类型","depth":2,"charIndex":364},{"text":"禁用 loader","id":"禁用-loader","depth":2,"charIndex":476}],"domain":"","frontmatter":{},"version":""},{"id":291,"title":"tools.postcss","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\nRsbuild 默认集成 PostCSS，你可以通过 tools.postcss 对 postcss-loader 进行配置。\n\n\nFunction 类型#\n\n当 tools.postcss 是一个 function\n时，默认选项会作为第一个参数传入，你可以直接修改这个对象，也可以返回一个新的对象作为最终使用的选项。函数的第二个参数为修改 postcss-loader\n配置的工具函数。\n\n例如，需要新增一个 PostCSS 插件，调用 addPlugins 工具函数即可：\n\n\n\n需要给 PostCSS 插件传递参数时，可以将 PostCSS 插件作为一个函数调用：\n\n\n\n也可以修改默认的 postcss-loader 选项：\n\n\n\ntools.postcss 可以返回一个配置对象，并完全替换默认配置：\n\n\n\n\nObject 类型#\n\n当 tools.postcss 是一个 object 时，它会与默认配置通过 Object.assign 合并。注意 Object.assign\n是浅拷贝，它会完全覆盖内置的 plugins 数组，请谨慎使用。\n\n\n\n\n工具函数#\n\n\naddPlugins#\n\n * 类型： (plugins: PostCSSPlugin | PostCSSPlugin[]) => void\n\n用于添加额外的 PostCSS 插件，你可以传入单个 PostCSS 插件，也可以传入 PostCSS 插件数组。\n\n\n\n\n实践#\n\n\n多份 PostCSS 选项#\n\ntools.postcss.postcssOptions 可以设置为一个函数，函数接收 Rspack 的 loaderContext\n作为参数，这允许你根据不同的文件路径使用不同的 PostCSS 选项。\n\n例如，为路径中包含 foo 的文件使用 postcss-plugin-a，为其他文件使用 postcss-plugin-b：\n\n\n\nTIP\n\n如果项目中包含 postcss.config.* 配置文件，该文件的内容会与 tools.postcss.postcssOptions\n合并，后者的优先级更高，plugins 数组会被合并到一个数组中。\n\n\n注意事项#\n\n\nPostCSS 版本#\n\nRsbuild 中使用的 PostCSS 版本为 v8，当你引入社区中的 PostCSS 插件时，请注意版本是否适配，部分旧版本插件可能无法在 PostCSS\nv8 下运行。\n\n\nPostCSS 配置加载#\n\nRsbuild 使用 postcss-load-config 加载 PostCSS 配置文件，并将其与默认配置合并。\n\nRsbuild 内部将 postcss-loader 的 postcssOptions.config 选项始终设置为 false，以避免重复加载配置文件。","routePath":"/zh/config/tools/postcss","lang":"zh","toc":[{"text":"Function 类型","id":"function-类型","depth":2,"charIndex":104},{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":398},{"text":"工具函数","id":"工具函数","depth":2,"charIndex":520},{"text":"addPlugins","id":"addplugins","depth":3,"charIndex":528},{"text":"实践","id":"实践","depth":2,"charIndex":662},{"text":"多份 PostCSS 选项","id":"多份-postcss-选项","depth":3,"charIndex":668},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":963},{"text":"PostCSS 版本","id":"postcss-版本","depth":3,"charIndex":971},{"text":"PostCSS 配置加载","id":"postcss-配置加载","depth":3,"charIndex":1074}],"domain":"","frontmatter":{},"version":""},{"id":292,"title":"tools.rspack","content":"#\n\n * 类型： Rspack.Configuration | Function | undefined\n * 默认值： undefined\n\ntools.rspack 选项用于修改 Rspack 的配置项。\n\nTIP\n\nRsbuild 内置的 Rspack 配置会随着迭代而发生变化，这些变化不会反映在 semver 中，因此在升级 Rsbuild 时，你的自定义配置可能会失效。\n\n\nObject 类型#\n\ntools.rspack 可以配置为一个对象，这个对象将会和内置的 Rspack 配置通过 webpack-merge 进行深层合并。\n\n比如添加 resolve.alias 配置：\n\n\n\n在合并配置时，webpack-merge 会自动合并数组，比如 plugins、module.rules、resolve.extensions 等配置。\n\n\n\n如果你需要覆盖某个配置项，而不是与默认值合并，可以使用 tools.rspack 的函数类型。\n\n\nFunction 类型#\n\ntools.rspack 也可以配置为一个函数，这个函数接收一个参数，即内置的 Rspack 配置对象，你可以对这个对象进行修改，然后返回一份新的配置。比如：\n\n\n\nTIP\n\ntools.rspack 函数返回的对象会直接作为最终使用的 Rspack 配置，不会再与内置的 Rspack 配置进行合并。\n\ntools.rspack 还可以是一个异步函数：\n\n\n\n\n工具集合#\n\n这个函数的第二个参数是一个对象，包含了一些工具函数和属性，详情如下：\n\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\n\n\n\nisDev#\n\n * 类型： boolean\n\n用于判断当前是否为开发模式构建，比如：\n\n\n\n\nisProd#\n\n * 类型： boolean\n\n用于判断当前是否为生产模式构建，比如：\n\n\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'web-worker'\n\n通过 target 参数可以判断构建的目标运行时环境。比如：\n\n\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\n\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\n\n\n\nrspack#\n\n * 类型： Rspack\n\n通过这个参数你可以拿到 Rspack 实例。比如：\n\n\n\n\nHtmlPlugin#\n\n * 类型： typeof import('html-rspack-plugin')\n\n通过这个参数你可以拿到 html-rspack-plugin 插件的实例。\n\n\n\n\naddRules#\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 Rspack rules 到 Rspack rules 列表的最前面。\n\n需要注意的是，Rspack loaders 会按照从右到左的顺序执行，如果你希望你添加的 loader（Normal Phase）先于其他 loader\n执行，应使用 appendRules 将该规则添加到最后面。\n\n示例：\n\n\n\n\nappendRules#\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 Rspack rules 到 Rspack rules 列表的最后面。\n\n示例：\n\n\n\n\nprependPlugins#\n\n * 类型： (plugins: BundlerPluginInstance | BundlerPluginInstance[]) => void\n\n在内部 Rspack 插件数组头部添加额外的插件，数组头部的插件会优先执行。\n\n\n\n\nappendPlugins#\n\n * 类型： (plugins: BundlerPluginInstance | BundlerPluginInstance[]) => void\n\n在内部 Rspack 插件数组尾部添加额外的插件，数组尾部的插件会在最后执行。\n\n\n\n\nremovePlugin#\n\n * 类型： (name: string) => void\n\n删除内部的 Rspack 插件，参数为该插件的 constructor.name。\n\n例如，删除内部的 webpack-bundle-analyzer：\n\n\n\n\nmergeConfig#\n\n * 类型： (...configs:Rspack.Configuration[]) =>Rspack.Configuration\n\n用于合并多份 Rspack 配置，等价于 webpack-merge。\n\n\n\nTIP\n\nmergeConfig 方法会创建一个新的 config 对象，不会修改原始 config 对象，因此你需要 return mergeConfig 的执行结果。","routePath":"/zh/config/tools/rspack","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":194},{"text":"Function 类型","id":"function-类型","depth":2,"charIndex":431},{"text":"工具集合","id":"工具集合","depth":2,"charIndex":627},{"text":"env","id":"env","depth":3,"charIndex":671},{"text":"isDev","id":"isdev","depth":3,"charIndex":781},{"text":"isProd","id":"isprod","depth":3,"charIndex":829},{"text":"target","id":"target","depth":3,"charIndex":878},{"text":"isServer","id":"isserver","depth":3,"charIndex":960},{"text":"isWebWorker","id":"iswebworker","depth":3,"charIndex":1037},{"text":"rspack","id":"rspack","depth":3,"charIndex":1129},{"text":"HtmlPlugin","id":"htmlplugin","depth":3,"charIndex":1183},{"text":"addRules","id":"addrules","depth":3,"charIndex":1282},{"text":"appendRules","id":"appendrules","depth":3,"charIndex":1506},{"text":"prependPlugins","id":"prependplugins","depth":3,"charIndex":1624},{"text":"appendPlugins","id":"appendplugins","depth":3,"charIndex":1759},{"text":"removePlugin","id":"removeplugin","depth":3,"charIndex":1894},{"text":"mergeConfig","id":"mergeconfig","depth":3,"charIndex":2021}],"domain":"","frontmatter":{},"version":""},{"id":293,"title":"tools.styleLoader","content":"#\n\n * 类型： Object | Function\n * 默认值： {}\n\n通过 tools.styleLoader 可以设置 style-loader 的配置项。\n\n值得注意的是，Rsbuild 默认不会开启 style-loader，你可以通过 output.injectStyles 配置项来开启它。\n\n\nObject 类型#\n\n当 tools.styleLoader 是一个 object 时，它会与默认配置通过 Object.assign 合并。\n\n\n\n\nFunction 类型#\n\n当 tools.styleLoader 是一个 function\n时，默认选项会作为第一个参数传入，你可以直接修改这个对象，也可以返回一个新的对象作为最终使用的选项。比如：\n\n","routePath":"/zh/config/tools/style-loader","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":157},{"text":"Function 类型","id":"function-类型","depth":2,"charIndex":234}],"domain":"","frontmatter":{},"version":""},{"id":294,"title":"tools.swc","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n通过 tools.swc 可以设置 builtin:swc-loader 的选项。\n\n> 参考 配置 SWC 了解更多。\n\n\nObject 类型#\n\ntools.swc 可以配置为一个对象，这个对象将会和内置的 builtin:swc-loader 选项进行深层合并。\n\n\n\n\nFunction 类型#\n\ntools.swc 也可以配置为一个函数，这个函数接收一个参数，即内置的 builtin:swc-loader\n选项，你可以对这个对象进行修改，然后返回一份新的配置。比如：\n\n\n\nTIP\n\ntools.swc 函数返回的对象会直接作为最终使用的 builtin:swc-loader 选项，不会再与内置的 builtin:swc-loader\n选项进行合并。","routePath":"/zh/config/tools/swc","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":101},{"text":"Function 类型","id":"function-类型","depth":2,"charIndex":177}],"domain":"","frontmatter":{},"version":""},{"id":295,"title":"路径别名","content":"#\n\n路径别名（alias）允许开发者为模块定义别名，以便于在代码中更方便的引用它们。当你想要使用一个简短、易于记忆的名称来代替冗长复杂的路径时，这将非常有用。\n\n例如，假如你在项目中经常引用 src/common/request.ts 模块，你可以为它定义一个别名 @request，然后在代码中通过 ``\n来引用它，而不需要每次都写出完整的相对路径。这也允许你将模块移动到不同的位置，而不需要更新代码中的所有 import 语法。\n\n\n\n在 Rsbuild 中，你有两种方式可以设置路径别名:\n\n * 使用 tsconfig.json 中的 paths 选项。\n * 使用 resolve.alias 配置。\n\n\ntsconfig.json 的 paths 选项#\n\n你可以通过 tsconfig.json 中的 paths 来配置别名，这是我们在 TypeScript 项目中推荐使用的方式，因为它可以解决路径别名的 TS\n类型问题。\n\n比如：\n\n\n\n以上配置完成后，如果你在代码中引用 @common/Foo.tsx, 则会映射到 /src/common/Foo.tsx 路径上。\n\nTIP\n\n你可以阅读 TypeScript - paths 文档来了解更多用法。\n\n\njsconfig.json#\n\n在非 TypeScript 项目中，如果你需要通过 jsconfig.json 中的 paths 字段来设置路径别名，可以使用\nsource.tsconfigPath 选项来设置。\n\n添加以下配置后，Rsbuild 会识别 jsconfig.json 中的 paths 字段。\n\n\n\n\nresolve.alias 配置#\n\nRsbuild 提供了 resolve.alias 配置项，对应 Rspack 原生的 resolve.alias\n配置，你可以通过对象或者函数的方式来配置这个选项。\n\n\n使用场景#\n\n由于 tsconfig.json 的 paths 配置是写在静态 JSON 文件里的，因此它不具备动态性。\n\n而 resolve.alias 则可以弥补这一不足，你可以通过 JavaScript 代码来动态设置 resolve.alias（比如基于环境变量来设置）。\n\n\n对象用法#\n\n你可以通过对象的方式来配置 resolve.alias，其中的相对路径会被自动补全为绝对路径。\n\n比如：\n\n\n\n以上配置完成后，如果你在代码中引用 @common/Foo.tsx, 则会映射到 /src/common/Foo.tsx 路径上。\n\n\n函数用法#\n\n你也可以将 resolve.alias 配置为一个函数，拿到内置的 alias 对象，对其进行修改。\n\n比如：\n\n\n\n\n优先级#\n\ntsconfig.json 的 paths 配置的优先级高于 resolve.alias，当一个路径同时匹配到这两者定义的规则时，会优先使用\ntsconfig.json 的 paths 定义的值。\n\n你可以通过 resolve.aliasStrategy 来调整这两个选项的优先级。","routePath":"/zh/guide/advanced/alias","lang":"zh","toc":[{"text":"`tsconfig.json` 的 `paths` 选项","id":"tsconfigjson-的-paths-选项","depth":2,"charIndex":-1},{"text":"jsconfig.json","id":"jsconfigjson","depth":2,"charIndex":538},{"text":"`resolve.alias` 配置","id":"resolvealias-配置","depth":2,"charIndex":-1},{"text":"使用场景","id":"使用场景","depth":3,"charIndex":802},{"text":"对象用法","id":"对象用法","depth":3,"charIndex":945},{"text":"函数用法","id":"函数用法","depth":3,"charIndex":1076},{"text":"优先级","id":"优先级","depth":3,"charIndex":1143}],"domain":"","frontmatter":{},"version":""},{"id":296,"title":"浏览器兼容性","content":"#\n\n本章节介绍如何使用 Rsbuild 提供的能力来处理浏览器兼容性问题。\n\n\n设置浏览器范围#\n\n在处理兼容性问题之前，首先需要明确你的项目需要支持的浏览器范围，并添加相应的 browserslist 配置。\n\n * 如果你还没有设置浏览器范围，请先阅读 设置浏览器范围 章节。\n\n * 如果你已经设置了浏览器范围，那么 Rsbuild 会自动根据该范围进行编译，对 JavaScript 语法和 CSS 语法进行降级处理，并注入所需的\n   polyfill 代码。大部分情况下，你可以放心地使用现代 ECMAScript 特性，无须担心兼容性问题。\n\n在设置浏览器范围之后，如果你依然在开发中遇到了一些兼容性问题，请继续阅读下面的内容来寻找解决方案。\n\n什么是 polyfill\n\npolyfill 是一种用于解决浏览器兼容问题的技术。它用于模拟某些浏览器不支持的新特性，使得这些特性能在不支持的浏览器中正常工作。例如，如果某个浏览器不支持\nArray.prototype.flat() 方法，那么我们可以使用 polyfill 来模拟这个方法，从而让代码在这个浏览器中也能正常工作。\n\n\n背景知识#\n\n在处理兼容性问题之前，建议你了解以下背景知识，以更好地处理相关问题。\n\n\n语法降级和 API 降级#\n\n当你在项目中使用高版本语法和 API 时，为了让编译后的代码能稳定运行在低版本浏览器中，需要完成两部分降级：语法降级和 API 降级。\n\nRsbuild 通过语法转译来对语法进行降级，通过 polyfill 来对 API 进行进行降级。\n\n> 语法和 API 并不是强绑定的，浏览器厂商在实现引擎的时候，会根据规范或者自身需要提前支持一些语法或者提前实现一些\n> API。因此，同一时期的不同厂商的浏览器，对语法和 API 的兼容都不一定相同。所以在一般的实践中，语法和 API 是分成两个部分进行处理的。\n\n\n语法转译#\n\n语法是编程语言如何组织代码的一系列规则，不遵守这些规则的代码无法被编程语言的引擎正确识别，因此无法被运行。在 JavaScript\n中，以下几个示例都是语法规则：\n\n * 在 const foo = 1 中，const 表示声明一个不可变的常量。\n * 在 foo?.bar?.baz 中，?. 表示可选链访问属性。\n * 在 async function () {} 中，async 表示声明一个异步函数。\n\n由于不同浏览器的解析器所能支持的语法不同，尤其是旧版本浏览器引擎所能支持的语法较少，因此一些语法在低版本浏览器引擎中运行时，就会在解析 AST 的阶段报错。\n\n比如下面这段代码在 IE 浏览器或低版本 Node.js 下会报错：\n\n\n\n我们在低版本 Node.js 中运行这段代码，会出现以下错误信息：\n\n\n\n从错误信息里可以明显看到，这是一个语法错误（SyntaxError）。这说明这个语法在低版本的引擎中是不受支持的。\n\n语法是不能通过 polyfill 或者 shim\n进行支持的。如果想在低版本浏览器中运行一些它原本不支持的语法，那么就需要对代码进行转译，转译成低版本引擎所能支持的语法。\n\n将上述代码转译为以下代码即可在低版本引擎中运行：\n\n\n\n转译后，代码的语法变了，把一些低版本引擎无法理解的语法用其可理解的语法替代，但代码本身的意义没有变。\n\n如果引擎在转换为 AST 的时候遇到了无法识别的语法，就会报语法错误，并中止代码执行流程。在这种情况下，如果你的项目没有使用 SSR 或 SSG\n等能力的话，页面将会直接白屏，导致页面不可用。\n\n如果代码被转换为 AST 成功，引擎会将 AST 转为可执行代码，并在引擎内部正常执行。\n\n\nAPI Polyfill#\n\nJavaScript 是解释型脚本语言，不同于 Rust 等编译型语言。Rust 会在编译阶段对代码中的调用进行检查，而 JavaScript\n在真正运行到某一行代码之前，并不知道这一行代码所调用的函数是否存在，因此一些错误只有在运行时才会出现。\n\n举个例子，下面这段代码：\n\n\n\n上面这段代码有着正确的语法，在引擎运行时的第一个阶段也能正确转换为 AST，但是在真正运行的时候，由于 String.prototype 上不存在\nnotExistedMethod 这个方法，所以在实际运行的时候会报错：\n\n\n\n随着 ECMAScript 的迭代，一些内置对象也会迎来新的方法。比如 String.prototype.replaceAll 是在 ES2021\n中被引入的，那么在大部分 2021 年前的浏览器的引擎的内置对象 String.prototype 中是不存在 replaceAll\n方法的，因此下面这段代码在最新的 Chrome 里可以运行，但是在较早的版本里无法运行：\n\n\n\n为了解决在旧版浏览器中的 String.prototype 缺少 replaceAll 的问题，我们可以在老版本的浏览器里扩展 String.prototype\n对象，给它加上 replaceAll 方法，例如：\n\n\n\n> 这种为旧环境提供实现来对齐新 API 的技术被称作 polyfill。\n\n\n降级方式#\n\n在 Rsbuild 中，我们将代码分为三类：\n\n * 第一类是当前项目中的源代码。\n * 第二类是通过 npm 安装的第三方依赖代码。\n * 第三类是非当前项目的代码，比如 monorepo 中其他目录下的代码。\n\n默认情况下，Rsbuild 只会对第一类代码进行编译和降级，而其他类型的代码默认是不进行降级处理的。\n\n之所以这样处理，主要有几个考虑：\n\n * 将所有第三方依赖代码都进行降级的话会导致构建性能显著下降。\n * 大部分第三方依赖在发布前已经进行了降级处理，二次降级可能会引入新问题。\n * 非当前项目的代码可能已经经过了编译处理，或者编译所需的配置与当前项目并不相同。\n\n\n降级当前项目代码#\n\n当前项目的代码会被默认降级，因此你不需要添加额外的配置，只需要保证正确设置了浏览器范围即可。\n\n\n降级第三方依赖#\n\n当你发现某个第三方依赖的代码导致了兼容性问题时，你可以将这个依赖添加到 Rsbuild 的 source.include 配置中，使 Rsbuild\n对该依赖进行额外的编译。\n\n以 query-string 这个 npm 包为例，你可以做如下的配置：\n\n\n\n请查看 source.include 文档来查看更详细的用法说明。\n\n\n降级非当前项目的代码#\n\n当你引用非当前项目的代码时，如果该代码未经过编译处理，那么你也需要配置 source.include 来对它进行编译。\n\n比如，你需要引用 monorepo 中 packages 目录下的某个模块，可以添加如下的配置：\n\n\n\n\nPolyfill 方案#\n\nRsbuild 通过 SWC 编译 JavaScript 代码，并支持注入 core-js、@swc/helpers 等 polyfills。\n\n在不同的使用场景下，你可能会需要不同的 polyfill 方案。Rsbuild 提供了 output.polyfill 配置项来切换不同的 polyfill\n方案。\n\n\n默认行为#\n\nRsbuild 默认不注入任何 polyfill：\n\n\n\n\nusage 方案#\n\n当你开启 usage 方案时，Rsbuild 会分析项目中的源代码，并判断需要注入哪些 polyfill。\n\n比如代码中使用了 Map:\n\n\n\n编译后，只会在该文件中注入 Map 所需的 polyfill：\n\n\n\n这种方式的优点是注入的 polyfill 体积更小，适合对包体积有较高要求的项目使用。缺点是 polyfill\n可能注入不全，因为第三方依赖默认不会被编译和降级处理，因此第三方依赖所需的 polyfill 不会被分析到，如果需要分析某个第三方依赖，也需要将其加入到\nsource.include 配置中。\n\nusage 方案对应的配置为：\n\n\n\n\nentry 方案#\n\n在使用 entry 方案时，Rsbuild 会根据当前项目设置的浏览器范围来计算需要注入哪些 core-js\n方法，并在每个页面的入口文件中进行注入。这种方式注入的 polyfill 较为全面，不需要再担心项目源码和第三方依赖的 polyfill\n问题，但是因为包含了一些没有用到的 polyfill 代码，所以最终的包大小可能会有所增加。\n\nentry 方案对应的配置为：\n\n\n\n\nUA Polyfill#\n\nCloudflare 提供了一个 polyfill 服务，可以根据用户浏览器的 User-Agent 自动生成 polyfill 文件。\n\n你可以通过 Rsbuild 的 html.tags 配置来注入脚本，例如在 标签的开头插入","routePath":"/zh/guide/advanced/browser-compatibility","lang":"zh","toc":[{"text":"设置浏览器范围","id":"设置浏览器范围","depth":2,"charIndex":40},{"text":"背景知识","id":"背景知识","depth":2,"charIndex":498},{"text":"语法降级和 API 降级","id":"语法降级和-api-降级","depth":3,"charIndex":542},{"text":"语法转译","id":"语法转译","depth":3,"charIndex":813},{"text":"API Polyfill","id":"api-polyfill","depth":3,"charIndex":1552},{"text":"降级方式","id":"降级方式","depth":2,"charIndex":2161},{"text":"降级当前项目代码","id":"降级当前项目代码","depth":3,"charIndex":2463},{"text":"降级第三方依赖","id":"降级第三方依赖","depth":3,"charIndex":2523},{"text":"降级非当前项目的代码","id":"降级非当前项目的代码","depth":3,"charIndex":2698},{"text":"Polyfill 方案","id":"polyfill-方案","depth":2,"charIndex":2825},{"text":"默认行为","id":"默认行为","depth":3,"charIndex":2997},{"text":"usage 方案","id":"usage-方案","depth":3,"charIndex":3034},{"text":"entry 方案","id":"entry-方案","depth":3,"charIndex":3326},{"text":"UA Polyfill","id":"ua-polyfill","depth":3,"charIndex":3529}],"domain":"","frontmatter":{},"version":""},{"id":297,"title":"设置浏览器范围","content":"#\n\nRsbuild 支持通过 Browserslist 来设置 Web 应用需要兼容的浏览器范围。\n\n\n什么是 Browserslist#\n\n由于各种浏览器对 ECMAScript 和 CSS 的支持程度不同，因此开发者需要根据使用场景，为 Web 应用设置正确的浏览器范围。\n\nBrowserslist 可以指定 Web 应用能够在哪些浏览器中正常运行，它提供了统一的配置格式，并且已经成为了前端社区中的标准。Browserslist 被\nSWC, Lightning CSS, Babel, ESLint, PostCSS 和 webpack 等库所使用。\n\n当你通过 Browserslist 指定了一个浏览器范围时，Rsbuild 会将 JavaScript 代码和 CSS 代码编译到指定的语法。\n\n\nPolyfill 注入#\n\n如果你开启了 output.polyfill，Rsbuild 还会基于 browserslist 注入相应的 polyfill\n代码。当你只需要兼容更现代的浏览器时，构建过程会引入更少的兼容代码和 polyfills，页面的性能会更好。\n\n\n\n比如，当你需要适配 IE11 浏览器时，Rsbuild 会将代码编译至 ES5，并通过 core-js 注入 IE11 所需的 polyfill。\n\n> 请参考 浏览器兼容性 了解更多。\n\n\n设置 Browserslist#\n\n你可以在当前项目根目录的 package.json 或 .browserslistrc 文件里设置 Browserslist 的值。\n\n\n示例#\n\n通过 package.json 的 browserslist 设置：\n\n\n\n通过独立的 .browserslistrc 文件设置：\n\n\n\n\n生效范围#\n\n.browserslistrc 文件默认只对浏览器端的构建产物生效，包括 web 和 web-worker 这两种产物类型。\n\n当你同时构建多种产物，比如 target 包含 web 和 node 两种产物时，只有 web 产物会受到 .browserslistrc\n文件的影响。如果你希望对 node 产物进行修改，可以使用下方的 output.overrideBrowserslist 配置。\n\n\n按环境设置#\n\n你可以基于 NODE_ENV 来设置不同的 browserslist，这样可以为开发模式和生产模式指定不同浏览器范围。\n\n比如在 package.json 中基于 key 设置：\n\n\n\n也可以通过 .browserslistrc：\n\n\n\n\noverrideBrowserslist#\n\n除了上述的标准用法，Rsbuild 还提供了 output.overrideBrowserslist 配置项，同样可以设置 Browserslist 的值。\n\noverrideBrowserslist 可以被设置为一个数组，数组的写法与 browserslistrc 配置是一样的，但比 browserslistrc\n拥有更高的优先级。\n\n\n\n大多数场景下，推荐优先使用 .browserslistrc 文件，而不是使用 overrideBrowserslist 配置。因为\n.browserslistrc 文件是官方定义的配置文件，通用性更强，可以被社区中的其他库识别。\n\n\n常用的浏览器范围#\n\n以下是一些常用的浏览器范围，你可以根据自己的项目类型进行选择。\n\n\n桌面端 PC 场景#\n\n在桌面端 PC 场景下，如果你需要兼容 IE 11 浏览器，则可以将 Browserslist 设置为：\n\n\n\n以上浏览器范围会将代码编译至 ES5 规范，具体对应的浏览器列表可以查看 browserslist.dev。\n\n如果你不需要兼容 IE 11 浏览器，那么可以调整 Browserslist 来获得更高性能的产物，比如：\n\n * 设置为支持原生 ES Modules 的浏览器（推荐）：\n\n\n\n * 设置为支持 ES6 的浏览器：\n\n\n\n\n移动端 H5 场景#\n\n移动端 H5 场景主要兼容 iOS 和 Android 系统，通常我们将 Browserslist 设置为：\n\n\n\n以上浏览器范围会将代码编译至 ES5 规范，可以兼容市面上绝大多数移动端场景，具体对应的浏览器列表可以查看 browserslist.dev。\n\n\n\n你也可以选择在 H5 场景使用 ES6 规范，这样会让页面的性能表现更好，对应的 Browserslist 如下：\n\n\n\n\nBrowserslist 默认值#\n\nRsbuild 会根据 output.target 来设置不同的 Browserslist 默认值，但我们推荐你在项目中显式设置\nBrowserslist，这会让项目的兼容范围更加明确。\n\n\nWeb 产物#\n\nWeb 产物的默认值如下所示：\n\n\n\n在该浏览器范围下，JavaScript 产物最低兼容到支持原生 ES Modules 的浏览器。\n\n\nNode 产物#\n\nNode 产物默认最低兼容到 Node.js 16.0 版本。\n\n\n\n\nWeb Worker 产物#\n\nWeb worker 产物默认的浏览器范围与 web 一致。\n\n\n\n\nService Worker 产物#\n\nService worker 产物默认的浏览器范围与 web 一致。\n\n\n\n\n查询浏览器支持情况#\n\n在开发时，我们需要了解某些特性或 API 的浏览器支持情况，此时我们可以在 caniuse 网站上进行查询。\n\n比如我们需要知道 Promise 的浏览器支持情况，只需要在 caniuse 中输入 Promise，就可以看到以下结果：\n\n\n\n从上表可以看出，Promise 在 Chrome 33 和 iOS 8 中得到了原生支持，但是在 IE 11 中不被支持。","routePath":"/zh/guide/advanced/browserslist","lang":"zh","toc":[{"text":"什么是 Browserslist","id":"什么是-browserslist","depth":2,"charIndex":52},{"text":"Polyfill 注入","id":"polyfill-注入","depth":2,"charIndex":356},{"text":"设置 Browserslist","id":"设置-browserslist","depth":2,"charIndex":588},{"text":"示例","id":"示例","depth":3,"charIndex":675},{"text":"生效范围","id":"生效范围","depth":3,"charIndex":750},{"text":"按环境设置","id":"按环境设置","depth":3,"charIndex":958},{"text":"overrideBrowserslist","id":"overridebrowserslist","depth":3,"charIndex":1086},{"text":"常用的浏览器范围","id":"常用的浏览器范围","depth":2,"charIndex":1398},{"text":"桌面端 PC 场景","id":"桌面端-pc-场景","depth":3,"charIndex":1443},{"text":"移动端 H5 场景","id":"移动端-h5-场景","depth":3,"charIndex":1680},{"text":"Browserslist 默认值","id":"browserslist-默认值","depth":2,"charIndex":1887},{"text":"Web 产物","id":"web-产物","depth":3,"charIndex":2002},{"text":"Node 产物","id":"node-产物","depth":3,"charIndex":2081},{"text":"Web Worker 产物","id":"web-worker-产物","depth":3,"charIndex":2127},{"text":"Service Worker 产物","id":"service-worker-产物","depth":3,"charIndex":2178},{"text":"查询浏览器支持情况","id":"查询浏览器支持情况","depth":2,"charIndex":2237}],"domain":"","frontmatter":{},"version":""},{"id":298,"title":"环境变量","content":"#\n\nRsbuild 支持在构建过程中向代码中注入环境变量或表达式，这对于区分运行环境、替换常量值等场景很有帮助。\n\n本章节将介绍如何在 Rsbuild 中使用环境变量。\n\n\n默认环境变量#\n\nRsbuild 默认通过 source.define 向代码中注入以下环境变量，它们会在构建时被替换为指定的值：\n\nimport.meta.env 包含以下环境变量：\n\n * import.meta.env.MODE\n * import.meta.env.DEV\n * import.meta.env.PROD\n * import.meta.env.BASE_URL\n * import.meta.env.ASSET_PREFIX\n\nprocess.env 包含以下环境变量：\n\n * process.env.BASE_URL\n * process.env.ASSET_PREFIX\n * process.env.NODE_ENV：该变量由 Rspack 注入，如需关闭或修改，可参考 Rspack - optimization.nodeEnv\n\n\nimport.meta.env.MODE#\n\n你可以在 client 代码中使用 import.meta.env.MODE 来读取 mode 配置项的值。\n\n\n\n在开发模式，以上代码会被编译为：\n\n\n\n在生产模式，以上代码会被编译为：\n\n\n\n在代码压缩过程中，if (false) { ... } 会被识别为无效代码，并被自动移除。\n\n\nimport.meta.env.DEV#\n\n当 mode 为 'development' 时，值为 true，否则为 false。\n\n\n\n\nimport.meta.env.PROD#\n\n当 mode 为 'production' 时，值为 true，否则为 false。\n\n\n\n\nimport.meta.env.BASE_URL#\n\n你可以在 client 代码中使用 import.meta.env.BASE_URL 来访问服务端的基础路径，它由 server.base\n配置项决定，这有助于在代码中引用 public 目录 下的资源。\n\n比如，我们通过 server.base 配置，将服务端的基础路径设置为 /foo：\n\n\n\n此时，public 目录下 favicon.ico 文件的访问 URL 为 http://localhost:3000/foo/favicon.ico，在 JS\n文件中可以使用 import.meta.env.BASE_URL 来拼接 URL：\n\n\n\n\nimport.meta.env.ASSET_PREFIX#\n\n你可以在 client 代码中使用 import.meta.env.ASSET_PREFIX 来访问静态资源的前缀。\n\n * 在开发模式下，它等同于 dev.assetPrefix 设置的值。\n * 在生产模式下，它等同于 output.assetPrefix 设置的值。\n * Rsbuild 会自动移除 assetPrefix 尾部的斜线符号，以便于进行字符串拼接。\n\n比如，我们通过 output.copy 配置，将 static/icon.png 图片拷贝到 dist 目录下：\n\n\n\n此时，我们可以在 client 代码中通过以下方式来拼接图片 URL：\n\n\n\n在开发模式，以上代码会被编译为：\n\n\n\n在生产模式，以上代码会被编译为：\n\n\n\n\nprocess.env.BASE_URL#\n\nRsbuild 也允许使用 process.env.BASE_URL，它是 import.meta.env.BASE_URL 的别名。\n\n例如，在 HTML 模板中，可以使用 process.env.BASE_URL 来拼接 URL：\n\n\n\n\nprocess.env.ASSET_PREFIX#\n\nRsbuild 也允许使用 process.env.ASSET_PREFIX，它是 import.meta.env.ASSET_PREFIX 的别名。\n\n例如，在 HTML 模板中，可以使用 process.env.ASSET_PREFIX 来拼接 URL：\n\n\n\n\nprocess.env.NODE_ENV#\n\n默认情况下，Rsbuild 会自动设置 process.env.NODE_ENV 环境变量，在开发模式为 'development'，生产模式为\n'production'。\n\n你可以在 Node.js 和 client 代码中直接使用 process.env.NODE_ENV。\n\n\n\n在开发模式，以上代码会被编译为：\n\n\n\n在生产模式，以上代码会被编译为：\n\n\n\n在代码压缩过程中，if (false) { ... } 会被识别为无效代码，并被自动移除。\n\n\n.env 文件#\n\n当项目根目录存在 .env 文件时，Rsbuild CLI 会自动使用 dotenv 来加载这些环境变量，并添加到当前 Node.js 进程中，其中的\npublic 变量 会被暴露在 client 代码中。\n\n你可以通过 import.meta.env.[name] 或 process.env.[name] 来访问这些环境变量。\n\n\n文件类型#\n\nRsbuild 支持读取以下 env 文件：\n\n文件名                      描述\n.env                     在所有场景下默认加载。\n.env.local               .env 文件的本地用法，需要添加到 .gitignore 中。\n.env.development         当 process.env.NODE_ENV 为 'development' 时读取。\n.env.production          当 process.env.NODE_ENV 为 'production' 时读取。\n.env.development.local   .env.development 文件的本地用法，需要添加到 .gitignore 中。\n.env.production.local    .env.production 文件的本地用法，需要添加到 .gitignore 中。\n\n如果同时存在上述的多个文件，那么多个文件都会被读取，并且表格下方的文件具有更高的优先级。\n\n\nEnv 模式#\n\nRsbuild 也支持读取 .env.[mode] 和 .env.[mode].local 文件，你可以通过 CLI 的 --env-mode 选项来指定\nenv 模式。\n\n比如，指定 env 模式为 test：\n\n\n\nRsbuild 会依次读取以下文件：\n\n * .env\n * .env.local\n * .env.test\n * .env.test.local\n\nTIP\n\n--env-mode 选项的优先级高于 process.env.NODE_ENV。\n\n推荐使用 --env-mode 来指定 env 模式，不建议修改 process.env.NODE_ENV。\n\n\nEnv 目录#\n\n默认情况下，.env 文件位于项目的根目录。你可以通过 CLI 的 --env-dir 选项来指定 env 目录。\n\n比如，指定 env 目录为 config：\n\n\n\n这种情况下，Rsbuild 会读取 ./config/.env 等 env 文件。\n\n\n示例#\n\n比如创建 .env 文件并添加以下内容：\n\n\n\n然后在 rsbuild.config.ts 文件中，你可以通过 import.meta.env.[name] 或 process.env.[name]\n访问到上述环境变量：\n\n\n\n此时，创建一个 .env.local 文件，添加以下内容：\n\n\n\nBAR 的值会被覆盖为 '2'：\n\n\n\n\n手动加载#\n\n如果你没有使用 Rsbuild 的 CLI，而是使用了 Rsbuild 的 JavaScript API，那么你需要手动调用 Rsbuild 提供的\nloadEnv 方法来读取环境变量，并通过 source.define 配置项注入到代码中。\n\n\n\n\npublic 变量#\n\n所有以 PUBLIC_ 开头的环境变量可以在 client 代码中访问，比如定义了以下变量：\n\n\n\n在 client 代码中，你可以通过 import.meta.env.PUBLIC_* 或 process.env.PUBLIC_*\n访问这些环境变量，Rsbuild 会匹配标识符替换为相应的值。\n\n\n\nTIP\n * public 变量的内容会出现在你的 client 代码中，请避免在 public 变量中包含敏感信息。\n * public 变量是通过 source.define 替换的，请阅读「使用 define」来了解 define 的原理和注意事项。\n\n\n替换范围#\n\npublic 变量会替换 client 代码中的标识符，替换范围包含：\n\n * JavaScript 文件，以及能转换为 JavaScript 代码的文件，比如 .js，.ts，.tsx 等。\n * HTML 模板文件，比如：\n\n\n\n注意，public 变量不会替换以下文件中的标识符：\n\n * CSS 文件，比如 .css, .scss, .less 等。\n\n\n自定义前缀#\n\nRsbuild 提供了 loadEnv 方法，可以把任何前缀的环境变量注入到 client 代码中。\n\n比如将一个 Create React App 项目迁移到 Rsbuild 时，你可以通过以下方式来读取 REACT_APP_ 开头的环境变量，并通过\nsource.define 配置项注入：\n\n\n\n\n使用 define#\n\n通过 source.define 选项，你可以在构建时将代码中的全局标识符替换成其它值或者表达式。\n\ndefine 类似于其它一些语言提供的宏定义能力，它常用于在构建时向代码注入环境变量等信息。\n\n\n替换标识符#\n\ndefine 最基础的用途是在构建时替换代码中的全局标识符。\n\n例如环境变量 NODE_ENV 的值会影响许多第三方模块的行为，在构建线上应用的产物时通常需要将它设置为 \"production\"：\n\n\n\n需要注意的是这里提供的值必须是 JSON 字符串，例如 process.env.NODE_ENV 的值为 \"production\" 则传入的值应当是\n\"\\\"production\\\"\" 才能够正确被处理。\n\n同理 { foo: \"bar\" } 也应该被转换成 \"{\\\"foo\\\":\\\"bar\\\"}\"，如果直接传入原始对象则意味着把标识符\nprocess.env.NODE_ENV.foo 替换为标识符 bar。\n\nsource.define 的具体行为请参考 API 文档。\n\nTIP\n\n以上例子中的环境变量 NODE_ENV 已经由 Rsbuild 自动注入，通常你不需要手动配置它的值。\n\n\n标识符匹配#\n\n需要注意的是，source.define 只能匹配完整的全局标识符，你可以将它理解为一个文本替换的过程。\n\n如果代码里的标识符与 define 里定义的 key 不是完全相同的，Rsbuild 将无法替换它。\n\n\n\n\nprocess.env 替换方式#\n\n在使用 source.define 时，请避免替换整个 process.env 对象，比如下面的用法是不推荐的：\n\n\n\n如果你采用了上述用法，将会导致如下问题：\n\n 1. 额外注入了一些未使用的环境变量，导致开发服务器的环境变量被泄露到前端代码中。\n 2. 由于每一处 process.env 代码都会被替换为完整的环境变量对象，导致前端代码的包体积增加，性能降低。\n\n因此，请按照实际需求来注入 process.env 上的环境变量，避免全量替换。\n\n\n类型声明#\n\n当你在 TypeScript 代码中访问环境变量时，TypeScript 可能会提示该变量缺少类型定义，此时你需要添加相应的类型声明。\n\n比如你引用了一个 PUBLIC_FOO 变量，在 TypeScript 文件中会出现如下提示：\n\n\n\n此时，你可以在项目中创建 src/env.d.ts 文件，并添加以下内容：\n\n\n\n\nimport.meta.env#\n\n你可以像这样来扩展 import.meta.env 的类型：\n\n\n\n\nprocess.env#\n\n如果缺少 process.env 的类型，请安装 @types/node 依赖：\n\n然后扩展 process.env 的类型：\n\n\n\n\nTree Shaking#\n\ndefine 还可以用于标记死代码以协助 Rspack 进行 tree shaking 优化。\n\n例如通过将 import.meta.env.LANGUAGE 替换为具体值来实现针对不同语言的产物进行差异化构建：\n\n\n\n对于一段国际化代码：\n\n\n\n指定环境变量 LANGUAGE=zh 并执行构建，得到的产物会移除多余的代码：\n\n\n\n未用到的组件不会被打包，它们的外部依赖也会对应地被移除，最终可以得到体积更小的构建产物。","routePath":"/zh/guide/advanced/env-vars","lang":"zh","toc":[{"text":"默认环境变量","id":"默认环境变量","depth":2,"charIndex":87},{"text":"import.meta.env.MODE","id":"importmetaenvmode","depth":3,"charIndex":471},{"text":"import.meta.env.DEV","id":"importmetaenvdev","depth":3,"charIndex":640},{"text":"import.meta.env.PROD","id":"importmetaenvprod","depth":3,"charIndex":710},{"text":"import.meta.env.BASE_URL","id":"importmetaenvbase_url","depth":3,"charIndex":780},{"text":"import.meta.env.ASSET_PREFIX","id":"importmetaenvasset_prefix","depth":3,"charIndex":1083},{"text":"process.env.BASE_URL","id":"processenvbase_url","depth":3,"charIndex":1441},{"text":"process.env.ASSET_PREFIX","id":"processenvasset_prefix","depth":3,"charIndex":1586},{"text":"process.env.NODE_ENV","id":"processenvnode_env","depth":3,"charIndex":1747},{"text":"`.env` 文件","id":"env-文件","depth":2,"charIndex":-1},{"text":"文件类型","id":"文件类型","depth":3,"charIndex":2179},{"text":"Env 模式","id":"env-模式","depth":3,"charIndex":2657},{"text":"Env 目录","id":"env-目录","depth":3,"charIndex":2956},{"text":"示例","id":"示例","depth":3,"charIndex":3093},{"text":"手动加载","id":"手动加载","depth":3,"charIndex":3266},{"text":"public 变量","id":"public-变量","depth":2,"charIndex":3399},{"text":"替换范围","id":"替换范围","depth":3,"charIndex":3694},{"text":"自定义前缀","id":"自定义前缀","depth":3,"charIndex":3883},{"text":"使用 define","id":"使用-define","depth":2,"charIndex":4043},{"text":"替换标识符","id":"替换标识符","depth":3,"charIndex":4155},{"text":"标识符匹配","id":"标识符匹配","depth":3,"charIndex":4562},{"text":"process.env 替换方式","id":"processenv-替换方式","depth":3,"charIndex":4679},{"text":"类型声明","id":"类型声明","depth":2,"charIndex":4926},{"text":"import.meta.env","id":"importmetaenv","depth":3,"charIndex":5095},{"text":"process.env","id":"processenv","depth":3,"charIndex":5148},{"text":"Tree Shaking","id":"tree-shaking","depth":2,"charIndex":5230}],"domain":"","frontmatter":{},"version":""},{"id":299,"title":"多环境构建","content":"#\n\nRsbuild 支持同时为多个环境构建产物。你可以使用 environments 来并行构建多个环境，并为每个环境设置不同的 Rsbuild 配置。\n\n\n什么是 environment#\n\nenvironment 指的是构建产物的运行环境，常见的运行环境有浏览器、Node.js 和 Workers。Rsbuild 允许你定义任意的\nenvironment 名称，并为这些 environment 分别设置构建选项。\n\n一个典型的场景是服务器端渲染（SSR），你可以定义 web 和 node 两个 environments，它们的构建目标（output.target）分别是\nweb 和 node，并用于客户端渲染（CSR）和服务器端渲染（SSR）场景。\n\n此外，你还可以为同一个构建目标定义不同的 environment，例如：\n\n * 定义 rsc 和 ssr 两个环境，它们的构建目标都是 node，分别用于 React Server Components 和 SSR。\n * 定义 desktop 和 mobile 两个环境，它们的构建目标都是 web，分别用于桌面端浏览器和移动端浏览器。\n\n如果没有 environments 配置，你需要为这些场景定义多份配置，并执行多次独立的 Rsbuild 构建。现在通过 environments\n配置，你可以在一次 Rsbuild 构建中完成多种产物的构建（Rsbuild 基于 Rspack 的 MultiCompiler 来实现这一点）。\n\nRsbuild 中的每个 environment 关联一份 Rsbuild 配置、一份 Rspack 配置和一份构建产物。Rsbuild 插件的开发者可以基于\nenvironment 名称，对指定环境的构建流程进行定制，如修改 Rsbuild 或 Rspack 配置、注册或移除插件、调整 Rspack\n规则和查看静态资源信息等。\n\n\n多环境配置#\n\nRsbuild 支持通过 environments 为每个环境定义不同的 Rsbuild 配置。\n\n例如，假如你的项目希望支持 SSR 功能，你需要分别为 client 和 SSR 定义不同的配置，你可以分别定义一个 web 和 node 的\nenvironment。\n\n\n\n\n配置合并#\n\n当你配置 environments 时，Rsbuild 会将 environments 里的配置与外层的基础配置进行合并。合并时，environments\n中的配置具有更高的优先级。\n\n在上述例子中，在合并配置后，Rsbuild 会生成两份独立的 environments 配置，分别用于构建 web 和 node 环境的产物。\n\n * web environments config：由 base config 和 environments.web 合并生成\n * node environments config：由 base config 和 environments.node 合并生成\n\n接着，Rsbuild 会基于这些 environments 配置，在内部生成两份 Rspack 配置，并通过 Rspack 的 MultiCompiler\n来执行单次构建。\n\n\n配置调试#\n\n当你在项目根目录下执行命令 npx rsbuild inspect 后，会发现有如下输出：\n\n * rsbuild.config.[name].mjs: 表示在构建时某个 environment 对应使用的 Rsbuild 配置。\n * rspack.config.[name].mjs: 表示在构建时某个 environment 对应使用的 Rspack 配置。\n\n\n\n\n默认 environment#\n\n当 environments 未指定时，Rsbuild 默认会根据当前的产物类型 (output.target 的值) 创建一个同名的环境。\n\n\n\n以上配置相当于下面配置的语法糖：\n\n\n\n\n仅构建指定环境#\n\n默认情况下，当你执行 rsbuild dev 或 rsbuild build 时，Rsbuild 会构建所有 Rsbuild 配置中的环境。你可以通过\n--environment 仅构建指定环境。\n\n\n\n\n为指定环境添加插件#\n\n通过 plugins 字段配置的插件支持在所有环境下运行，如果你希望某个插件仅在指定环境下运行时，将该插件配置在特定 environment 下即可。\n\n例如，仅在 web 环境下开启 React 插件：\n\n\n\n如果你是插件开发者，可查看 开发 Environment 插件 了解详情。\n\n\n插件 API#\n\n\n更新配置#\n\nRsbuild 支持通过 modifyRsbuildConfig 钩子新增或修改 environment 配置。\n\n\n\n\n配置特定 environment#\n\nRsbuild 支持通过 modifyEnvironmentConfig 钩子修改特定 environment 的 Rsbuild 配置。\n\n\n\n\nEnvironment 上下文#\n\nEnvironment context 是一个只读对象，提供一些和当前环境有关的上下文信息。Rsbuild 支持在 plugin hook 中获取\nenvironment context 信息。\n\n对于一些与构建环境相关的 plugin hooks（如 modifyRspackConfig、modifyBundlerChain 等）, Rsbuild\n支持通过 environment 参数获取当前 environment 上下文。\n\n\n\n对于一些全局的 plugin hooks（如 onDevCompileDone、onBeforeStartDevServer 等）， Rsbuild 支持通过\nenvironments 参数获取所有环境的上下文。\n\n\n\n\nEnvironment API#\n\nRsbuild Server 提供了一系列和构建环境相关的 API，用户可通过 Rsbuild environment API\n在服务器端操作特定环境下的构建产物。\n\n你可以在 Rsbuild DevMiddleware 或自定义 Server 中使用 environment API。\n\n例如，你可以通过 Rsbuild environment API 在开发模式下快速实现一个 SSR 功能：\n\n\n\n详细使用情况可参考：SSR + Express 示例。\n\n\n构建顺序#\n\n默认情况下，Rsbuild 会并行构建所有环境。\n\n如果你需要控制不同环境之间的构建顺序，可以通过 Rspack 的 dependencies 配置来设置构建依赖关系。\n\n例如，假设你需要先完成 web 环境的构建，再开始构建 node 环境，可以添加如下配置：\n\n\n\n我们可以通过一个简单的插件来测试多个环境的构建顺序：\n\n","routePath":"/zh/guide/advanced/environments","lang":"zh","toc":[{"text":"什么是 environment","id":"什么是-environment","depth":2,"charIndex":79},{"text":"多环境配置","id":"多环境配置","depth":2,"charIndex":821},{"text":"配置合并","id":"配置合并","depth":3,"charIndex":968},{"text":"配置调试","id":"配置调试","depth":3,"charIndex":1363},{"text":"默认 environment","id":"默认-environment","depth":2,"charIndex":1557},{"text":"仅构建指定环境","id":"仅构建指定环境","depth":2,"charIndex":1669},{"text":"为指定环境添加插件","id":"为指定环境添加插件","depth":2,"charIndex":1782},{"text":"插件 API","id":"插件-api","depth":2,"charIndex":1940},{"text":"更新配置","id":"更新配置","depth":3,"charIndex":1950},{"text":"配置特定 environment","id":"配置特定-environment","depth":3,"charIndex":2018},{"text":"Environment 上下文","id":"environment-上下文","depth":2,"charIndex":2111},{"text":"Environment API","id":"environment-api","depth":2,"charIndex":2461},{"text":"构建顺序","id":"构建顺序","depth":2,"charIndex":2711}],"domain":"","frontmatter":{},"version":""},{"id":300,"title":"模块热更新","content":"#\n\n模块热更新（HMR - hot module\nreplacement）功能会在应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：\n\n * 保留在完全重新加载页面期间丢失的应用程序状态。\n * 只更新变更内容，以节省宝贵的开发时间。\n * 在源代码中 CSS / JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。\n\n\nHMR 开关#\n\nRsbuild 已内置了对 HMR 的支持，在开发模式下默认启用。\n\n如果你不需要使用 HMR 能力，可以将 dev.hmr 设置为 false，此时热更新和 react-refresh 将被禁用，Rsbuild 会自动降级到\ndev.liveReload。\n\n\n\n如果你需要同时禁用 HMR 和 liveReload，可以将 dev.hmr 和 dev.liveReload 都设置为 false，此时页面上不会发起 Web\nSocket 请求到 dev server，也不会在文件变更时自动刷新页面。\n\n\n\n\n自定义 HMR URL#\n\n在默认情况下，Rsbuild 使用当前页面的 host 和端口号来拼接 HMR 对应的 WebSocket URL。\n\n当出现 HMR 连接失败的情况时，你可以自定义 dev.client 配置来指定 WebSocket URL。\n\n\n\n\n文件监听#\n\nRsbuild 默认不监听 .git/ 和 node_modules/ 目录下的文件，当这些目录下的文件发生变化时，Rsbuild\n不会触发重新构建。这有助于减少内存占用和提升构建性能。\n\n如果你希望监听这些目录，可以手动配置 Rspack 的 watchOptions.ignored 来覆盖默认行为。\n\n例如，监听 node_modules/ 目录且忽略 .git/ 目录，可以配置为：\n\n\n\n\n常见问题#\n\n请参考 热更新问题。","routePath":"/zh/guide/advanced/hmr","lang":"zh","toc":[{"text":"HMR 开关","id":"hmr-开关","depth":2,"charIndex":215},{"text":"自定义 HMR URL","id":"自定义-hmr-url","depth":2,"charIndex":481},{"text":"文件监听","id":"文件监听","depth":2,"charIndex":615},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":822}],"domain":"","frontmatter":{},"version":""},{"id":301,"title":"模块联邦","content":"#\n\nModule Federation 是一种 JavaScript 应用分治的架构模式（类似于服务端的微服务），它允许你在多个 JavaScript\n应用程序（或微前端）之间共享代码和资源。\n\nRspack 团队与 Module Federation 的开发团队密切合作，并为 Module Federation 提供一流的支持。\n\n\n使用场景#\n\n模块联邦有一些典型的使用场景，包括：\n\n * 允许独立应用（在微前端架构中称为\"微前端\"）之间共享模块，无需重新编译整个应用。\n * 不同的团队在不需要重新编译整个应用的情况下处理同一应用的不同部分。\n * 应用之间在运行时进行动态代码加载和共享。\n\n模块联邦可以帮助你：\n\n * 减少代码重复\n * 提高代码可维护性\n * 降低应用程序的整体大小\n * 提高应用程序的性能\n\n\n如何使用#\n\nModule Federation（MF） 目前有多个主要版本，你可以根据你的需求选择其中一个使用。\n\n下面是几个版本的特点：\n\n版本        描述                                                     特点                                                       使用场景\nMF v2.0   Module Federation 的增强版本，基于 Module Federation v1.5 实现   - 开箱即用的提供了一些额外的功能，比如动态 TS 类型提示、Chrome DevTools、预加载等-     需要使用 MF 2.0 进阶能力的项目\n                                                                 更适用于支持大型 Web 应用的微前端架构 - 包括 Module Federation 1.5 的所有功能\nMF v1.5   Rspack 内置支持的版本                                         - 支持 Module Federation v1.0 的模块导出、模块加载、依赖共享等能力-          不需要使用 MF 2.0 使用的额外能力\n                                                                 添加了运行时插件功能，允许用户扩展模块联邦的行为、功能\n\n\nModule Federation v2.0#\n\nModule Federation 2.0 在 Module Federation 的基础上，开箱即用的提供了一些额外的功能，比如动态 TS\n类型提示、Chrome devtool、Runtime plugin、预加载，这些功能让 Module Federation 更适用于支持大型 Web\n应用的微前端架构，Module Federation v2.0 在 v1.5 的基础上实现。\n\n你需要安装额外的 @module-federation/rsbuild-plugin 插件，才能使用 Module Federation v2.0。\n\n\n\n请参考 Module Federation v2.0 官方文档 来了解具体的用法。\n\n\nModule Federation v1.5#\n\n这是 Rspack 内置支持的版本，除了支持 Module Federation v1.0\n的模块导出、模块加载、依赖共享等能力之外，还添加了运行时插件功能，允许用户扩展模块联邦的行为、功能。\n\n你可以通过 Rsbuild 的 moduleFederation.options 来使用它，无须安装任何插件。\n\n\n\n\n示例仓库#\n\nRsbuild 提供了一些 Module Federation 的示例项目，你可以参考：\n\n * Module Federation v2.0 示例\n * Module Federation v1.5 示例","routePath":"/zh/guide/advanced/module-federation","lang":"zh","toc":[{"text":"使用场景","id":"使用场景","depth":2,"charIndex":169},{"text":"如何使用","id":"如何使用","depth":2,"charIndex":366},{"text":"Module Federation v2.0","id":"module-federation-v20","depth":3,"charIndex":1065},{"text":"Module Federation v1.5","id":"module-federation-v15","depth":3,"charIndex":1407},{"text":"示例仓库","id":"示例仓库","depth":2,"charIndex":1590}],"domain":"","frontmatter":{},"version":""},{"id":302,"title":"服务端渲染（SSR）","content":"","routePath":"/zh/guide/advanced/ssr","lang":"zh","toc":[{"text":"什么是 SSR","id":"什么是-ssr","depth":2,"charIndex":-1},{"text":"文件结构","id":"文件结构","depth":2,"charIndex":-1},{"text":"创建 SSR 配置","id":"创建-ssr-配置","depth":2,"charIndex":-1},{"text":"自定义 Server","id":"自定义-server","depth":2,"charIndex":-1},{"text":"修改启动脚本","id":"修改启动脚本","depth":2,"charIndex":-1},{"text":"获取资源清单","id":"获取资源清单","depth":2,"charIndex":-1},{"text":"示例项目","id":"示例项目","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":303,"title":"命令行工具","content":"#\n\nRsbuild 内置了一个轻量的命令行工具，包含 rsbuild dev、rsbuild build 等命令。\n\n\nrsbuild -h#\n\n如果你需要查看所有可用的 CLI 命令，请在项目目录中运行以下命令：\n\n\n\n输出如下：\n\n\n\n\nrsbuild dev#\n\nrsbuild dev 命令用于启动一个本地开发服务器，对源代码进行开发模式编译。\n\n\n\n\n打开页面#\n\n通过 --open 选项可以在启动 dev server 时自动打开页面，等同于将 server.open 设置为 true。\n\n\n\n--open 选项也支持指定需要打开的 URL 地址，比如：\n\n\n\n--open 选项也可以缩写为 -o：\n\n\n\nTIP\n\n当同时使用 server.open 和 --open 时，--open 的优先级更高。\n\n\nrsbuild build#\n\nrsbuild build 命令默认会在 dist/ 目录下构建出可用于生产环境的产物。\n\n\n\n\nrsbuild preview#\n\nrsbuild preview 命令用于在本地预览生产模式构建的产物, 注意你需要提前执行 rsbuild build 命令构建出对应产物。\n\n\n\nTIP\n\npreview 命令仅用于本地预览，请勿将它用于生产服务器，因为它不是为此而设计的。\n\n\nrsbuild inspect#\n\nrsbuild inspect 命令用于查看项目的 Rsbuild 配置以及 Rspack 配置。\n\n\n\n当你在项目根目录下执行命令 npx rsbuild inspect 后，会在项目的 dist/.rsbuild 目录生成以下文件：\n\n * rsbuild.config.mjs: 表示在构建时使用的 Rsbuild 配置。\n * rspack.config.web.mjs: 表示在构建时使用的 Rspack 配置。\n\n\n\n\n指定模式#\n\n默认情况下，inspect 命令会输出开发模式的配置，你可以添加 --mode production 选项来输出生产模式的配置：\n\n\n\n\n完整内容#\n\n默认情况下，inspect 命令会省略配置对象中的函数内容，你可以添加 --verbose 选项来输出函数的完整内容：\n\n\n\n\n多种产物类型#\n\n如果当前项目有多种产物类型，比如同时构建了浏览器产物和 Node.js 产物，那么会在 dist/.rsbuild 目录生成多份 Rspack 配置文件。\n\n","routePath":"/zh/guide/basic/cli","lang":"zh","toc":[{"text":"rsbuild -h","id":"rsbuild--h","depth":2,"charIndex":60},{"text":"rsbuild dev","id":"rsbuild-dev","depth":2,"charIndex":121},{"text":"打开页面","id":"打开页面","depth":3,"charIndex":181},{"text":"rsbuild build","id":"rsbuild-build","depth":2,"charIndex":363},{"text":"rsbuild preview","id":"rsbuild-preview","depth":2,"charIndex":428},{"text":"rsbuild inspect","id":"rsbuild-inspect","depth":2,"charIndex":570},{"text":"指定模式","id":"指定模式","depth":3,"charIndex":804},{"text":"完整内容","id":"完整内容","depth":3,"charIndex":880},{"text":"多种产物类型","id":"多种产物类型","depth":3,"charIndex":951}],"domain":"","frontmatter":{},"version":""},{"id":304,"title":"配置 Rsbuild","content":"#\n\nRsbuild 提供了丰富的配置项，并为每个配置项预设了一个通用的默认值，它可以满足大部分使用场景。因此，在大多数情况下，你不需要声明任何 Rsbuild\n配置，直接开箱使用即可。\n\n如果你需要定制一些构建行为，那么可以使用这些配置项。\n\n\n配置结构#\n\nRsbuild 的配置结构如下所示：\n\n\n\n你可以在 Config 总览 页面找到所有配置项的详细说明。\n\n\n配置文件#\n\n当你使用 Rsbuild 的 CLI 命令时，Rsbuild 会自动读取当前项目根目录下的配置文件，按照以下顺序进行解析：\n\n * rsbuild.config.mjs\n * rsbuild.config.ts\n * rsbuild.config.js\n * rsbuild.config.cjs\n * rsbuild.config.mts\n * rsbuild.config.cts\n\n我们推荐使用 .mjs 或 .ts 格式的配置文件，并从 @rsbuild/core 中导入 defineConfig 工具函数, 它提供了友好的\nTypeScript 类型推导和自动补全，可以帮助你避免配置中的错误。\n\n比如在 rsbuild.config.ts 中，你可以定义 Rsbuild 的 resolve.alias 配置：\n\n\n\n如果你在开发一个非 TypeScript 项目，可以使用 .mjs 格式的配置文件：\n\n\n\nTIP\n\n当你使用 .ts, .mts 和 .cts 后缀时，Rsbuild 会使用 jiti 来加载配置文件，提供 ESM 与 CommonJS\n的互操作性，模块解析的行为与 Node.js 原生行为存在一定差异。\n\n\n指定配置文件#\n\nRsbuild CLI 通过 --config 选项来指定配置文件，可以设置为相对路径或绝对路径。\n\n例如，你需要在执行 build 命令时使用 rsbuild.prod.config.mjs 文件，可以在 package.json 中添加如下配置：\n\n\n\n你也可以将 --config 选项缩写为 -c：\n\n\n\n\n使用环境变量#\n\n在配置文件中，你可以使用 process.env.NODE_ENV 等 Node.js 环境变量，来动态写入不同的配置：\n\n\n\n\n导出配置函数#\n\nRsbuild 支持在配置文件中导出一个函数，你可以在函数中动态计算配置，并返回给 Rsbuild。\n\n\n\nTIP\n\n导出的配置函数必须提供一个返回值，如果你不需要返回任何配置，可以 return 一个空对象。\n\n该函数接受以下入参：\n\n\nenv#\n\n * 类型： string\n * 默认值： process.env.NODE_ENV\n\n当前运行的环境。\n\n * 运行 rsbuild dev 时，env 的默认值为 development。\n * 运行 rsbuild build 或 rsbuild preview 时，env 的默认值为 production。\n\n\nenvMode#\n\n * 类型： string\n * 默认值： process.env.NODE_ENV\n\nCLI 参数 --env-mode 当前的值。\n\n比如，当运行 rsbuild build --env-mode test 时，envMode 的值为 test。\n\n\ncommand#\n\n * 类型： string\n\n当前运行的 CLI 命令，如 dev、build、preview。\n\n\n导出异步函数#\n\nRsbuild 也支持在配置文件中导出一个异步函数，你可以在函数中进行一些异步操作：\n\n\n\n\n合并配置#\n\n你可以使用 @rsbuild/core 导出的 mergeRsbuildConfig 函数来合并多个配置。\n\n\n\n\n调试配置#\n\n在执行构建时，你可以添加 DEBUG=rsbuild 环境变量来开启 Rsbuild 的调试模式。\n\n\n\n在调试模式下，Rsbuild 会将内部最终生成的 Rsbuild 配置写入到产物目录下，便于开发者查看和调试。\n\n\n\n打开生成的 /dist/.rsbuild/rsbuild.config.mjs 文件，即可查看 Rsbuild 配置的完整内容。\n\n关于调试模式的完整介绍，请查看 开启调试模式 章节。","routePath":"/zh/guide/basic/configure-rsbuild","lang":"zh","toc":[{"text":"配置结构","id":"配置结构","depth":2,"charIndex":123},{"text":"配置文件","id":"配置文件","depth":2,"charIndex":185},{"text":"指定配置文件","id":"指定配置文件","depth":2,"charIndex":715},{"text":"使用环境变量","id":"使用环境变量","depth":2,"charIndex":882},{"text":"导出配置函数","id":"导出配置函数","depth":2,"charIndex":956},{"text":"env","id":"env","depth":3,"charIndex":1085},{"text":"envMode","id":"envmode","depth":3,"charIndex":1252},{"text":"command","id":"command","depth":3,"charIndex":1390},{"text":"导出异步函数","id":"导出异步函数","depth":2,"charIndex":1451},{"text":"合并配置","id":"合并配置","depth":2,"charIndex":1507},{"text":"调试配置","id":"调试配置","depth":2,"charIndex":1572}],"domain":"","frontmatter":{},"version":""},{"id":305,"title":"配置 Rspack","content":"#\n\nRsbuild 支持直接修改 Rspack 配置对象，也支持通过 rspack-chain 来修改 Rsbuild 内置的 Rspack 配置。\n\nTIP\n\nRsbuild 内置的 Rspack 配置会随着迭代而发生变化，这些变化不会反映在 semver 中，因此在升级 Rsbuild 时，你的自定义配置可能会失效。\n\n\n查看 Rspack 配置#\n\nRsbuild 提供了 rsbuild inspect 命令来查看 Rsbuild 最终生成的 Rspack 配置。\n\n你也可以通过 调试模式 来查看。\n\n\n修改配置对象#\n\n你可以使用 Rsbuild 的 tools.rspack 选项来修改 Rspack 配置对象。\n\n比如注册 Rspack 插件或 webpack 插件：\n\n\n\n比如以函数的形式修改 Rspack 配置：\n\n\n\n> 请查看 tools.rspack 文档 来了解完整用法。\n\n\n使用 Rspack Chain#\n\n\ntools.bundlerChain#\n\nRsbuild 提供了 tools.bundlerChain 配置项来修改 rspack-chain。\n\ntools.bundlerChain 的值是一个函数，接收两个参数：\n\n * 第一个参数为 rspack-chain 实例，你可以通过 它来修改默认的 Rspack 配置。\n * 第二个参数为一个工具对象，包括 env、isProd、CHAIN_ID 等。\n\n下面是一个基本示例：\n\n\n\ntools.bundlerChain 还可以是一个异步函数：\n\n\n\n\n背景知识#\n\n在开始使用 rspack-chain 来修改 Rspack 配置之前，请先了解一些背景知识。\n\n关于 ID#\n\n简单来说，rspack-chain 要求使用者为每个 Rule、Loader、Plugin、Minimizer 都设置一个独一无二的 id，通过这个\nid，就可以便捷地从嵌套层级很深的对象中找到所需的对象。\n\nRsbuild 将内部定义的全部 id 都通过 CHAIN_ID 对象导出，因此你可以通过这些导出的 id，快速定位到你想要修改的 Loader 或\nPlugin，而不需要在 Rspack 配置对象里通过复杂的遍历寻找。\n\n比如通过 CHAIN_ID.PLUGIN.HTML 来删除内置的 HTML 插件：\n\n\n\nID 类型#\n\nCHAIN_ID 对象包含了多种 id，对应的含义如下：\n\nCHAIN_ID 字段               对应的配置                    描述\nCHAIN_ID.PLUGIN           plugins[i]               对应 Rspack 配置中的一个插件\nCHAIN_ID.RULE             module.rules[i]          对应 Rspack 配置中的一个 Rule\nCHAIN_ID.USE              module.rules[i].loader   对应 Rspack 配置中的一个 Loader\nCHAIN_ID.MINIMIZER        optimization.minimizer   对应 Rspack 配置中的一个压缩工具\nCHAIN_ID.RESOLVE_PLUGIN   resolve.plugins[i]       对应 Rspack 配置中的一个 Resolve 插件\n\n\n示例#\n\n配置 loader#\n\n下面是新增、修改和删除 Rspack loader 的示例。\n\n * 新增一个 loader 来处理 .md 文件：\n\n\n\n * 修改内置的 SWC loader 选项：\n\n\n\n * 删除内置的 SWC loader：\n\n\n\n * 在内置的 SWC loader 之后插入一个 loader，它会早于 SWC loader 执行：\n\n\n\n> 注意：Rspack 的 loader 是以相反顺序执行的。\n\n * 在内置的 SWC loader 之前插入一个 loader，它会晚于 SWC loader 执行：\n\n\n\n * 删除内置的 CSS 处理规则：\n\n\n\n配置 Plugin#\n\n下面是新增、修改和删除 Rspack 插件的示例。\n\n\n\n根据环境修改#\n\n在 tools.bundlerChain 函数的第二个参数中，你可以拿到各种环境的标识，如开发/生产模式构建、 SSR 构建、Web Worker\n构建，从而实现不同环境下的配置修改。\n\n\n\n以上是一些常见的配置示例，完整的 API 请见 rspack-chain 文档。\n\n\n配置修改顺序#\n\nRsbuild 支持通过 tools.rspack、tools.bundlerChain、modifyBundlerChain 等方式修改 Rspack\n配置对象。\n\n它们之间的执行顺序依次为：\n\n * modifyBundlerChain\n * tools.bundleChain\n * modifyRspackConfig\n * tools.rspack","routePath":"/zh/guide/basic/configure-rspack","lang":"zh","toc":[{"text":"查看 Rspack 配置","id":"查看-rspack-配置","depth":2,"charIndex":164},{"text":"修改配置对象","id":"修改配置对象","depth":2,"charIndex":258},{"text":"使用 Rspack Chain","id":"使用-rspack-chain","depth":2,"charIndex":405},{"text":"tools.bundlerChain","id":"toolsbundlerchain","depth":3,"charIndex":424},{"text":"背景知识","id":"背景知识","depth":3,"charIndex":677},{"text":"关于 ID","id":"关于-id","depth":4,"charIndex":732},{"text":"ID 类型","id":"id-类型","depth":4,"charIndex":1002},{"text":"示例","id":"示例","depth":3,"charIndex":1465},{"text":"配置 loader","id":"配置-loader","depth":4,"charIndex":1470},{"text":"配置 Plugin","id":"配置-plugin","depth":4,"charIndex":1762},{"text":"根据环境修改","id":"根据环境修改","depth":4,"charIndex":1803},{"text":"配置修改顺序","id":"配置修改顺序","depth":2,"charIndex":1951}],"domain":"","frontmatter":{},"version":""},{"id":306,"title":"配置 SWC","content":"#\n\nSWC（Speedy Web Compiler）是基于 Rust 语言编写的高性能 JavaScript 和 TypeScript 转译和压缩工具。SWC\n提供与 Babel 和 Terser 相似的能力，在单线程上它比 Babel 快 20 倍，在四核上它比 Babel 快 70 倍。\n\nRsbuild 默认启用 SWC 的以下功能：\n\n * 通过 Rspack 的 builtin:swc-loader 来转换 JavaScript 和 TypeScript 代码，它是 swc-loader 的\n   Rust 版本。\n * 通过 Rspack 的 SwcJsMinimizerRspackPlugin 来压缩 JavaScript 代码。\n\n\nLoader 选项#\n\nbuiltin:swc-loader 的选项与 JS 版本的 swc-loader 一致。Rsbuild 提供了 tools.swc 选项来配置\nbuiltin:swc-loader，下面是一些示例：\n\n\n注册 SWC 插件#\n\ntools.swc 可以用于注册 SWC 的 Wasm 插件，比如注册 @swc/plugin-styled-components：\n\n\n\n> 你可以通过 awesome-swc 仓库查看社区中可用的 SWC 插件。\n\n\nSWC 插件版本#\n\n请注意，SWC 的插件仍然是一个实验性功能，目前 SWC 的 Wasm 插件是不向后兼容的，SWC 插件的版本与 Rspack 依赖的 swc_core\n版本存在强耦合关系。\n\n这意味着，你需要选择和当前 swc_core 版本匹配的 SWC 插件，才能使它正常执行。如果你使用的 SWC 插件版本与 Rspack 依赖的\nswc_core 版本不匹配，Rspack 在执行构建时会抛出如下错误：\n\n\n\n如果你遇到了以上问题，通常可行的解决方法是将 Rsbuild 和 SWC 插件都升级到最新版本。\n\n此外，你也可以按照以下步骤来选择合适的 SWC 插件版本：\n\n 1. 查看当前使用的 Rspack 版本，你可以通过 调试模式 来查看。\n 2. 访问 plugins.swc.rs，选择你当前使用的 Rspack 版本。\n 3. 该网站会列出你当前使用的 Rspack 版本所匹配的 SWC 插件版本范围，选择匹配的 SWC 插件版本使用即可。\n\n如果你使用的 SWC 插件未收录到 plugins.swc.rs，可以通过 Rust 代码仓库中的 Cargo.toml 文件来查看 swc_core\n的版本信息。以 Rspack 仓库为例，你可以打开 Cargo.toml，搜索 swc_core 关键字来查看版本，然后参考 SWC - Selecting\nthe version 进行选择。\n\n\n启用 Emotion 支持#\n\n启用 builtin:swc-loader 对 Emotion 支持的示例：\n\n\n\n更多选项可参考 @swc/plugin-emotion。\n\n\n启用 Relay 支持#\n\n启用 builtin:swc-loader 对 Relay 支持的示例：\n\n\n\n更多选项可参考 @swc/plugin-relay。\n\n\nMinimizer 选项#\n\nRsbuild 提供了 output.minify.js 选项来配置 SwcJsMinimizerRspackPlugin，下面是一些示例：\n\n\n排除文件#\n\n通过 exclude 选项可以排除某些文件，不进行压缩：\n\n\n\n\n切换压缩工具#\n\n如果 SwcJsMinimizerRspackPlugin 无法满足你的需求，你可以通过 tools.bundlerChain 选项来切换到其他压缩工具。\n\n例如，切换到 Terser 来压缩 JavaScript 代码，它的性能不如 SWC，但功能更稳定：\n\n","routePath":"/zh/guide/basic/configure-swc","lang":"zh","toc":[{"text":"Loader 选项","id":"loader-选项","depth":2,"charIndex":329},{"text":"注册 SWC 插件","id":"注册-swc-插件","depth":3,"charIndex":444},{"text":"SWC 插件版本","id":"swc-插件版本","depth":3,"charIndex":567},{"text":"启用 Emotion 支持","id":"启用-emotion-支持","depth":3,"charIndex":1179},{"text":"启用 Relay 支持","id":"启用-relay-支持","depth":3,"charIndex":1268},{"text":"Minimizer 选项","id":"minimizer-选项","depth":2,"charIndex":1351},{"text":"排除文件","id":"排除文件","depth":3,"charIndex":1439},{"text":"切换压缩工具","id":"切换压缩工具","depth":2,"charIndex":1479}],"domain":"","frontmatter":{},"version":""},{"id":307,"title":"使用 CSS Modules","content":"#\n\nCSS Modules 让我们能以模块化的方式编写 CSS 代码，并且可以在 JavaScript 文件中导入和使用这些样式。使用 CSS Modules\n可以自动生成唯一的类名，隔离不同模块之间的样式，避免类名冲突。\n\nRsbuild 默认支持使用 CSS Modules，无需添加额外的配置。我们约定使用 [name].module.css 文件名来启用 CSS\nModules。\n\n以下样式文件会被视为 CSS Modules：\n\n * *.module.css\n * *.module.less\n * *.module.sass\n * *.module.scss\n * *.module.styl\n * *.module.stylus\n\n\n用法示例#\n\n * 编写样式：\n\n\n\n * 使用样式：\n\n\n\n\n具名导入#\n\n如果你倾向于在 CSS Modules 中使用具名导入，可以通过 output.cssModules.namedExport 配置项来开启。\n\n\n\n开启后，你可以通过具名导入来引用类名：\n\n\n\n\nCSS Modules 识别规则#\n\n在默认情况下，只有 *.module.css 结尾的文件才被视为 CSS Modules 模块。\n\n如果你想将其他 CSS 文件也当做 CSS Modules 模块进行处理，可以通过配置 output.cssModules.auto 来实现。\n\n比如：\n\n\n\n设置后，以下两个文件都会被视为 CSS Modules：\n\n\n\n\n自定义类名#\n\n自定义 CSS Modules 生成的类名也是我们比较常用的功能，你可以使用 output.cssModules.localIdentName 来进行配置。\n\n\n\n如果你需要自定义 CSS Modules 的其他配置，可以通过 output.cssModules 进行设置。\n\n\n类型声明#\n\n当你在 TypeScript 代码中引用 CSS Modules 时，TypeScript 可能会提示该模块缺少类型定义：\n\n\n\n此时你需要为 CSS Modules 添加类型声明文件，请在项目中创建 src/env.d.ts 文件，并添加相应的类型声明。\n\n * 方法一：如果项目里安装了 @rsbuild/core 包，你可以直接引用 @rsbuild/core 提供的 预设类型：\n\n\n\n * 方法二：手动添加需要的类型声明：\n\n\n\n * 方法三：如果你需要使用具名导入来引用类名，可以更松散的类型定义：\n\n\n\n添加类型声明后，如果依然存在类型错误，请尝试重启当前 IDE，或者调整 env.d.ts 所在的目录，使 TypeScript 能够正确识别类型定义。\n\n\n类型生成#\n\n上述方法虽然可以解决 CSS Modules 在 TypeScript 中的类型问题，但是无法准确地提示出 CSS Modules 导出了哪些类名。\n\nRsbuild 支持为 CSS Modules 生成准确的类型声明，你只需要开启\n@rsbuild/plugin-typed-css-modules，再执行构建命令，Rsbuild 就会为项目中所有的 CSS Modules\n文件生成类型声明文件。\n\n\n\n\n示例#\n\n例如，创建 src/index.ts 和 src/index.module.css 两个文件：\n\n\n\n\n\n构建后，Rsbuild 会自动生成 src/index.module.css.d.ts 类型声明文件：\n\n\n\n此时再打开 src/index.ts 文件，可以看到 styles 对象已经具备了准确的类型。","routePath":"/zh/guide/basic/css-modules","lang":"zh","toc":[{"text":"用法示例","id":"用法示例","depth":2,"charIndex":326},{"text":"具名导入","id":"具名导入","depth":2,"charIndex":358},{"text":"CSS Modules 识别规则","id":"css-modules-识别规则","depth":2,"charIndex":463},{"text":"自定义类名","id":"自定义类名","depth":2,"charIndex":645},{"text":"类型声明","id":"类型声明","depth":2,"charIndex":793},{"text":"类型生成","id":"类型生成","depth":2,"charIndex":1137},{"text":"示例","id":"示例","depth":3,"charIndex":1349}],"domain":"","frontmatter":{},"version":""},{"id":308,"title":"引用 CSS 文件","content":"#\n\nRsbuild 对 CSS 提供开箱即用的支持，包括 Lightning CSS、PostCSS、CSS Modules、CSS 预处理器、CSS 内联和\nCSS 压缩。\n\nRsbuild 也提供了多个配置项，允许自定义 CSS 文件的处理规则。\n\n\nLightning CSS#\n\nTIP\n\nLightning CSS 是一个基于 Rust 编写的高性能 CSS 解析、转译和压缩工具。它支持将许多现代的 CSS\n特性解析并转化为指定浏览器支持的语法，并提供更好的压缩比例。\n\nRsbuild 使用 Rspack 内置的 lightningcss-loader 来转换 CSS 代码，它会自动读取项目中的 browserslist\n配置，并将 CSS 代码转换为目标浏览器支持的语法。\n\n\n特性#\n\n * Lightning CSS 会自动添加浏览器前缀，比如 -webkit-、-moz-、-ms- 等，因此你不需要手动添加前缀，也不需要使用\n   autoprefixer 插件。\n * Lightning CSS 会自动将 CSS 语法降级，这允许你在代码中使用现代的 CSS 特性，比如 CSS nesting，custom media\n   queries 等，而无需担心浏览器兼容性问题。\n * 你可以使用 tools.lightningcssLoader 来自定义 lightningcss-loader 的选项。\n\n\n禁用 Lightning CSS#\n\n如果 Lightning CSS 无法满足你的需求，你也可以禁用 Lightning CSS，并使用 PostCSS 来转换 CSS 代码。\n\n步骤如下：\n\n 1. 将 tools.lightningcssLoader 设置为 false 来禁用 Lightning CSS loader。\n 2. 使用 @rsbuild/plugin-css-minimizer 来将 CSS 压缩工具从 Lightning CSS 切换到 cssnano 或其他\n    CSS 压缩器。\n\n\n\n 3. 参考 使用 PostCSS，配置你需要的 PostCSS 插件，下面是一些常用的 PostCSS 插件：\n\n * autoprefixer：添加浏览器前缀。\n * postcss-preset-env：将现代 CSS 语法转换为大多数浏览器支持的语法。\n * postcss-nesting：支持 CSS nesting。\n\n\nCSS 压缩#\n\n在生产模式构建时， Rsbuild 会开启 Rspack 内置的 LightningCssMinimizerRspackPlugin 插件，将 CSS\n资源压缩，以达到更好的传输效率。\n\n * 你可以通过 output.minify 选项来禁用 CSS 压缩，或是自定义 LightningCssMinimizerRspackPlugin 的选项。\n * 你可以通过 @rsbuild/plugin-css-minimizer 来自定义 CSS 压缩工具，切换到 cssnano 或是其他 CSS 压缩器。\n\n\n使用 PostCSS#\n\nRsbuild 支持通过 PostCSS 来转换 CSS 代码。你可以通过以下方式来配置 PostCSS：\n\n 1. Rsbuild 使用 postcss-load-config 来加载当前项目根目录下的 PostCSS 配置文件，比如\n    postcss.config.js：\n\n\n\n 2. 通过 Rsbuild 的 tools.postcss 选项来配置 postcss-loader，该选项支持通过函数来修改内置配置，比如：\n\n\n\n * 当你同时配置 postcss.config.js 文件和 tools.postcss 选项时，两者都会生效，并且 tools.postcss\n   的优先级更高。\n * 如果项目中没有 postcss.config.js 文件，也没有配置 tools.postcss 选项，Rsbuild 将不会注册\n   postcss-loader。\n\n\n使用 CSS Modules#\n\nRsbuild 默认支持 CSS Modules，请阅读 使用 CSS Modules 章节来了解 CSS Modules 的完整用法。\n\n\n使用 CSS 预处理器#\n\nRsbuild 通过插件来支持社区流行的 CSS 预处理器，包括 Sass、Less 和 Stylus，使用方式请参考：\n\n * Sass 插件\n * Less 插件\n * Stylus 插件\n\n\nCSS-in-JS#\n\n请阅读 React - CSS-in-JS 章节来了解如何在 Rsbuild 中使用常见的 CSS-in-JS 库。\n\n\n内联 CSS 文件#\n\n默认情况下，Rsbuild 会把 CSS 提取为独立的 .css 文件，并输出到构建产物目录。\n\n如果你希望将样式内联到 JS 文件中，可以将 output.injectStyles 设置为 true 来禁用 CSS 提取逻辑。当浏览器请求到 JS\n文件后，JS 将动态地向 HTML 插入","routePath":"/zh/guide/basic/css-usage","lang":"zh","toc":[{"text":"Lightning CSS","id":"lightning-css","depth":2,"charIndex":128},{"text":"特性","id":"特性","depth":3,"charIndex":348},{"text":"禁用 Lightning CSS","id":"禁用-lightning-css","depth":3,"charIndex":620},{"text":"CSS 压缩","id":"css-压缩","depth":2,"charIndex":1049},{"text":"使用 PostCSS","id":"使用-postcss","depth":2,"charIndex":1314},{"text":"使用 CSS Modules","id":"使用-css-modules","depth":2,"charIndex":1723},{"text":"使用 CSS 预处理器","id":"使用-css-预处理器","depth":2,"charIndex":1811},{"text":"CSS-in-JS","id":"css-in-js","depth":2,"charIndex":1924},{"text":"内联 CSS 文件","id":"内联-css-文件","depth":2,"charIndex":1997},{"text":"引用 node_modules 里的样式","id":"引用-node_modules-里的样式","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":309,"title":"配置 HTML 模板","content":"","routePath":"/zh/guide/basic/html-template","lang":"zh","toc":[{"text":"设置模板文件","id":"设置模板文件","depth":2,"charIndex":-1},{"text":"设置页面标题","id":"设置页面标题","depth":2,"charIndex":-1},{"text":"设置页面图标","id":"设置页面图标","depth":2,"charIndex":-1},{"text":"设置 meta 标签","id":"设置-meta-标签","depth":2,"charIndex":-1},{"text":"默认模板引擎","id":"默认模板引擎","depth":2,"charIndex":-1},{"text":"模板参数","id":"模板参数","depth":3,"charIndex":-1},{"text":"参数转义","id":"参数转义","depth":3,"charIndex":-1},{"text":"其他模板引擎","id":"其他模板引擎","depth":2,"charIndex":-1},{"text":"EJS","id":"ejs","depth":3,"charIndex":-1},{"text":"Pug","id":"pug","depth":3,"charIndex":-1},{"text":"注入标签","id":"注入标签","depth":2,"charIndex":-1},{"text":"HTML 插件","id":"html-插件","depth":2,"charIndex":-1},{"text":"HTML 压缩","id":"html-压缩","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":310,"title":"引用 JSON 文件","content":"#\n\nRsbuild 支持在代码中引用 JSON 文件，也支持引用 YAML 和 TOML 文件并将其转换为 JSON 格式。\n\n\nJSON 文件#\n\n你可以直接在 JavaScript 文件中引用 JSON 文件。\n\n\n示例#\n\n\n\n\n\n\n具名引用#\n\nRsbuild 同样支持通过 named import 来引用 JSON 文件：\n\n\n\n\nYAML 文件#\n\nYAML 是一种数据序列化语言，通常用于编写配置文件。\n\nRsbuild 提供了 @rsbuild/plugin-yaml，在注册插件后，你可以在 JavaScript 中引用 .yaml 或 .yml\n文件，它们会被自动转换为 JavaScript 对象。\n\n\n\n\n示例#\n\n\n\n\n\n\nTOML 文件#\n\nTOML 是一种语义明显、易于阅读的配置文件格式。\n\nRsbuild 提供了 @rsbuild/plugin-toml，在注册插件后，你可以在 JavaScript 中引用 .toml 文件，它会被自动转换为\nJavaScript 对象。\n\n\n\n\n示例#\n\n\n\n\n\n\n类型声明#\n\n当你在 TypeScript 代码中引用 YAML 或 TOML 文件时，请在项目中创建 src/env.d.ts 文件，并添加相应的类型声明。\n\n * 方法一：如果项目里安装了 @rsbuild/core 包，你可以直接引用 @rsbuild/core 提供的 预设类型：\n\n\n\n * 方法二：手动添加需要的类型声明：\n\n","routePath":"/zh/guide/basic/json-files","lang":"zh","toc":[{"text":"JSON 文件","id":"json-文件","depth":2,"charIndex":65},{"text":"示例","id":"示例","depth":3,"charIndex":110},{"text":"具名引用","id":"具名引用","depth":3,"charIndex":120},{"text":"YAML 文件","id":"yaml-文件","depth":2,"charIndex":172},{"text":"示例","id":"示例-1","depth":3,"charIndex":316},{"text":"TOML 文件","id":"toml-文件","depth":2,"charIndex":326},{"text":"示例","id":"示例-2","depth":3,"charIndex":460},{"text":"类型声明","id":"类型声明","depth":2,"charIndex":470}],"domain":"","frontmatter":{},"version":""},{"id":311,"title":"构建产物目录","content":"#\n\n本章节主要介绍构建产物的目录结构，以及如何控制不同类型产物的输出目录。\n\n如果你想要了解如何将 Rsbuild 的构建产物部署为静态站点，请参考 部署静态站点。\n\n\n默认产物目录#\n\n下面是最基础的产物目录结构，默认情况下，构建产物会生成在当前项目的 dist 目录下。\n\n\n\n最常见的产物是 HTML 文件、JS 文件和 CSS 文件：\n\n * HTML 文件：默认输出到 dist 目录的根部。\n * JS 文件：默认输出到 static/js 目录，\n * CSS 文件：默认输出到 static/css 目录。\n\n此外，JS 文件和 CSS 文件有时候会生成一些相关产物：\n\n * License 文件：包含开源许可证信息，默认输出到 JS 文件的同级目录，并添加 .LICENSE.txt 后缀。\n * Source Map 文件：包含保存源代码映射关系，默认输出到 JS 文件和 CSS 文件的同级目录，并添加 .map 后缀。\n\n在产物的文件名称中，[name] 表示这个文件对应的入口名称，比如 index, main。[hash] 则是基于该文件的内容生成的哈希值。\n\n\n开发模式产物#\n\n在开发模式下，Rsbuild 默认会将构建产物保存在 dev server 的内存中，而不是写入磁盘，这样可以减少 fs 操作产生的开销。你可以参考\n查看静态资源 查看当前构建生成的所有静态资源。\n\n你也可以选择将构建产物写入磁盘，这通常用于排查构建产物的内容，或是配置静态资源的代理规则。\n\n将 dev.writeToDisk 配置项设置为 true 即可：\n\n\n\n\n修改产物目录#\n\nRsbuild 提供了多个配置项来修改产物目录和产物名称，你可以：\n\n * 通过 output.filename 来修改产物的文件名。\n * 通过 output.distPath 来修改产物的输出路径。\n * 通过 output.legalComments 来修改 License 文件的生成方式。\n * 通过 output.sourceMap 来修改 Source Map 文件。\n * 通过 html.outputStructure 来修改 HTML 产物对应的文件夹结构。\n\n\n静态资源#\n\n当你在代码中引用图片、SVG、字体、媒体等类型的静态资源时，它们也会被输出到 dist/static 目录下，并根据静态资源类型来自动分配到对应的子目录：\n\n\n\n你可以通过 output.distPath 配置项将这些静态资源统一输入到单个目录下，比如输出到 assets 目录：\n\n\n\n上方的配置会生成以下目录结构：\n\n\n\n\nNode.js 产物目录#\n\n当 Rsbuild 的 output.target 是 'node' 时，Rsbuild 会在构建后生成 Node.js 产物：\n\n\n\nNode.js 产物通常只包含 JS 文件，不包含 HTML、CSS 等文件。此外，Node 产物的 JS 文件名称也不会自动生成哈希值。\n\n你可以通过 environments 配置项来修改 Node 产物的输出路径。\n\n比如，将 Node.js 产物输出到 dist/server 目录：\n\n\n\n\n扁平化产物目录#\n\n有时候你不想产物目录有太多层级，可以将目录设置为空字符串，使生成的产物目录扁平化。\n\n参考下方的例子：\n\n\n\n上方的配置会生成以下目录结构：\n\n","routePath":"/zh/guide/basic/output-files","lang":"zh","toc":[{"text":"默认产物目录","id":"默认产物目录","depth":2,"charIndex":85},{"text":"开发模式产物","id":"开发模式产物","depth":2,"charIndex":497},{"text":"修改产物目录","id":"修改产物目录","depth":2,"charIndex":691},{"text":"静态资源","id":"静态资源","depth":2,"charIndex":942},{"text":"Node.js 产物目录","id":"nodejs-产物目录","depth":2,"charIndex":1113},{"text":"扁平化产物目录","id":"扁平化产物目录","depth":2,"charIndex":1347}],"domain":"","frontmatter":{},"version":""},{"id":312,"title":"开发服务器","content":"#\n\nRsbuild 配备了一个内置的开发服务器，旨在提升开发体验。当你执行 rsbuild dev 或 rsbuild preview\n命令时，该服务器将启动，并提供页面预览、路由、模块热更新等功能。\n\n\n服务端基础路径#\n\n默认情况下，服务端的基础路径为 /，用户可通过 http://localhost:3000/ 访问到 index.html 等产物资源、以及 public\n目录下的资源。\n\nRsbuild 支持通过 server.base 修改服务端的基础路径。当我们希望通过 http://localhost:3000/foo/\n访问到这些资源时，可以添加如下配置：\n\n\n\n\n查看静态资源#\n\n启动 dev server 后，你可以访问 /rsbuild-dev-server 查看 Rsbuild 在当前构建中生成的所有静态资源。\n\n例如，在浏览器中打开 http://localhost:3000/rsbuild-dev-server，可以看到：\n\n\n页面路由#\n\nRsbuild 的 Server 提供一套默认的路由约定，并允许用户通过配置项定制。\n\n\n默认行为#\n\nRsbuild Server 会根据 server.base 和 source.entry 配置生成对应的页面路由。\n\n当 entry 为 index 时，可通过 / 访问页面；当 entry 为 foo 时，可通过 /foo 访问该页面。\n\n当 server.base 为 /base 时，可通过 /base 访问 index 页面，通过 /base/foo 访问 foo 页面。\n\n\n\n\nFallback 行为#\n\n当请求满足以下条件且未找到对应资源时，会被 server.htmlFallback 处理，默认会回退到 index.html。\n\n * 当前请求是 GET 或 HEAD 请求\n * 当前请求头接受 text/html (请求头 accept 类型为 text/html 或 */*)\n\n\n\n\n自定义 Fallback 行为#\n\n当 Rsbuild 默认的 server.htmlFallback 配置无法满足你的需求，例如，希望在访问 / 时可以访问 main.html，可通过\nserver.historyApiFallback 进行设置。\n\n\n\n\nHTML 输出路径#\n\n通常情况下，/ 指向 dist 产物根目录， 而 HTML 文件输出到 dist 根目录下，此时可通过 /some-path 访问对应的 HTML 页面。\n\n若通过修改 output.distPath.html 将 HTML 文件输出到其他子目录下，此时需通过 /[htmlPath]/some-path 访问对应的\nHTML 页面。\n\n例如，设置将 HTML 文件输出到 HTML 目录下，此时将通过 /html/ 访问到 index.html，通过 /html/foo 访问到\nfoo.html。\n\n\n\n\nRspack Dev Server#\n\nRspack CLI 内置的开发服务器是 @rspack/dev-server，Rsbuild 没有使用\n@rspack/dev-server，而是自行实现了一个更轻量的版本。\n\n\n对比#\n\nRsbuild 的开发服务器和 @rspack/dev-server 有以下区别：\n\n * 配置项：Rsbuild 提供了更丰富的 server 配置项。\n * 日志格式：Rspack CLI 日志格式与 Webpack CLI 基本一致，而 Rsbuild 的日志则更加清晰和易读。\n * 底层依赖：@rspack/dev-server 基于 express 实现，三方依赖较多。Rsbuild 则采用 connect 等更轻量的库实现。\n\n\n配置项#\n\nRsbuild 不支持使用 Rspack 的 devServer 配置项，你可以使用 Rsbuild 的 dev 和 server 配置代替。\n\n在 Rsbuild 里，dev 包含一些仅在开发阶段生效的配置，而 server 配置对开发服务器和 preview 服务器均能生效。\n\n以下是 Rspack CLI 的 devServer 配置对应的 Rsbuild 配置：\n\nRSPACK CLI                     RSBUILD\ndevServer.client               dev.client\ndevServer.compress             server.compress\ndevServer.headers              server.headers\ndevServer.historyApiFallback   server.historyApiFallback\ndevServer.host                 server.host\ndevServer.hot                  dev.hmr\ndevServer.liveReload           dev.liveReload\ndevServer.open                 server.open\ndevServer.port                 server.port\ndevServer.proxy                server.proxy\ndevServer.setupMiddlewares     dev.setupMiddlewares\ndevServer.static               server.publicDir\ndevServer.watchFiles           dev.watchFiles\n\n> 更多配置请参考 Config 总览。\n\n\n扩展中间件#\n\nRsbuild server 未使用任何 Node.js 框架，Rsbuild 中间件提供的 req 和 res 均为 Node.js 原生对象。\n这意味着，当你从其他服务端框架迁移时（如 Express），原本的中间件不一定能直接在 Rsbuild 中使用，例如，无法在 Rsbuild 中间件中访问\nExpress 所提供的 req.params、req.path、req.search、req.query 等属性。\n\n如果你需要在 Rsbuild 中使用原有的中间件，可以采取以下方式，将服务端应用作为中间件传入：\n\n\n\n\n自定义 Server#\n\n如果你希望将 Rsbuild dev server 集成到自定义的 server 中，可以通过 Rsbuild createDevServer 方法获取\nRsbuild dev server 的实例方法，进行按需调用。\n\n详情可参考 Rsbuild - createDevServer。","routePath":"/zh/guide/basic/server","lang":"zh","toc":[{"text":"服务端基础路径","id":"服务端基础路径","depth":2,"charIndex":103},{"text":"查看静态资源","id":"查看静态资源","depth":2,"charIndex":294},{"text":"页面路由","id":"页面路由","depth":2,"charIndex":434},{"text":"默认行为","id":"默认行为","depth":3,"charIndex":486},{"text":"Fallback 行为","id":"fallback-行为","depth":3,"charIndex":689},{"text":"自定义 Fallback 行为","id":"自定义-fallback-行为","depth":3,"charIndex":849},{"text":"HTML 输出路径","id":"html-输出路径","depth":3,"charIndex":979},{"text":"Rspack Dev Server","id":"rspack-dev-server","depth":2,"charIndex":1246},{"text":"对比","id":"对比","depth":3,"charIndex":1357},{"text":"配置项","id":"配置项","depth":3,"charIndex":1585},{"text":"扩展中间件","id":"扩展中间件","depth":2,"charIndex":2438},{"text":"自定义 Server","id":"自定义-server","depth":2,"charIndex":2711}],"domain":"","frontmatter":{},"version":""},{"id":313,"title":"引用静态资源","content":"#\n\nRsbuild 支持在代码中引用图片、字体、音频、视频等类型的静态资源。\n\n什么是静态资源\n\n静态资源是指 Web 应用中不会发生变化的文件。常见的静态资源包括图片、字体、视频、样式表和 JavaScript 文件。这些资源通常存储在服务器或 CDN\n上，当用户访问 Web 应用时会被传送到用户的浏览器。由于它们不会发生变化，静态资源可以被浏览器缓存，从而提高 Web 应用的性能。\n\n\n静态资源格式#\n\n以下是 Rsbuild 默认支持的静态资源格式：\n\n * 图片：png、jpg、jpeg、gif、svg、bmp、webp、ico、apng、avif、tif、tiff、jfif、pjpeg、pjp。\n * 字体：woff、woff2、eot、ttf、otf、ttc。\n * 音频：mp3、wav、flac、aac、m4a、opus。\n * 视频：mp4、webm、ogg、mov。\n\n如果你需要引用其他格式的静态资源，请参考 扩展静态资源类型。\n\nSVG 图片\n\nSVG 图片是一种特殊情况，Rsbuild 提供了 SVG 转 React 组件的能力，对 SVG 进行单独处理，详见 SVGR 插件。\n\n\n在 JS 文件中引用#\n\n在 JS 文件中，可以直接通过 import 的方式引用相对路径下的静态资源：\n\n\n\n也可以使用路径别名来引用：\n\n\n\n\nURL assets#\n\nRsbuild 支持使用 JavaScript 原生的 URL 和 import.meta.url 相配合，来引用静态资源。\n\n\n\n如果你使用 new URL() 引用 .js 或 .ts 文件，它们将被视为 URL assets，不会经过 Rsbuild 内置的 swc-loader\n处理。\n\n\n\n同理，当使用 new URL() 引用 .css 或 .scss 文件时，它们将被视为 URL assets，不会经过 Rsbuild 内置的 CSS\nloaders 处理。\n\n\n\n\n在 CSS 文件中引用#\n\n在 CSS 文件中，可以引用相对路径下的静态资源：\n\n\n\n也支持使用路径别名来引用：\n\n\n\n如果需要在 CSS 文件中引用绝对路径下的静态资源：\n\n\n\n默认情况下，Rsbuild 内置的 css-loader 会解析 url() 中的绝对路径并寻找指定的模块。如果你希望跳过绝对路径的解析，可以配置\ntools.cssLoader 来过滤指定的路径，被过滤的路径将被原样保留在代码中。\n\n\n\n\n引用结果#\n\n引用静态资源的结果取决于文件体积：\n\n * 当文件体积大于 4KiB 时，会返回一个 URL，同时文件会被输出到构建产物目录下。\n * 当文件体积小于 4KiB 时，会自动被内联为 Base64 格式。\n\n\n\n关于资源内联的更详细介绍，请参考 静态资源内联 章节。\n\n\n构建产物#\n\n当静态资源被引用后，会自动被输出到构建产物的目录下，你可以：\n\n * 通过 output.filename 来修改产物的文件名。\n * 通过 output.distPath 来修改产物的输出路径。\n\n请阅读 构建产物目录 来了解更多细节。\n\n\nURL 前缀#\n\n引用静态资源后返回的 URL 中会自动包含路径前缀：\n\n * 在开发模式下，通过 dev.assetPrefix 设置路径前缀。\n * 在生产模式下，通过 output.assetPrefix 设置路径前缀。\n\n比如将 output.assetPrefix 设置为 https://example.com：\n\n\n\n\npublic 目录#\n\n项目根目录下的 public 目录可以用于放置一些静态资源，这些资源不会被 Rsbuild 构建，并且可以直接通过 URL 引用。\n\n * 当你启动开发服务器时，这些资源会被托管在 server.base 根路径下（默认 /）。\n * 当你执行生产模式构建时，这些资源会被拷贝到 dist 目录。\n\n比如，你可以在 public 目录下放置 robots.txt、manifest.json 或 favicon.ico 等文件。\n\n\n引用方式#\n\n你可以通过 URL 来引用 public 目录下的文件。\n\n例如，在 HTML 模板中，./public/favicon.ico 文件可以被引用为 /favicon.ico，BASE_URL 对应服务端的基础路径。\n\n\n\n\n注意事项#\n\n下面是一些使用 public 目录的注意事项：\n\n * 通过 URL 引用 public 目录中的资源时，请使用绝对路径，而不是相对路径，以确保资源在部署后能够正确访问。\n\n\n\n * 请避免在源代码中 import public 目录下的文件，正确的方式是通过 URL 引用。你可以将源代码中 import 的静态资源放在\n   /src/assets 目录下。\n\n\n\n * 在生产模式构建过程中，public 目录中的文件将会被拷贝到构建产物目录（默认为 dist）下，请注意不要和产物文件出现名称冲突。当 public\n   下的文件和产物重名时，构建产物具有更高的优先级，会覆盖 public 下的同名文件。这个功能可以通过将\n   server.publicDir.copyOnBuild 设置为 false 来禁用。\n\n\n自定义行为#\n\nRsbuild 提供了 server.publicDir 选项，可以用于自定义 public 目录的名称和行为，也可以用于禁用 public 目录。\n\n\n\n\n类型声明#\n\n当你在 TypeScript 代码中引用静态资源时，TypeScript 可能会提示该模块缺少类型定义：\n\n\n\n此时你需要为静态资源添加类型声明文件，请在项目中创建 src/env.d.ts 文件，并添加相应的类型声明。\n\n * 方法一：如果项目里安装了 @rsbuild/core 包，你可以直接引用 @rsbuild/core 提供的 预设类型：\n\n\n\n * 方法二：手动添加需要的类型声明：\n\n\n\n添加类型声明后，如果依然存在上述错误提示，请尝试重启当前 IDE，或者调整 env.d.ts 所在的目录，使 TypeScript 能够正确识别类型定义。\n\n\n扩展静态资源类型#\n\n如果 Rsbuild 内置的静态资源类型不能满足你的需求，可以通过以下方式扩展额外的静态资源类型。\n\n\n使用 source.assetsInclude#\n\n通过 source.assetsInclude 配置项，你可以指定需要被视为静态资源的额外文件类型。\n\n\n\n添加以上配置后，你就可以在代码里引用 *.pdf 文件了，比如：\n\n\n\n\n使用 tools.rspack#\n\n可以通过 tools.rspack 来修改内置的 Rspack 配置，并添加自定义的静态资源处理规则。\n\n比如，把 *.pdf 文件当做静态资源输出到产物目录，可以添加以下配置：\n\n\n\n关于 asset modules 的更多介绍，请参考 Rspack - Asset modules。\n\n\n相关配置#\n\n扩展的静态资源类型会受到以下配置项的影响：\n\n * output.filename.assets：设置扩展的静态资源的名称。\n * output.distPath.assets：设置扩展的静态资源的输出目录。\n * output.dataUriLimit.assets：设置扩展的静态资源内联的体积阈值。\n\n\n自定义规则#\n\n在某些场景下，你可能需要跳过 Rsbuild 内置的静态资源处理规则，并添加一些自定义规则。\n\n以 PNG 图片为例，你需要：\n\n 1. 通过 tools.bundlerChain 来修改内置的 Rspack 配置，通过 exclude 排除 .png 文件。\n 2. 通过 tools.rspack 来添加自定义的静态资源处理规则。\n\n\n\n\n图片格式#\n\n在使用图片资源时，你可以根据下方表格中图片的优缺点以及适用场景，来选择合适的图片格式。\n\n格式     优点                                      缺点                    适用场景\nPNG    无损压缩，不会丢失图片细节，不失真，支持半透明                 不适合色表复杂的图片            适合颜色数量少，边界层次分明的图片，适合用在 logo、icon、透明图等场景\nJPG    颜色丰富                                    有损压缩，会导致图片失真，不支持透明度   适合颜色数量多，颜色带有渐变、过度复杂的图片，适合用在人像照片、风景图等场景\nWebP   同时支持有损压缩与无损压缩，支持透明度，体积比 PNG 和 JPG 小很多   iOS 兼容性不好             几乎任何场景的像素图片，支持 WebP 的宿主环境，都应该首选 WebP 图片格式\nSVG    无损格式，不失真,支持透明度                          不适合复杂图形               适合矢量图,适合用于 icon","routePath":"/zh/guide/basic/static-assets","lang":"zh","toc":[{"text":"静态资源格式","id":"静态资源格式","depth":2,"charIndex":197},{"text":"在 JS 文件中引用","id":"在-js-文件中引用","depth":2,"charIndex":510},{"text":"URL assets","id":"url-assets","depth":3,"charIndex":584},{"text":"在 CSS 文件中引用","id":"在-css-文件中引用","depth":2,"charIndex":840},{"text":"引用结果","id":"引用结果","depth":2,"charIndex":1051},{"text":"构建产物","id":"构建产物","depth":2,"charIndex":1193},{"text":"URL 前缀","id":"url-前缀","depth":2,"charIndex":1322},{"text":"public 目录","id":"public-目录","depth":2,"charIndex":1489},{"text":"引用方式","id":"引用方式","depth":3,"charIndex":1718},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":1837},{"text":"自定义行为","id":"自定义行为","depth":3,"charIndex":2210},{"text":"类型声明","id":"类型声明","depth":2,"charIndex":2297},{"text":"扩展静态资源类型","id":"扩展静态资源类型","depth":2,"charIndex":2586},{"text":"使用 `source.assetsInclude`","id":"使用-sourceassetsinclude","depth":3,"charIndex":-1},{"text":"使用 `tools.rspack`","id":"使用-toolsrspack","depth":3,"charIndex":-1},{"text":"相关配置","id":"相关配置","depth":3,"charIndex":2930},{"text":"自定义规则","id":"自定义规则","depth":2,"charIndex":3092},{"text":"图片格式","id":"图片格式","depth":2,"charIndex":3272}],"domain":"","frontmatter":{},"version":""},{"id":314,"title":"部署静态站点","content":"#\n\n本章节介绍如何将 Rsbuild 的构建产物部署为静态站点。\n\n\n背景信息#\n\n在开始进行部署前，你需要了解一些背景信息：\n\n * 用于构建和预览产物的 CLI 命令。\n * 构建产物的目录结构。\n * 静态资源的 URL 前缀。\n\n\n构建命令#\n\nRsbuild 提供的构建命令：\n\n * build 命令，用于生成部署到生产环境的构建产物；\n * preview 命令，用于在本地预览生产构建的产物, 注意你需要提前执行 rsbuild build 命令构建出对应产物。\n\n\n\nTIP\n\npreview 命令仅用于本地预览，请勿将它用于生产服务器，因为它不是为此而设计的。\n\n\n产物目录#\n\nRsbuild 的构建产物通常包含 HTML、JS、CSS 等文件，默认输出到 dist 目录下，dist 目录的名称和结构可以通过一些配置项来修改，请参考\n构建产物目录 章节来了解更多。\n\n\n\n\n静态资源前缀#\n\n我们可以把构建产物分为两部分：HTML 文件和静态资源。\n\n * HTML 文件指的是产物目录中 .html 后缀的文件，它们通常需要被部署到服务器上。\n * 静态资源位于产物目录中的 static 目录，里面包含了 JavaScript、CSS、图片等资源，它们可以被部署到服务器或者 CDN 上。\n\n如果静态资源被部署到了服务器的某个子目录下，你可以将 output.assetPrefix 配置为一个 base 路径：\n\n\n\n你想要将静态资源放到 CDN 上，以保证更好的访问性能，而不是像 HTML 一样直接放到服务器上，那么你就需要将 output.assetPrefix 配置为\nCDN 地址，使应用能够正确的引用到这些静态资源：\n\n\n\n这样，在 HTML 中引用静态资源的时候，就会自动加上指定的前缀，例如：\n\n\n\n\nGitHub Pages#\n\nGitHub Pages 是一个静态站点托管服务，可以直接从 GitHub 上的存储库获取 HTML、CSS 和 JavaScript 文件。\n\n下面是部署到 GitHub Pages 的步骤示例。\n\n 1. 通过 output.assetPrefix 设置静态资源的 URL 前缀。\n\n\n\n 2. 打开 GitHub 仓库的 \"Settings\" 页面，点击左侧菜单的 \"Pages\" 选项，进入 GitHub Pages 的配置页面。\n 3. 选择 \"Source\" -> \"GitHub Actions\"，点击 \"create your own\" 来创建 GitHub Action 配置文件。\n 4. 将以下内容粘贴到输入框，将文件命名为 github-pages.yml（你可以根据需要来调整文件的内容和名称）。\n\n\n\n 5. 提交，等待 GitHub Actions 执行，执行完成后，你可以访问 https://.github.io// 来查看部署后的页面。\n\n\nNetlify#\n\nNetlify Core 是一个针对开发者的前端云解决方案，使用现代、可组合的工具构建和部署具有未来兼容性的数字解决方案。\n\n\n新增站点#\n\nNetlify 提供了详细的指南，你可以按照 Netlify - Add new site 操作，配置一些基础信息，就可以开始部署了。\n\n你需要配置以下两个字段：\n\n * Build command：构建命令，填写项目的 build 命令即可，通常是 npm run build。\n * Publish directory：产物目录，填写项目中的产物目录，默认是 dist。\n\n然后点击 Deploy site 按钮，就可以开始部署了。\n\n\n配置域名#\n\n如果你想要使你的站点可以通过你自己的域名访问，那么你可以在 Netlify 的 \"Domain management\" 栏目中进行配置。\n\n> 详细指南：Netlify - Custom domains。\n\n\nVercel#\n\nVercel 是一个为开发者提供的平台，它提供了构建和快速部署网络应用所需的工具、工作流程和基础设施，无需额外的配置。\n\n\n新增站点#\n\nVercel 提供了详细的指南，你可以按照 Vercel - Projects 操作，在 dashboard\n中创建一个项目，配置一些基础信息，就可以开始部署了。\n\n你只需要配置 \"Build and Output Settings\" 下的字段：\n\n * Output directory：产物目录，填写项目中的产物目录，默认是 dist。\n\n然后点击 Deploy 按钮，就可以开始部署了。\n\n\n配置域名#\n\n如果你想要使你的站点可以通过你自己的域名访问，那么你可以在 Vercel 的 \"Domains\" 栏目中进行配置。\n\n> 详细指南：Vercel - Domains。\n\n\nCloudflare Pages#\n\nCloudflare Pages 是一个由 Cloudflare 提供的静态网站托管平台。\n\n你可以按照 Cloudflare Pages - Git integration guide 操作，通过 Git 集成，将你的站点部署到 Cloudflare\nPages。\n\n在进行配置时，你需要填写 \"Build settings\" 中的以下字段：\n\n * Build command：构建命令，填写项目的 build 命令即可，通常是 npm run build。\n * Build output directory：产物目录，填写项目中的产物目录，默认是 dist。\n\n然后点击 Save and Deploy 按钮，就可以开始部署了。","routePath":"/zh/guide/basic/static-deploy","lang":"zh","toc":[{"text":"背景信息","id":"背景信息","depth":2,"charIndex":35},{"text":"构建命令","id":"构建命令","depth":3,"charIndex":120},{"text":"产物目录","id":"产物目录","depth":3,"charIndex":293},{"text":"静态资源前缀","id":"静态资源前缀","depth":3,"charIndex":399},{"text":"GitHub Pages","id":"github-pages","depth":2,"charIndex":774},{"text":"Netlify","id":"netlify","depth":2,"charIndex":1228},{"text":"新增站点","id":"新增站点","depth":3,"charIndex":1302},{"text":"配置域名","id":"配置域名","depth":3,"charIndex":1530},{"text":"Vercel","id":"vercel","depth":2,"charIndex":1642},{"text":"新增站点","id":"新增站点-1","depth":3,"charIndex":1713},{"text":"配置域名","id":"配置域名-1","depth":3,"charIndex":1919},{"text":"Cloudflare Pages","id":"cloudflare-pages","depth":2,"charIndex":2012}],"domain":"","frontmatter":{},"version":""},{"id":315,"title":"使用 Tailwind CSS","content":"#\n\nTailwind CSS 是一个以 Utility Class 为基础的 CSS 框架和设计系统，可以快速地为组件添加常用样式，同时支持主题样式的灵活扩展。\n\n你可以通过 PostCSS 插件来在 Rsbuild 中接入 Tailwind CSS。\n\n\n安装 Tailwind CSS#\n\n由于 Rsbuild 内置支持了 postcss 和 autoprefixer，你只需要安装 tailwindcss，无须安装其他 npm 包：\n\n\n配置 PostCSS#\n\n你可以通过 postcss.config.cjs 或 tools.postcss 来注册 tailwindcss 的 PostCSS 插件。\n\n\n\nTIP\n\nRsbuild 内置了 autoprefixer，因此你只需要注册 tailwindcss 插件。\n\n\n配置 Tailwind CSS#\n\n在当前项目的根目录创建 tailwind.config.js 文件，并添加以下内容：\n\n\n\nTIP\n\n上述配置仅供参考，你可以根据项目需要进行调整，比如非 TypeScript 项目不需要包含 ts 和 tsx 文件。\n\n需要注意的是，content 选项应包含所有用到 Tailwind 类名的源文件的路径。详情可参考 tailwindcss - Content 配置。\n\n\n\n\n其他配置方式#\n\n * 你可以在 postcss.config.cjs 中直接传入 Tailwind CSS 的配置：\n\n\n\n * 也可以通过 tools.postcss 来设置 Tailwind CSS 的配置：\n\n\n\n但我们建议将 Tailwind CSS 的配置放在 tailwind.config.* 中，因为其他方式可能会导致 Tailwind CSS\n的构建性能劣化，参考 tailwindcss/issues/14229。\n\n\n引入 CSS#\n\n在 CSS 入口文件中添加 @tailwind 指令：\n\n\n\n根据需求不同，你可以选择性地导入 Tailwind CSS 提供的 CSS 样式。请参考 @tailwind 文档 来了解 @tailwind 指令的详细用法。\n\n\n完成#\n\n你已经完成了在 Rsbuild 中接入 Tailwind CSS 的全部步骤！\n\n你可以在任意组件或 HTML 中使用 Tailwind 的 utility classes，比如：\n\n\n\n更多用法请参考 Tailwind CSS 文档。\n\n\nVS Code 插件#\n\nTailwind CSS 提供了 Tailwind CSS IntelliSense 插件，用于在 VS Code 中自动补全 Tailwind CSS 的\nclass names、CSS functions 和 directives。\n\n你可以在 VS Code 中安装该插件，即可开启自动补全功能。\n\n\n构建性能#\n\n在使用 Tailwind CSS 时，如果没有正确地配置 tailwind.config.js 中的 content\n字段，可能会导致构建性能和热更新性能下降。这是因为 Tailwind CSS 内部会基于 content 定义的 glob\n来匹配文件，扫描的文件数量越多，产生的性能开销越大。\n\n因此，我们建议精确地指定需要扫描的路径，以避免不必要的性能开销。例如，仅包括项目源码中实际包含 Tailwind 类名的 HTML 或 JS\n文件，避免包含不相关的文件或目录，尤其是 node_modules 目录。\n\n下面是一个扫描 node_modules 的错误示例：\n\n\n\n\n优化样式体积#\n\n如果你需要优化 Tailwind CSS 的样式体积，欢迎尝试 rsbuild-plugin-tailwindcss。\n\n该插件读取了 Rspack 的模块图信息，自动设置准确的 content 配置，以生成尽可能少的 Tailwind CSS 样式。\n\n\n\n> 参考 rsbuild-plugin-tailwindcss 了解更多。","routePath":"/zh/guide/basic/tailwindcss","lang":"zh","toc":[{"text":"安装 Tailwind CSS","id":"安装-tailwind-css","depth":2,"charIndex":129},{"text":"配置 PostCSS","id":"配置-postcss","depth":2,"charIndex":222},{"text":"配置 Tailwind CSS","id":"配置-tailwind-css","depth":2,"charIndex":366},{"text":"其他配置方式","id":"其他配置方式","depth":3,"charIndex":575},{"text":"引入 CSS","id":"引入-css","depth":2,"charIndex":796},{"text":"完成","id":"完成","depth":2,"charIndex":919},{"text":"VS Code 插件","id":"vs-code-插件","depth":2,"charIndex":1045},{"text":"构建性能","id":"构建性能","depth":2,"charIndex":1212},{"text":"优化样式体积","id":"优化样式体积","depth":2,"charIndex":1510}],"domain":"","frontmatter":{},"version":""},{"id":316,"title":"使用 TypeScript","content":"#\n\nRsbuild 默认支持 TypeScript，你可以直接在项目中使用 .ts 和 .tsx 文件。\n\n\nTypeScript 转译#\n\nRsbuild 默认使用 SWC 来转译 TypeScript 代码，也支持切换到 Babel 进行转译。\n\n\nisolatedModules#\n\n与 TypeScript 原生编译器不同，像 SWC 和 Babel 这样的工具会将每个文件单独编译，它无法确定导入的名称是一个类型还是一个值。因此，当你在\nRsbuild 中使用 TypeScript 时，需要启用 tsconfig.json 中的 isolatedModules 选项：\n\n\n\n该选项可以帮助你避免使用一些 SWC 和 Babel 无法正确编译的写法，比如跨文件的类型引用问题，它会引导你更正对应的用法：\n\n\n\n> 参考 SWC - Migrating from tsc 了解更多 SWC 和 tsc 的差异。\n\n\n预设类型#\n\n@rsbuild/core 提供了一些预设的类型定义，包含 CSS Modules、静态资源、import.meta 等类型。\n\n你可以创建一个 src/env.d.ts 文件来引用：\n\n\n\n\n类型检查#\n\n在进行 TypeScript 转译时，SWC 和 Babel 等工具不会执行类型检查。\n\nRsbuild 提供了 Type Check 插件，用于在单独的进程中运行 TypeScript 类型检查，插件内部集成了\nts-checker-rspack-plugin。\n\n请参考 @rsbuild/plugin-type-check 了解用法。\n\n\ntsconfig.json 路径#\n\nRsbuild 默认读取根目录的 tsconfig.json 文件，你可以使用 source.tsconfigPath 配置自定义的 tsconfig.json\n文件路径。\n\n\n\n\n路径后缀#\n\n当在一个 TypeScript 模块中导入另一个模块时，TypeScript 允许使用 .js 文件扩展名：\n\n\n\nRsbuild 通过 Rspack 的 extensionAlias 配置来支持该特性。在 TypeScript 项目中，Rsbuild 默认会添加以下配置：\n\n\n\n这意味着：\n\n * 允许使用 .js 文件扩展名导入 .ts 或 .tsx 文件。\n * 允许使用 .jsx 文件扩展名导入 .tsx 文件。","routePath":"/zh/guide/basic/typescript","lang":"zh","toc":[{"text":"TypeScript 转译","id":"typescript-转译","depth":2,"charIndex":55},{"text":"isolatedModules","id":"isolatedmodules","depth":3,"charIndex":127},{"text":"预设类型","id":"预设类型","depth":2,"charIndex":413},{"text":"类型检查","id":"类型检查","depth":2,"charIndex":517},{"text":"tsconfig.json 路径","id":"tsconfigjson-路径","depth":2,"charIndex":697},{"text":"路径后缀","id":"路径后缀","depth":2,"charIndex":807}],"domain":"","frontmatter":{},"version":""},{"id":317,"title":"使用 UnoCSS","content":"#\n\nUnoCSS 是一个灵活可扩展的原子化的 CSS 引擎，所有 CSS 工具类都是通过 preset 提供的。\n\n你可以通过 PostCSS 插件来在 Rsbuild 中接入 UnoCSS。\n\n\n安装 UnoCSS#\n\n首先，你需要安装 unocss 和 @unocss/postcss。\n\n\n配置 PostCSS#\n\n你可以通过 postcss.config.mjs 或 tools.postcss 来注册 unocss 的 PostCSS 插件。\n\n\n\n\n配置 UnoCSS#\n\n在当前项目的根目录创建 uno.config.ts 文件，并添加以下内容：\n\n\n\nTIP\n\n上述配置仅供参考，你可以根据项目需要进行调整。\n\n\n引入 CSS#\n\n在 CSS 入口文件中添加 @unocss 指令：\n\n\n\n根据需求不同，你可以选择性地导入 UnoCSS 提供的 CSS 样式。请参考 UnoCSS 文档 来了解 @unocss 指令的详细用法。\n\n\n完成#\n\n你已经完成了在 Rsbuild 中接入 UnoCSS 的全部步骤！\n\n你可以在任意组件或 HTML 中使用 UnoCSS 的 utility classes，比如：\n\n\n\n更多用法请参考 UnoCSS 文档。\n\n\nVS Code 插件#\n\nUnoCSS 提供了 VS Code 插件，用于在 VS Code 中提示 UnoCSS 的 utilities classes。\n\n你可以在 VS Code 中安装该插件，即可开启更多智能化功能。","routePath":"/zh/guide/basic/unocss","lang":"zh","toc":[{"text":"安装 UnoCSS","id":"安装-unocss","depth":2,"charIndex":99},{"text":"配置 PostCSS","id":"配置-postcss","depth":2,"charIndex":148},{"text":"配置 UnoCSS","id":"配置-unocss","depth":2,"charIndex":231},{"text":"引入 CSS","id":"引入-css","depth":2,"charIndex":315},{"text":"完成","id":"完成","depth":2,"charIndex":425},{"text":"VS Code 插件","id":"vs-code-插件","depth":2,"charIndex":537}],"domain":"","frontmatter":{},"version":""},{"id":318,"title":"升级 Rsbuild","content":"#\n\n本章节介绍如何升级项目中的 Rsbuild 依赖到最新版本。\n\n> 请参考 版本发布 来了解 Rsbuild 的版本发布策略。\n\n\n使用 Taze#\n\n我们推荐使用 Taze 来升级 Rsbuild 的版本，这是一个用于升级 npm 依赖版本的 CLI 工具。\n\n\n用法#\n\n运行以下命令来升级所有名称中包含 rsbuild 的依赖：\n\n\n\n运行结果类似于：\n\n\n\n你也可以调整 include 来匹配不同的包，比如仅升级 @rsbuild scope 下的包：\n\n\n\n\n选项#\n\n下面是一些使用 taze 选项的示例。\n\n * 在 monorepo 中，你可以添加 -r 选项来递归升级：\n\n\n\n * 添加 -l 来升级被锁定的版本：\n\n\n\n * 升级 major 版本：\n\n\n\n> 更多选项请参考 taze 文档。","routePath":"/zh/guide/basic/upgrade-rsbuild","lang":"zh","toc":[{"text":"使用 Taze","id":"使用-taze","depth":2,"charIndex":68},{"text":"用法","id":"用法","depth":3,"charIndex":135},{"text":"选项","id":"选项","depth":3,"charIndex":238}],"domain":"","frontmatter":{},"version":""},{"id":319,"title":"引用 Wasm 资源","content":"#\n\nRsbuild 支持在代码引用 WebAssembly 资源。\n\n什么是 WebAssembly\n\nWebAssembly（缩写为 wasm）是一种可移植、高性能的字节码格式，被设计用来在现代 Web 浏览器中执行 CPU 密集型计算任务，为 Web\n平台带来了接近本地编译代码的性能和可靠性。\n\n\n引用方式#\n\n你可以直接在 JavaScript 文件中引用一个 WebAssembly 模块：\n\n\n\n也可以通过 dynamic import 来引用 WebAssembly 模块：\n\n\n\n还可以通过 new URL 语法来获取 WebAssembly 模块的路径：\n\n\n\n\n输出目录#\n\n当 .wasm 资源被引用后，默认会被 Rsbuild 输出到 dist/static/wasm 目录下。\n\n你可以通过 output.distPath 配置项来修改 .wasm 产物的输出目录。\n\n\n\n\n类型声明#\n\n当你在 TypeScript 代码中引用 Wasm 文件时，通常需要添加相应的类型声明。\n\n比如 add.wasm 文件导出了 add() 方法，那么你可以在同级目录下创建一个 add.wasm.d.ts 文件，并添加相应的类型声明：\n\n","routePath":"/zh/guide/basic/wasm-assets","lang":"zh","toc":[{"text":"引用方式","id":"引用方式","depth":2,"charIndex":152},{"text":"输出目录","id":"输出目录","depth":2,"charIndex":291},{"text":"类型声明","id":"类型声明","depth":2,"charIndex":401}],"domain":"","frontmatter":{},"version":""},{"id":320,"title":"使用 Web Workers","content":"#\n\n本文将介绍在 Rsbuild 项目中如何配置和使用 Web Workers。\n\nWeb Workers\n\nWeb Workers 是一种 JavaScript API，它允许网页在后台线程中执行脚本，与主线程（网页）分离。这意味着，您可以使用 Web Workers\n来执行计算密集型或长时间运行的任务，而无需阻塞主线程，进而影响网页的性能。\n\n\n使用 Web Workers#\n\n\n使用 Worker 构造器#\n\nWeb Workers 是 Rspack 的一等公民，这意味着你不需要任何的 Loader 就可以直接在 Rspack / Rsbuild 项目中使用 Web\nWorkers。详情可参考 Rspack - Web Workers。\n\n例如，创建一个名为 worker.js 的文件：\n\n\n\n然后在主线程中使用这个 worker：\n\n\n\n\n使用 worker-loader#\n\n> worker-loader 已不再维护，推荐使用 new Worker() 语法。\n\n如果你的项目已经在使用 worker-loader，或者希望使用 worker-loader 内的 inline 等配置能力，在 Rsbuild /\nRspack 项目中可以使用 worker-loader 的替代方案 worker-rspack-loader。\n\n\n\n\n从远程 URL 加载脚本（跨域）#\n\n默认情况下，worker 脚本会输出成一个独立的 chunk。worker 脚本支持上传到 CDN，但在加载远程脚本时需要遵守同源策略。\n\n如果你希望你的 worker 脚本可以跨域访问，常见解法是通过 importScripts (不受 CORS 约束) 加载，可参考如下代码：\n\n\n\n关于跨域问题的详细讨论可参考 Discussions - webpack 5 web worker support for CORS?\n\n\n构建 Web Workers 产物#\n\nRsbuild 支持独立构建 Web Workers 产物，这在你需要将 Web Workers 产物提供给其他应用使用时很有帮助。\n\n将 Rsbuild 的 output.target 配置项设置为 'web-worker'，即可生成运行在 Worker 线程的构建产物。\n\n","routePath":"/zh/guide/basic/web-workers","lang":"zh","toc":[{"text":"使用 Web Workers","id":"使用-web-workers-1","depth":2,"charIndex":-1},{"text":"使用 Worker 构造器","id":"使用-worker-构造器","depth":3,"charIndex":194},{"text":"使用 worker-loader","id":"使用-worker-loader","depth":3,"charIndex":379},{"text":"从远程 URL 加载脚本（跨域）","id":"从远程-url-加载脚本跨域","depth":3,"charIndex":579},{"text":"构建 Web Workers 产物","id":"构建-web-workers-产物","depth":2,"charIndex":812}],"domain":"","frontmatter":{},"version":""},{"id":321,"title":"构建性能分析","content":"#\n\n进行构建性能分析可以帮助你确定项目中的性能瓶颈，从而采取针对性的优化。\n\n\n使用 Rsdoctor#\n\nRsdoctor 是一个构建分析工具，能够可视化地展示各个 loaders 和 plugins 的编译耗时。\n\n请参考 使用 Rsdoctor 了解更多。\n\n\nNode.js Profiling#\n\n当 Rsbuild 执行一次构建时，会包含 JavaScript 和 Rust 两侧的代码运行开销，以及 JavaScript 和 Rust\n之间的数据通信开销。\n\n通常而言，JavaScript 侧的性能开销会大于 Rust 侧，你可以使用 Node.js 的 profiling 来分析 JS 侧的开销，这有助于发现 JS\n侧的性能瓶颈。\n\n例如，进行 CPU profiling 分析，在项目根目录执行以下命令：\n\n\n\n以上命令执行后会生成一个 *.cpuprofile 文件，我们可以使用 speedscope 来可视化查看该文件：\n\n\n\n\nRspack Profiling#\n\nRsbuild 支持使用 RSPACK_PROFILE 环境变量来对 Rspack 进行构建性能分析。\n\n\n\n执行该命令后，会在产物目录下生成一个 rspack-profile-${timestamp} 文件夹，该文件夹下会包含\nlogging.json、trace.json 和 jscpuprofile.json 三个文件：\n\n * trace.json：使用 tracing 细粒度地记录了 Rust 侧各个阶段的耗时，可以使用 ui.perfetto.dev 进行查看。\n * jscpuprofile.json：使用 Node.js inspector 细粒度地记录了 JavaScript 侧的各个阶段的耗时，可以使用\n   speedscope.app 进行查看。\n * logging.json：包含一些日志信息，粗粒度地记录了构建的各个阶段耗时（开发模式下暂不支持）。\n\n> 更多 Rspack 构建性能分析用法，可参考 Rspack - Profiling。","routePath":"/zh/guide/debug/build-profiling","lang":"zh","toc":[{"text":"使用 Rsdoctor","id":"使用-rsdoctor","depth":2,"charIndex":40},{"text":"Node.js Profiling","id":"nodejs-profiling","depth":2,"charIndex":134},{"text":"Rspack Profiling","id":"rspack-profiling","depth":2,"charIndex":429}],"domain":"","frontmatter":{},"version":""},{"id":322,"title":"开启调试模式","content":"#\n\n为了便于排查问题，Rsbuild 提供了调试模式，你可以在执行构建时添加 DEBUG=rsbuild 环境变量来开启 Rsbuild 的调试模式。\n\n\n\n在调试模式下，Rsbuild 会输出一些额外的日志信息，并将内部最终生成的 Rsbuild 配置和 Rspack 配置写入到产物目录下，便于开发者查看和调试。\n\n\n日志信息#\n\n在调试模式下，你会看到 terminal 中输出了一些以 rsbuild 开头的日志，包括 Rsbuild 内部执行的操作、当前使用的 Rspack 版本等。\n\n\n\n此外，terminal 中还会输出以下日志，表示 Rsbuild 将内部生成的构建配置写入到磁盘中，此时你可以打开这些配置文件来查看相应的内容。\n\n\n\n\nRsbuild 配置文件#\n\n在调试模式下，Rsbuild 会自动生成 dist/.rsbuild/rsbuild.config.mjs 文件，这里面包含了最终生成的 Rsbuild\n配置。在这个文件里，你可以了解到你传入的 Rsbuild 配置在经过框架层和 Rsbuild 处理后的最终结果。\n\n该文件的大致结构如下：\n\n\n\n关于 Rsbuild 配置项的完整介绍，请查看 配置 Rsbuild 章节。\n\n\nRspack 配置文件#\n\n在调试模式下，Rsbuild 还会自动生成 dist/.rsbuild/rspack.config.web.mjs 文件，这里面包含了最终生成的 Rspack\n配置。在这个文件里，你可以了解到 Rsbuild 最终传递给 Rspack 的配置里包含了哪些内容。\n\n该文件的大致结构如下：\n\n\n\n关于 Rspack 配置项的完整介绍，请查看 Rspack 官方文档。","routePath":"/zh/guide/debug/debug-mode","lang":"zh","toc":[{"text":"日志信息","id":"日志信息","depth":2,"charIndex":161},{"text":"Rsbuild 配置文件","id":"rsbuild-配置文件","depth":2,"charIndex":328},{"text":"Rspack 配置文件","id":"rspack-配置文件","depth":2,"charIndex":534}],"domain":"","frontmatter":{},"version":""},{"id":323,"title":"使用 Rsdoctor","content":"#\n\nRsdoctor 是一个构建分析工具，能够可视化地展示构建过程，比如编译耗时、编译前后代码变化、模块引用关系、重复模块等。\n\n当你需要调试构建产物或构建过程时，可以借助 Rsdoctor 来提升排查问题的效率。\n\n\n快速上手#\n\n在基于 Rsbuild 的项目中，你可以通过以下步骤开启 Rsdoctor 分析：\n\n 1. 安装 Rsdoctor 插件：\n\n 2. 在 CLI 命令前添加 RSDOCTOR=true 环境变量：\n\n\n\n由于 Windows 系统不支持上述用法，你也可以使用 cross-env 来设置环境变量，这可以确保在不同的操作系统中都能正常使用：\n\n\n\n在项目内执行上述命令后，Rsbuild 会自动注册 Rsdoctor 的插件，并在构建完成后打开本次构建的分析页面，请参考 Rsdoctor 文档\n来了解完整功能。\n\n\n配置项#\n\n如果你需要配置 Rsdoctor 插件提供的选项，请手动注册 Rsdoctor 插件：\n\n","routePath":"/zh/guide/debug/rsdoctor","lang":"zh","toc":[{"text":"快速上手","id":"快速上手","depth":2,"charIndex":110},{"text":"配置项","id":"配置项","depth":2,"charIndex":376}],"domain":"","frontmatter":{},"version":""},{"id":324,"title":"异常类问题","content":"#\n\n\n编译产物中存在未编译的 ESNext 代码？#\n\n默认情况下，Rsbuild 不会编译 node_modules 下的 JavaScript 文件。如果项目引入的 npm 包中含有 ESNext\n语法，会被打包进产物中。\n\n遇到这种情况时，可以通过 source.include 配置项来指定需要额外进行编译的目录或模块。\n\n--------------------------------------------------------------------------------\n\n\n编译时报错 You may need additional loader？#\n\n如果编译过程中遇到了以下报错提示，表示存在个别文件无法被正确编译。\n\n\n\n请检查是否引用了 Rsbuild 不支持的文件格式，并自行配置相应的 Rspack loader 对其进行编译。\n\n--------------------------------------------------------------------------------\n\n\n编译时报错 Error: [object Object] is not a PostCSS plugin ?#\n\n目前，Rsbuild 使用的是 v8 版本的 PostCSS。如果编译过程中遇到了 Error: [object Object] is not a\nPostCSS plugin 报错提示，通常是由于引用到了错误的 PostCSS 版本导致，常见的如 cssnano 中 postcss\n(peerDependencies) 版本不符合预期。\n\n可以通过 npm ls postcss 查找 UNMET PEER DEPENDENCY 的依赖，然后在 package.json 中通过指定 PostCSS\n版本等方式安装正确的依赖版本即可。\n\n\n\n--------------------------------------------------------------------------------\n\n\n编译时报错 export 'foo' (imported as 'foo') was not found in './utils'？#\n\n如果编译的过程中出现此报错，说明代码中引用了一个不存在的导出。\n\n比如以下例子，index.ts 中引用了 utils.ts 中的 foo 变量， 但 utils.ts 实际上只导出了 bar 变量。\n\n\n\n在这种情况下，Rsbuild 会抛出以下错误：\n\n\n\n当你遇到该问题时，首先需要检查相关代码里 import / export 的内容是否正确，并修正相关错误。\n\n常见的错误写法有：\n\n * 引入了不存在的变量：\n\n\n\n * re-export 了一个类型，但是没有添加 type 修饰符，导致 SWC、Babel 等转译工具无法识别到类型导出，导致编译异常。\n\n\n\n在个别情况下，以上报错是由第三方依赖引入的，你无法直接修改它。此时，如果你确定该问题不影响你的应用，那么可以添加以下配置，将 error 日志修改为 warn\n级别：\n\n\n\n同时，你需要尽快联系第三方依赖的开发者来修复相应的问题。\n\n> 你可以查看 Rspack 的文档来了解 module.parser.javascript.exportsPresence 的更多细节。\n\n--------------------------------------------------------------------------------\n\n\n打包后发现 tree shaking 没有生效？#\n\nRsbuild 在生产构建时会默认开启 Rspack 的 tree shaking 功能，tree shaking 是否能够生效，取决于代码能否满足\nRspack 的 tree shaking 条件。\n\n如果你发现 tree shaking 没有按照预期生效，可以检查下相关 npm 包的 sideEffects 配置是否正确，如果你不了解 sideEffects\n的作用，或是对 tree shaking 背后的原理感兴趣，可以阅读 Rspack 官方文档 - Tree Shaking。\n\n如果你是 npm 包的开发者，可以阅读这篇文章：\n\n * 如何编写一个友好支持 Tree-shaking 的库\n\n--------------------------------------------------------------------------------\n\n\n打包时出现 JavaScript heap out of memory?#\n\n该报错表示打包过程中出现了内存溢出问题，大多数情况下是由于打包的内容较多，超出了 Node.js 默认的内存上限。\n\n如果出现 OOM 问题，最简单的方法是通过增加内存上限来解决，Node.js 提供了 --max-old-space-size 选项来对此进行设置。你可以在\nCLI 命令前添加 NODE_OPTIONS 来设置此参数。\n\n比如，在 rsbuild build 命令前添加参数：\n\n\n\n如果你执行的是其他命令，比如 rsbuild dev，请在对应的命令前添加参数。\n\nmax_old_space_size 参数的值代表内存上限大小（MB），一般情况下设置为 16384（16GB）即可。\n\nNode.js 官方文档中有对以下参数更详细的解释：\n\n * NODE_OPTIONS\n * --max-old-space-size\n\n除了增加内存上限，通过开启一些编译策略来提升构建效率也是一个解决方案，请参考 提升构建性能。\n\n如果以上方式无法解决你的问题，可能是项目中某些异常逻辑导致了内存非正常溢出。你可以排查近期的代码变更，定位问题的根因。如果无法定位，请联系我们进行排查。\n\n--------------------------------------------------------------------------------\n\n\n打包时出现 Can't resolve 'core-js/modules/abc.js'？#\n\n如果你在打包时出现了类似下面的报错，表示项目中的 core-js 无法被正确引用。\n\n\n\n通常来说，你无须在项目中安装 core-js，因为 Rsbuild 已经内置了一份 core-js v3。\n\n如果出现 core-js 找不到的报错，可能有以下几个原因：\n\n 1. 当前项目覆盖了 Rsbuild 内置的 alias 配置，导致引用 core-js 时，没有解析到正确的 core-js\n    路径，这种情况下，你可以检查项目的 alias 配置。\n 2. 项目里某一处代码依赖了 core-js v2 版本。这种情况通常需要你找出对应的代码，并升级其中的 core-js 到 v3 版本。\n 3. node_modules 中的某一个 npm 包引用了 core-js，但是没有在 dependencies 中声明 core-js\n    依赖。这种情况需要你在对应的 npm 包中声明 core-js 依赖，或者在项目根目录下安装一份 core-js。","routePath":"/zh/guide/faq/exceptions","lang":"zh","toc":[{"text":"编译产物中存在未编译的 ESNext 代码？","id":"编译产物中存在未编译的-esnext-代码","depth":3,"charIndex":3},{"text":"编译时报错 `You may need additional loader`？","id":"编译时报错-you-may-need-additional-loader","depth":3,"charIndex":-1},{"text":"编译时报错 `Error: [object Object] is not a PostCSS plugin` ?","id":"编译时报错-error-object-object-is-not-a-postcss-plugin-","depth":3,"charIndex":-1},{"text":"编译时报错 `export 'foo' (imported as 'foo') was not found in './utils'`？","id":"编译时报错-export-foo-imported-as-foo-was-not-found-in-utils","depth":3,"charIndex":-1},{"text":"打包后发现 tree shaking 没有生效？","id":"打包后发现-tree-shaking-没有生效","depth":3,"charIndex":1508},{"text":"打包时出现 `JavaScript heap out of memory`?","id":"打包时出现-javascript-heap-out-of-memory","depth":3,"charIndex":-1},{"text":"打包时出现 `Can't resolve 'core-js/modules/abc.js'`？","id":"打包时出现-cant-resolve-core-jsmodulesabcjs","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":325,"title":"功能类问题","content":"#\n\n\n如何配置组件库按需引入？#\n\n如果需要配置组件库的按需引入，你可以通过 source.transformImport 配置，这个配置的能力等价于 babel-plugin-import。\n\n\n\n--------------------------------------------------------------------------------\n\n\n如何在编译过程中进行 ESLint 代码校验？#\n\n出于编译性能的考虑，Rsbuild 默认不会在编译过程中进行 ESLint 校验，如果你需要该功能，可以使用 Rsbuild 的 ESLint 插件。\n\n--------------------------------------------------------------------------------\n\n\n如何配置静态资源的 CDN 路径？#\n\n如果需要将 JS、CSS 等静态资源上传到 CDN 使用，那么可以通过 output.assetPrefix 配置来设置静态资源的 URL 前缀。\n\n\n\n--------------------------------------------------------------------------------\n\n\n如何移除代码中的 console？#\n\n在生产模式构建时，我们可以移除代码中的 console，从而避免开发模式的日志被输出到生产模式。\n\nRsbuild 默认提供了移除 console 的配置项，请查看 performance.removeConsole。\n\n--------------------------------------------------------------------------------\n\n\n如何查看 Rsbuild 生成的 Rspack 配置?#\n\n通过 Rsbuild 调试模式可以查看 Rsbuild 生成的 Rspack 配置。\n\n你可以在执行构建时添加 DEBUG=rsbuild 环境变量，即可开启 Rsbuild 的调试模式，此时会输出内部生成的 Rspack 配置到 dist\n目录下。\n\n\n\n--------------------------------------------------------------------------------\n\n\n如何忽略特定 warning 日志？#\n\n默认情况下，Rsbuild 会打印构建过程产生的所有 error 和 warning 日志。\n\n如果遇到由于三方包产生大量 warning 日志，暂时又无法处理，希望忽略的情况。可通过 Rspack 提供的 ignoreWarnings 配置忽略特定\nwarning 日志。\n\n\n\n详细信息可参考: ignoreWarnings。","routePath":"/zh/guide/faq/features","lang":"zh","toc":[{"text":"如何配置组件库按需引入？","id":"如何配置组件库按需引入","depth":3,"charIndex":3},{"text":"如何在编译过程中进行 ESLint 代码校验？","id":"如何在编译过程中进行-eslint-代码校验","depth":3,"charIndex":183},{"text":"如何配置静态资源的 CDN 路径？","id":"如何配置静态资源的-cdn-路径","depth":3,"charIndex":369},{"text":"如何移除代码中的 console？","id":"如何移除代码中的-console","depth":3,"charIndex":549},{"text":"如何查看 Rsbuild 生成的 Rspack 配置?","id":"如何查看-rsbuild-生成的-rspack-配置","depth":3,"charIndex":763},{"text":"如何忽略特定 warning 日志？","id":"如何忽略特定-warning-日志","depth":3,"charIndex":1005}],"domain":"","frontmatter":{},"version":""},{"id":326,"title":"通用类问题","content":"#\n\n\nRsbuild 和 Rspack 的关系？#\n\nRspack 是 Rsbuild 底层的打包工具。Rsbuild 的目标是为 Rspack 用户提供开箱即用的构建能力，使开发者能够在零配置的情况下启动一个\nweb 项目。\n\nRspack 和 Rsbuild 的主要区别在于：\n\n * Rspack 项目需要从零开始配置；Rsbuild 默认提供了最佳实践的配置，并支持扩展 Rspack 配置。\n * Rspack 项目需要接入社区中的 loaders 和 plugins 来支持各种场景；Rsbuild 提供官方插件，默认支持常见的前端框架和构建能力。\n * Rspack CLI 的能力对标 webpack CLI，功能比较精简；而 Rsbuild 提供更强大的 CLI 和更完善的 dev server。\n\n--------------------------------------------------------------------------------\n\n\nRsbuild 能否用于构建工具库或组件库？#\n\nRsbuild 可以开箱即用地构建 Web 应用。\n\n对于工具库和组件库，我们推荐使用 Rslib，它是基于 Rsbuild 实现的 library 开发工具，能够复用 Rsbuild 的配置和插件。\n\n--------------------------------------------------------------------------------\n\n\nRsbuild 和 Modern.js 的关系？#\n\nModern.js 是基于 Rsbuild 实现的渐进式 Web 开发框架，它基于 Rsbuild 提供构建能力。\n\nModern.js 和 Rsbuild 的主要区别在于：\n\n * Modern.js 是基于 React 的；而 Rsbuild 不与前端 UI 框架耦合。\n * Modern.js 是全栈解决方案，提供运行时和服务端能力；Rsbuild 是构建工具，其他能力可以通过插件进行扩展。\n * Modern.js 内置了更多功能；Rsbuild 则更加追求轻量和灵活性。","routePath":"/zh/guide/faq/general","lang":"zh","toc":[{"text":"Rsbuild 和 Rspack 的关系？","id":"rsbuild-和-rspack-的关系","depth":3,"charIndex":3},{"text":"Rsbuild 能否用于构建工具库或组件库？","id":"rsbuild-能否用于构建工具库或组件库","depth":3,"charIndex":443},{"text":"Rsbuild 和 Modern.js 的关系？","id":"rsbuild-和-modernjs-的关系","depth":3,"charIndex":653}],"domain":"","frontmatter":{},"version":""},{"id":327,"title":"热更新问题","content":"#\n\n\n热更新不生效，如何排查？#\n\n热更新不生效有很多种可能的原因，在这篇文档中会介绍大部分常见的原因，你可以参照以下内容进行排查。\n\n在开始排查之前，请简单了解一下热更新的原理：\n\n热更新原理\n 1. 浏览器和开发服务器建立一个 Web Socket 连接，用于实时通信。\n 2. 当开发服务器每次重新编译完成后，会通过 Web Socket 通知浏览器，浏览器向开发服务器发送 hot-update.(js|json)\n    请求，从而加载编译后的新模块。\n 3. 当浏览器收到新的模块后，如果是 React 项目，则会通过 React 官方的 React Refresh 来更新 React 组件，其他框架也是类似。\n\n了解完热更新的原理后，你可以按照以下步骤来进行基本的排查：\n\n1. 检查 Web Socket 连接#\n\n打开浏览器的控制台，查看是否有 [HMR] connected. 日志。\n\n * 如果有，说明 Web Socket 连接正常，请继续检查后续步骤。\n * 如果没有，请打开 Chrome 的 Network 面板，查看 ws://[host]:[port]/rsbuild-hmr\n   的请求状态，若请求异常，说明热更新失败的原因是 Web Socket 请求没有建立成功。\n\nWeb Socket 请求没有建立成功的原因可能有很多种，例如开启了网络代理，导致 Web Socket 请求没有正确发送到开发服务器。你可以检查 Web\nSocket 请求的地址是否为你的开发服务器地址，如果不是，则可以通过 dev.client 来配置 Web Socket 请求的地址。\n\n2. 检查 hot-update 请求#\n\n当你修改一个模块的代码，并触发重新编译后，浏览器会向开发服务器发送若干个 hot-update.json 和 hot-update.js\n请求，用于获取更新后的代码。\n\n你可以尝试修改一个模块并检查 hot-update.(js|json) 请求的内容，如果请求的内容是最新的代码，说明热更新的请求正常。\n\n如果请求的内容错误，大概率也是由于开启了网络代理，请检查 hot-update.(js|json)\n请求的地址是否为你的开发服务器地址，如果不是，则需要调整代理规则，将 hot-update.(js|json) 请求代理到开发服务器地址。\n\n3. 检查其他原因#\n\n如果以上两个步骤都没有问题，那么可能是其他原因导致的热更新失败，比如没有符合 React 对热更新的要求，你可以参考下列的问题进行排查。\n\n--------------------------------------------------------------------------------\n\n\n打包时 external React 后，热更新不生效？#\n\n为了保证热更新生效，我们需要使用 React 和 ReactDOM 的开发模式产物。\n\n当你将 React 通过 externals 排除后，通常会通过 CDN 等方式注入 React 的生产模式产物，所以热更新会不生效。\n\n\n\n为了解决该问题，你需要引用 React 的开发模式产物，同时安装 React DevTools，安装完成后即可实现热更新。\n\n如果你不确定当前使用的 React 产物类型，可以参考：React 官方文档 - Use the Production Build。\n\n--------------------------------------------------------------------------------\n\n\n开发环境设置文件名的 hash 后，热更新不生效？#\n\n通常来说，我们只会在生产模式下设置文件名的 hash 值（即 process.env.NODE_ENV === 'production' 时）。\n\n如果你在开发模式下设置了文件名的 hash，那么可能会导致热更新不生效（尤其是 CSS 文件）。这是因为每次文件内容变化时，都会引起 hash 变化，导致\nmini-css-extract-plugin 等工具无法读取到最新的文件内容。\n\n * 正确用法：\n\n\n\n * 错误用法：\n\n\n\n--------------------------------------------------------------------------------\n\n\n开启 https 后，热更新不生效？#\n\n当开启 https 时，由于证书的问题，可能会出现 HMR 连接失败的情况，此时打开控制台，会出现 HMR connect failed 的报错。\n\n\n\n此问题的解决方法为：点击 Chrome 浏览器问题页面的「高级」->「继续前往 some page（不安全）」。\n\n> Tips: 当通过 Localhost 访问页面时，「您的连接不是私密连接」字样可能不会出现，可访问 Network 域名进行处理。","routePath":"/zh/guide/faq/hmr","lang":"zh","toc":[{"text":"热更新不生效，如何排查？","id":"热更新不生效如何排查","depth":3,"charIndex":3},{"text":"1. 检查 Web Socket 连接","id":"1-检查-web-socket-连接","depth":4,"charIndex":345},{"text":"2. 检查 hot-update 请求","id":"2-检查-hot-update-请求","depth":4,"charIndex":705},{"text":"3. 检查其他原因","id":"3-检查其他原因","depth":4,"charIndex":1002},{"text":"打包时 external React 后，热更新不生效？","id":"打包时-external-react-后热更新不生效","depth":3,"charIndex":1167},{"text":"开发环境设置文件名的 hash 后，热更新不生效？","id":"开发环境设置文件名的-hash-后热更新不生效","depth":3,"charIndex":1527},{"text":"开启 https 后，热更新不生效？","id":"开启-https-后热更新不生效","depth":3,"charIndex":1856}],"domain":"","frontmatter":{},"version":""},{"id":328,"title":"Preact","content":"#\n\n在这篇文档中，你可以了解到如何基于 Rsbuild 来构建一个 Preact 应用。\n\n\n创建 Preact 项目#\n\n你可以使用 create-rsbuild 来创建一个 Rsbuild + Preact 的项目，调用以下命令：\n\n然后在 Select framework 时选择 Preact 即可。\n\n\n在已有项目中使用 Preact#\n\n为了能够编译 Preact，你需要注册 Rsbuild 的 Preact 插件，插件会自动添加 Preact 构建所需的配置。\n\n例如，在 rsbuild.config.ts 中注册：\n\n\n\n\nPreact Fast Refresh#\n\nPreact 插件使用 @preact/prefresh 和 @rspack/plugin-preact-refresh 来热替换 Preact 组件。\n\n\n识别#\n\nPrefresh 需要能够识别你的组件，这意味着组件名称应该以大写字母开头，hook 名称应该以 use\n开头，后跟一个大写字母。这使得插件能够有效地识别这些内容。\n\n注意，如下所示的组件是没有命名的：\n\n\n\n相反，应该这样写：\n\n\n\n当使用高阶组件（HOC）时，请确保设置 displayName 以便插件能够将其识别为组件。","routePath":"/zh/guide/framework/preact","lang":"zh","toc":[{"text":"创建 Preact 项目","id":"创建-preact-项目","depth":2,"charIndex":47},{"text":"在已有项目中使用 Preact","id":"在已有项目中使用-preact","depth":2,"charIndex":157},{"text":"Preact Fast Refresh","id":"preact-fast-refresh","depth":2,"charIndex":272},{"text":"识别","id":"识别","depth":3,"charIndex":373}],"domain":"","frontmatter":{},"version":""},{"id":329,"title":"React","content":"#\n\n在这篇文档中，你可以了解到如何基于 Rsbuild 来构建一个 React 应用。\n\n\n创建 React 项目#\n\n你可以使用 create-rsbuild 来创建一个 Rsbuild + React 的项目，调用以下命令：\n\n然后在 Select framework 时选择 React 即可。\n\n\n在已有项目中使用 React#\n\n为了能够编译 React，你需要注册 Rsbuild 的 React 插件，插件会自动添加 React 构建所需的配置。\n\n例如，在 rsbuild.config.ts 中注册：\n\n\n\nTIP\n\n对于使用 Create React App 的项目，可以参考 CRA 迁移指南。\n\n\n使用 SVGR#\n\nRsbuild 支持调用 SVGR，将 SVG 图片转换为一个 React 组件使用。\n\n如果你需要使用 SVGR，需要注册 Rsbuild 的 SVGR 插件。\n\n\nReact Fast Refresh#\n\nRsbuild 使用 React 官方的 Fast Refresh 能力来进行组件热更新。\n\n注意 React Refresh 要求组件按照规范的方式编写，否则热更新可能无效，你可以使用 eslint-plugin-react-refresh 进行校验。\n\n比如，如果 React 组件的热更新无法生效，或者是热更新后 React 组件的 state 丢失，这通常是因为你的 React 组件使用了匿名函数。在\nReact Fast Refresh 的官方实践中，要求组件不能为匿名函数，否则热更新后无法保留 React 组件的 state。\n\n以下是一些错误用法的例子：\n\n\n\n正确用法是给每个组件函数声明一个名称：\n\n\n\n\nReact Compiler#\n\nReact Compiler 是 React 19 引入的一个实验性编译器，它可以自动优化你的 React 代码。\n\n在开始使用 React Compiler 之前，建议阅读 React Compiler 文档，以了解 React Compiler 的功能、当前状态和使用方法。\n\n\n如何使用#\n\n在 Rsbuild 中使用 React Compiler 的步骤如下：\n\n 1. 升级 react 和 react-dom 版本到 19。如果你暂时无法升级，可以在 React 17 或 18 项目中安装\n    react-compiler-runtime，以允许编译后的代码在 19 之前的版本上运行。\n 2. 目前 React Compiler 仅提供了 Babel 插件，你需要安装 @rsbuild/plugin-babel 和\n    babel-plugin-react-compiler。\n 3. 在你的 Rsbuild 配置文件中注册 Babel 插件：\n\n\n\n> 你也可以参考 示例项目。\n\n\n配置#\n\n通过以下方式来传入 React Compiler 的配置：\n\n\n\n对于 React 17 和 18 的项目，除了安装 react-compiler-runtime，还需要指定 target：\n\n\n\n\nRouter#\n\n\nTanStack Router#\n\nTanStack Router 是一个类型安全的 React 路由，内置数据获取、缓存和一流的 search-param API。\n\nTanStack Router 提供了 @tanstack/router-plugin 来与 Rsbuild 集成，该插件支持基于文件的路由，详见：\n\n * File-Based Routing 文档\n * TanStack Router + Rsbuild 示例\n\n\nCSS-in-JS#\n\n\n使用 styled-components#\n\nRsbuild 支持编译 styled-components，优化调试体验，并对 styled-components 添加服务器端渲染支持。\n\n如果你需要使用 styled-components, 我们推荐使用 @rsbuild/plugin-styled-components。\n\n> 你可以参考这个示例：styled-components。\n\n\n使用 Emotion#\n\nRsbuild 支持编译 Emotion，你可以添加以下配置来使用：\n\n * swcReactOptions.importSource\n * @swc/plugin-emotion\n\n\n\n> 你可以参考这个示例：emotion。\n\n\n使用 styled-jsx#\n\n你可以通过 @swc/plugin-styled-jsx 来使用 styled-jsx：\n\n\n\n请注意，你需要选择和当前 @swc/core 版本匹配的 SWC 插件，才能使 SWC 正常执行，详见 tools.swc。\n\n> 你可以参考这个示例：styled-jsx。\n\n\n使用 vanilla-extract#\n\nRsbuild 支持使用 @vanilla-extract/webpack-plugin 插件，你可以添加以下配置来使用 vanilla-extract：\n\n\n\n> 你可以参考这个示例：vanilla-extract。\n\n\n使用 StyleX#\n\n你可以通过 unplugin-stylex 来使用 StyleX:\n\n\n\n> 你可以参考这个示例：stylex。","routePath":"/zh/guide/framework/react","lang":"zh","toc":[{"text":"创建 React 项目","id":"创建-react-项目","depth":2,"charIndex":46},{"text":"在已有项目中使用 React","id":"在已有项目中使用-react","depth":2,"charIndex":153},{"text":"使用 SVGR","id":"使用-svgr","depth":2,"charIndex":311},{"text":"React Fast Refresh","id":"react-fast-refresh","depth":2,"charIndex":405},{"text":"React Compiler","id":"react-compiler","depth":2,"charIndex":740},{"text":"如何使用","id":"如何使用","depth":3,"charIndex":899},{"text":"配置","id":"配置","depth":3,"charIndex":1213},{"text":"Router","id":"router","depth":2,"charIndex":1318},{"text":"TanStack Router","id":"tanstack-router","depth":3,"charIndex":1328},{"text":"CSS-in-JS","id":"css-in-js","depth":2,"charIndex":1548},{"text":"使用 styled-components","id":"使用-styled-components","depth":3,"charIndex":1561},{"text":"使用 Emotion","id":"使用-emotion","depth":3,"charIndex":1759},{"text":"使用 styled-jsx","id":"使用-styled-jsx","depth":3,"charIndex":1889},{"text":"使用 vanilla-extract","id":"使用-vanilla-extract","depth":3,"charIndex":2043},{"text":"使用 StyleX","id":"使用-stylex","depth":3,"charIndex":2176}],"domain":"","frontmatter":{},"version":""},{"id":330,"title":"Solid","content":"#\n\n在这篇文档中，你可以了解到如何基于 Rsbuild 来构建一个 Solid 应用。\n\n\n创建 Solid 项目#\n\n你可以使用 create-rsbuild 来创建一个 Rsbuild + Solid 的项目，调用以下命令：\n\n然后在 Select framework 时选择 Solid 即可。\n\n\n在已有项目中使用 Solid#\n\n为了能够编译 Solid 组件，你需要注册 Rsbuild 的 Solid 插件，插件会自动添加 Solid 构建所需的配置。\n\n例如，在 rsbuild.config.ts 中注册：\n\n","routePath":"/zh/guide/framework/solid","lang":"zh","toc":[{"text":"创建 Solid 项目","id":"创建-solid-项目","depth":2,"charIndex":46},{"text":"在已有项目中使用 Solid","id":"在已有项目中使用-solid","depth":2,"charIndex":153}],"domain":"","frontmatter":{},"version":""},{"id":331,"title":"Svelte","content":"#\n\n在这篇文档中，你可以了解到如何基于 Rsbuild 来构建一个 Svelte 5 或 Svelte 4 应用。\n\n\n创建 Svelte 项目#\n\n你可以使用 create-rsbuild 来创建一个 Rsbuild + Svelte 的项目，调用以下命令：\n\n然后在 Select framework 时选择 Svelte 5 或 Svelte 4 即可。\n\n\n在已有项目中使用 Svelte#\n\n为了能够编译 Svelte 组件（.svelte 文件），你需要注册 Rsbuild 的 Svelte 插件，插件会自动添加 Svelte 构建所需的配置。\n\n例如，在 rsbuild.config.ts 中注册：\n\n","routePath":"/zh/guide/framework/svelte","lang":"zh","toc":[{"text":"创建 Svelte 项目","id":"创建-svelte-项目","depth":2,"charIndex":60},{"text":"在已有项目中使用 Svelte","id":"在已有项目中使用-svelte","depth":2,"charIndex":183}],"domain":"","frontmatter":{},"version":""},{"id":332,"title":"Vue","content":"#\n\n在这篇文档中，你可以了解到如何基于 Rsbuild 来构建一个 Vue 3 或 Vue 2 应用。\n\n\n创建 Vue 项目#\n\n你可以使用 create-rsbuild 来创建一个 Rsbuild + Vue 的项目，调用以下命令：\n\n然后在 Select framework 时选择 Vue 3 或 Vue 2 即可。\n\n\nVue 3#\n\n\n在已有项目中使用 Vue 3#\n\n为了能够编译 Vue 的 SFC（单文件组件），你需要注册 Rsbuild 的 Vue 插件，插件会自动添加 Vue 构建所需的配置。\n\n例如，在 rsbuild.config.ts 中注册：\n\n\n\nTIP\n\n对于使用 Vue CLI 的项目，可以参考 Vue CLI 迁移指南。\n\n\n使用 Vue JSX 语法#\n\n如果你需要使用 Vue 的 JSX 语法，还需要注册 Rsbuild 的 Vue 3 JSX 插件。\n\n\nTypeScript 支持#\n\nRsbuild 默认支持编译 TypeScript。\n\n请参考 Vue 官方文档的 TypeScript - IDE 支持 小节，了解如何在 IDE 中设置 Vue TypeScript 支持。\n\n\nVue 2#\n\n\n在已有项目中使用 Vue 2#\n\n为了能够编译 Vue 的 SFC（单文件组件），你需要注册 Rsbuild 的 Vue 2 插件，插件会自动添加 Vue 构建所需的配置。\n\n例如，在 rsbuild.config.ts 中注册：\n\n\n\nTIP\n * Vue 2 插件仅支持 Vue >= 2.7.0 版本。\n * 对于使用 Vue CLI 的项目，可以参考 Vue CLI 迁移指南。\n\n\n使用 Vue JSX 语法#\n\n如果你需要使用 Vue 的 JSX 语法，还需要注册 Rsbuild 的 Vue 2 JSX 插件。\n\n\n类型声明#\n\n在 TypeScript 项目中，你需要为 *.vue 文件添加类型定义，使 TypeScript 能够正确识别它。\n\n请在 src 目录下创建 env.d.ts，并添加以下内容：\n\n","routePath":"/zh/guide/framework/vue","lang":"zh","toc":[{"text":"创建 Vue 项目","id":"创建-vue-项目","depth":2,"charIndex":54},{"text":"Vue 3","id":"vue-3","depth":2,"charIndex":165},{"text":"在已有项目中使用 Vue 3","id":"在已有项目中使用-vue-3","depth":3,"charIndex":174},{"text":"使用 Vue JSX 语法","id":"使用-vue-jsx-语法","depth":3,"charIndex":334},{"text":"TypeScript 支持","id":"typescript-支持","depth":3,"charIndex":403},{"text":"Vue 2","id":"vue-2","depth":2,"charIndex":519},{"text":"在已有项目中使用 Vue 2","id":"在已有项目中使用-vue-2","depth":3,"charIndex":528},{"text":"使用 Vue JSX 语法","id":"使用-vue-jsx-语法-1","depth":3,"charIndex":724},{"text":"类型声明","id":"类型声明","depth":3,"charIndex":793}],"domain":"","frontmatter":{},"version":""},{"id":333,"title":"Create React App","content":"#\n\n本章节介绍如何将 Create React App（简称 CRA）或 CRACO 项目迁移到 Rsbuild。\n\nCRA eject\n\n如果你的项目已经执行了 CRA 的 eject 命令，那么本文档的大部分内容将不再适用。\n\nCRA 项目在 eject 后，更近似于直接使用 webpack 的项目，因此你可以参考 webpack 迁移指南。\n\n\n安装依赖#\n\n首先你需要把 CRA 的 npm 依赖替换为 Rsbuild 的依赖。\n\n * 移除 CRA 的依赖：\n\n> 对于使用 CRACO 的项目，你还可以移除 @craco/craco 依赖。\n\n * 安装 Rsbuild 的依赖：\n\n\n更新 npm scripts#\n\n下一步，你需要把 package.json 中的 npm scripts 更新为 Rsbuild 的 CLI 命令。\n\n\n\nTIP\n\nRsbuild 未集成测试框架，因此没有提供用于替换 react-scripts test 的命令，你可以直接使用 Jest 或 Vitest\n等测试框架。你可以参考 Rsbuild react-jest 示例项目进行配置。\n\n\n创建配置文件#\n\n在 package.json 的同级目录下创建 Rsbuild 的配置文件 rsbuild.config.ts，并添加以下内容：\n\n\n\n\nHTML 模板#\n\nCRA 默认使用 public/index.html 文件作为 HTML 模板。在 Rsbuild 中，你可以通过 html.template 来指定 HTML\n模板：\n\n\n\n在 HTML 模板中，如果使用了 CRA 的 %PUBLIC_URL% 变量，请替换为 Rsbuild 的 assetPrefix 变量，并使用斜杠进行连接：\n\n\n\n这样就完成了从 CRA 到 Rsbuild 的基本迁移，此时你可以执行 npm run start 命令来尝试启动开发服务器。\n\n\n构建产物目录#\n\nCRA 默认会将构建产物输出到 build 目录，而 Rsbuild 的默认构建产物目录为 dist。\n\n你可以配置 Rsbuild 的 output.distPath.root 选项，将目录修改为 build，与 CRA 保持一致：\n\n\n\n> 更多细节请参考构建产物目录章节。\n\n\n使用 CSS 预处理器#\n\nRsbuild 通过插件来支持 Sass 和 Less 等 CSS 预处理器，使用方式请参考：\n\n * Sass 插件\n * Less 插件\n * Stylus 插件\n\n\n使用 SVGR#\n\n如果你使用了 CRA 的 \"SVG 转 React 组件\" 功能（即 SVGR），那么还需要安装 Rsbuild 的 SVGR 插件。\n\n比如使用了以下用法：\n\n\n\n只需要安装和注册 @rsbuild/plugin-svgr 即可：\n\n\n\n请参考 SVGR 插件 文档了解如何在 Rsbuild 中使用 SVGR。\n\n\n配置迁移#\n\n以下是 CRA 配置对应的 Rsbuild 配置：\n\nCRA                       RSBUILD\nHOST                      server.host\nPORT                      server.port\nHTTPS                     server.https\nWDS_SOCKET_HOST           dev.client.host\nWDS_SOCKET_PATH           dev.client.path\nWDS_SOCKET_PORT           dev.client.port\nPUBLIC_URL                dev.assetPrefix / output.assetPrefix\nBUILD_PATH                output.distPath\nGENERATE_SOURCEMAP        output.sourceMap\nIMAGE_INLINE_SIZE_LIMIT   output.dataUriLimit\nFAST_REFRESH              dev.hmr\nTSC_COMPILE_ON_ERROR      @rsbuild/plugin-type-check\n\n说明：\n\n * 上述表格尚未覆盖到 CRA 的所有配置，欢迎补充。\n\n\n编译 node_modules#\n\nCRA 默认会使用 Babel 编译 node_modules 中的依赖，但 Rsbuild 则不会，这是为了避免二次编译带来的性能损耗和潜在的编译错误。\n\n如果你需要处理 node_modules 中依赖引起的语法兼容性问题，可以使用 source.include 配置项来编译 node_modules。\n\n\n环境变量#\n\nCRA 默认会将 REACT_APP_ 开头的环境变量注入到 client 代码中，而 Rsbuild 默认会注入 PUBLIC_ 开头的环境变量（参考\npublic 变量）。\n\n为了兼容 CRA 的行为，你可以手动调用 Rsbuild 提供的 loadEnv 方法来读取 REACT_APP_ 开头的环境变量，并通过\nsource.define 配置项注入到 client 代码中。\n\n\n\n值得注意的是，CRA 允许在代码中访问完整的 process.env 对象，也允许对 process.env 进行解构。而 Rsbuild\n出于包体积和安全的考虑，并没有注入完整的 process.env 对象。\n\n\n\n在 Rsbuild 中，你可以通过 source.define 配置项设置 process.env，读取 loadEnv 方法返回的\nrawPublicVars，来允许以上用法：\n\n\n\n\n引用未知资源#\n\n在 CRA 中，如果你引用了一个构建工具无法识别的资源，CRA 默认会将该文件输出到 build/static/media 目录下，比如\ndocument.pdf 文件：\n\n\n\n在 Rsbuild 中，遇到无法识别的资源时，Rsbuild 会输出报错日志，类似于：\n\n\n\n为了解决该错误，你可以采用以下方法：\n\n * 使用 tools.rspack 配置一个合适的 loader 来处理该类型的资源。\n * 使用 tools.rspack 配置 asset modules 规则来处理该类型的资源。\n\n比如，你可以添加以下 asset modules 配置，来保持与 CRA 相同的输出结果：\n\n\n\n\n移除 react-app-polyfill#\n\nCRA 提供了 react-app-polyfill 来手动注入 polyfill 代码。\n\n在 Rsbuild 项目中，你可以移除 react-app-polyfill 相关的依赖和代码，因为 Rsbuild 会自动读取 browserslist\n配置，并按需注入 polyfill 代码。\n\n\n\n你可以参考 浏览器兼容性 来了解 Rsbuild 是如何处理 polyfill 的。\n\n\n添加 ESLint 插件#\n\nCRA 默认启用了 eslint-webpack-plugin，并内置了一套 ESLint 规则集。\n\n在 Rsbuild 项目中，如果你需要保持类似的行为，可以添加 @rsbuild/plugin-eslint，并使用\neslint-config-react-app 作为 ESLint 规则集。\n\n\n\n\n读取 jsconfig.json#\n\n在非 TypeScript 项目中，CRA 支持读取 jsconfig.json 中的 paths 字段作为路径别名。\n\n如果你需要在 Rsbuild 中使用该特性，可以参考 路径别名 - jsconfig.json。\n\n\nCRACO 迁移#\n\n如果你的项目使用了 CRACO 来覆盖 CRA 的配置，可以参考下表来迁移：\n\nCRACO                    RSBUILD\nwebpack.configure        tools.rspack\nwebpack.alias            resolve.alias\nwebpack.plugins.add      appendPlugins of tools.rspack\nwebpack.plugins.remove   removePlugin of tools.rspack\nstyle.modules            output.cssModules\nstyle.css                tools.cssLoader\nstyle.sass               Sass 插件\nstyle.postcss            tools.postcss\nbabel                    Babel 插件\ntypescript               @rsbuild/plugin-type-check\ndevServer                server configs\n\n\n示例#\n\n下面是一个从 webpack.configure 迁移到 tools.rspack 的例子：\n\n * 迁移前：\n\n\n\n * 迁移后：\n\n\n\n\n内容补充#\n\n当前文档只涵盖了迁移过程的部分事项，如果你发现有合适的内容可以补充，欢迎通过 pull request 来完善文档 🤝。\n\n> Rsbuild 的文档位于 rsbuild/website 目录。","routePath":"/zh/guide/migration/cra","lang":"zh","toc":[{"text":"安装依赖","id":"安装依赖","depth":2,"charIndex":177},{"text":"更新 npm scripts","id":"更新-npm-scripts","depth":2,"charIndex":300},{"text":"创建配置文件","id":"创建配置文件","depth":2,"charIndex":499},{"text":"HTML 模板","id":"html-模板","depth":2,"charIndex":577},{"text":"构建产物目录","id":"构建产物目录","depth":2,"charIndex":824},{"text":"使用 CSS 预处理器","id":"使用-css-预处理器","depth":2,"charIndex":975},{"text":"使用 SVGR","id":"使用-svgr","depth":2,"charIndex":1075},{"text":"配置迁移","id":"配置迁移","depth":2,"charIndex":1245},{"text":"编译 node_modules","id":"编译-node_modules","depth":2,"charIndex":1872},{"text":"环境变量","id":"环境变量","depth":2,"charIndex":2047},{"text":"引用未知资源","id":"引用未知资源","depth":2,"charIndex":2454},{"text":"移除 react-app-polyfill","id":"移除-react-app-polyfill","depth":2,"charIndex":2764},{"text":"添加 ESLint 插件","id":"添加-eslint-插件","depth":2,"charIndex":2983},{"text":"读取 jsconfig.json","id":"读取-jsconfigjson","depth":2,"charIndex":3152},{"text":"CRACO 迁移","id":"craco-迁移","depth":2,"charIndex":3283},{"text":"示例","id":"示例","depth":3,"charIndex":3837},{"text":"内容补充","id":"内容补充","depth":2,"charIndex":3913}],"domain":"","frontmatter":{},"version":""},{"id":334,"title":"Modern.js Builder","content":"#\n\n本章节介绍如何将使用 Modern.js Builder (或 EdenX Builder) 的项目迁移到 Rsbuild。\n\n\n主要区别#\n\nRsbuild 是 Modern.js Builder 的新版本，主要区别如下：\n\n * Rsbuild 的性能更出色，在同时使用 Rspack 的情况下，Rsbuild 的启动速度和构建速度是 Builder 的 1.5 ~ 2 倍。\n * Rsbuild 仅支持 Rspack 作为打包工具，不再支持 Webpack。\n * Rsbuild 的 CLI 工具和 dev server 更加强大，支持更多功能。\n\n\n安装依赖#\n\n首先你需要把 Builder 相关的 npm 依赖替换为 Rsbuild 的依赖。\n\n * 移除 Builder 的依赖：\n\n * 安装 Rsbuild 的依赖：\n\n\n更新 npm scripts#\n\n下一步，你需要把 package.json 中的 npm scripts 更新为 Rsbuild 的 CLI 命令。\n\n\n\n\n修改配置文件#\n\n * 将 builder.config.ts 重命名为 rsbuild.config.ts。\n * 从 @modern-js/builder-cli 中导入 defineConfig 方法，改为从 @rsbuild/core 中导入。\n * 将 builderPlugins 字段改为 plugins。\n\n\n\n\n替换插件#\n\nRsbuild 和 Builder 的插件系统不兼容，因此需要将 Builder 的插件替换为 Rsbuild 的插件。\n\n下面是 Builder 插件和 Rsbuild 插件的对应关系：\n\nBUILDER                                    RSBUILD\n@modern-js/builder-plugin-vue              @rsbuild/plugin-vue\n@modern-js/builder-plugin-vue2             @rsbuild/plugin-vue2\n@modern-js/builder-plugin-stylus           @rsbuild/plugin-stylus\n@modern-js/builder-plugin-node-polyfill    @rsbuild/plugin-node-polyfill\n@modern-js/builder-plugin-image-compress   @rsbuild/plugin-image-compress\n@modern-js/builder-plugin-swc              默认生效，无须使用\n@modern-js/builder-plugin-esbuild          不再支持\n\n以 @modern-js/builder-plugin-vue 为例，你需要先安装 @rsbuild/plugin-vue，然后在\nrsbuild.config.ts 中引入插件，并添加到 plugins 字段中。\n\n\n\n\n添加 React 相关插件#\n\nRsbuild 不与任何前端 UI 框架耦合。因此，如果你是一个 React 项目，需要手动添加 React 插件：\n\n\n\n如果你当前项目中有使用 SVGR，还需要注册 Rsbuild 的 SVGR 插件：\n\n\n\n如果你是其他框架的使用者，可参考 插件列表 选择对应的框架插件。\n\n\n配置迁移#\n\nRsbuild 和 Builder 的绝大多数配置项是一致的，仅有少许配置项进行了调整。\n\n你可以通过 Rsbuild 配置项 来查看 Rsbuild 的配置项。\n\n值得注意的是，相比 Builder，Rsbuild 中一些默认值和行为存在差异：\n\n * 浏览器范围：默认最低兼容到支持 原生 ES Modules 的浏览器，可参考 Browserslist 默认值。\n * HTML 文件输出位置：默认输出到 dist 目录的根部，可参考 默认产物目录。\n * Polyfill 注入方式：默认按需注入，可参考 output.polyfill。\n * TypeScript 类型检查：默认不开启，需要手动注册 @rsbuild/plugin-type-check。\n * 修改 DevServer 配置：通过 dev 和 server 配置项修改。\n\n\n验证结果#\n\n完成以上步骤后，你已经完成了从 Modern.js Builder 到 Rsbuild 的基本迁移，此时可以执行 npm run dev\n命令来尝试启动开发服务器。\n\n如果在构建过程中发现问题，请根据错误日志进行调试。\n\n\n内容补充#\n\n当前文档只涵盖了迁移过程的部分事项，如果你发现有合适的内容可以补充，欢迎通过 pull request 来完善文档 🤝。\n\n> Rsbuild 的文档位于 rsbuild/website 目录。","routePath":"/zh/guide/migration/modern-builder","lang":"zh","toc":[{"text":"主要区别","id":"主要区别","depth":2,"charIndex":67},{"text":"安装依赖","id":"安装依赖","depth":2,"charIndex":283},{"text":"更新 npm scripts","id":"更新-npm-scripts","depth":2,"charIndex":374},{"text":"修改配置文件","id":"修改配置文件","depth":2,"charIndex":454},{"text":"替换插件","id":"替换插件","depth":2,"charIndex":619},{"text":"添加 React 相关插件","id":"添加-react-相关插件","depth":2,"charIndex":1327},{"text":"配置迁移","id":"配置迁移","depth":2,"charIndex":1485},{"text":"验证结果","id":"验证结果","depth":2,"charIndex":1870},{"text":"内容补充","id":"内容补充","depth":2,"charIndex":1989}],"domain":"","frontmatter":{},"version":""},{"id":335,"title":"从 Rsbuild 0.x 迁移","content":"#\n\n当前文档列出了从 Rsbuild 0.7 到 1.0 的所有不兼容更新，你可以参考此文档来迁移。\n\n> 查看 Breaking changes in Rsbuild v1.0.0 了解更多细节。\n\n\n[重要] Lightning CSS loader#\n\nRsbuild 现在默认启用 lightningcss-loader 来转换 CSS 文件，它取代了 autoprefixer 来添加 vendor\nprefixes，并提供了更好的性能。\n\n * @rsbuild/plugin-lightningcss 已被废弃且不再需要。\n * tools.autoprefixer 配置已被移除。\n\n考虑到 Lightning CSS 有一些未覆盖的边缘情况，你仍然可以通过 postcss 配置文件启用 autoprefixer：\n\n\n\n\n[重要] output.polyfill#\n\nRsbuild v1 默认将 output.polyfill 设置为 'off'，这可以减少 polyfill 代码并默认生成更小的包。\n\n如果你的应用需要 polyfill，请将 output.polyfill 设置为 'usage' 或 'entry'：\n\n\n\n\n[重要] source.decorators#\n\nRsbuild 现在默认使用 2022-11 装饰器版本。这使得 Rsbuild 的默认行为与 TypeScript >= 5.0 和 esbuild >=\n0.21.0 保持一致。\n\n如果你在使用旧版装饰器，可以添加以下配置：\n\n\n\n\n[重要] output.targets#\n\nTIP\n\nRsbuild v1 移除了 output.targets 选项，以及 source.alias / source.entry 等配置的 target\n参数，改为通过 environments 配置以提供更灵活的多环境配置能力。\n\n对比原有选项，environments 覆盖范围更广，可对更多配置项进行多环境差异化配置。详情可参考多环境构建。\n\n移除 output.targets 配置，改用 output.target 和 environments 配置。\n\n * before:\n\n\n\n * after:\n\n\n\n\n[重要] Rspack 配置校验#\n\nRsbuild 现在默认启用 Rspack 的 scheme 校验，以确保 Rspack 配置的正确性。\n\n * 当 Rspack 配置的类型错误时，会抛出错误并终止构建。\n * 当 Rspack 配置中存在多余的字段时，会抛出错误，但不会终止构建。\n\n> 详见 Rspack - RSPACK_CONFIG_VALIDATE。\n\n\nsource.alias#\n\n移除 source.alias 函数的 target 参数，改用 environments 配置。\n\n * before:\n\n\n\n * after:\n\n\n\n\nsource.entry#\n\n移除了 source.entry 函数用法，改为使用 environments 配置。\n\n * before:\n\n\n\n * after:\n\n\n\n\noutput.overrideBrowserslist#\n\noutput.overrideBrowserslist 不再支持 Record 类型，使用 environments 配置代替。\n\n * before:\n\n\n\n * after:\n\n\n\n\noutput.emitAssets#\n\noutput.emitAssets 调整为 boolean 类型，使用 environments 配置代替。\n\n * before:\n\n\n\n * after:\n\n\n\n\noutput.distPath.server#\n\n移除 output.distPath.server，使用 environments 配置代替。\n\n\n\n\noutput.minify.html#\n\nRsbuild v1 移除了 output.minify.html 和 output.minify.htmlOptions 选项，不再对 HTML\n文件进行压缩。\n\n之前 Rsbuild 使用 html-minifier-terser 来压缩 HTML 文件。但 html-minifier-terser 的性能无法满足\nRsbuild 应用的需求，并且在大多数情况下，压缩 HTML 带来的收益很小。\n\n目前，Rsbuild 不再内置 html-minifier-terser，因此我们提供了一个独立的插件\nrsbuild-plugin-html-minifier-terser 来支持 HTML 压缩。\n\n\n\n我们计划在未来使用一些性能更好的基于 Rust 的 HTML 压缩器。\n\n\noutput.charset#\n\noutput.charset 的默认值由 ascii 调整为 utf8。\n\n如果你需要使用 ascii，可以添加配置：\n\n\n\n\ndev.startUrl#\n\ndev.startUrl 被重命名为 server.open：\n\n\n\n\ndev.client.port#\n\ndev.client.port 的默认值从 调整为 '' (使用 location.port)。\n\n你也可以使用之前的默认值：\n\n\n\n\nhtml.appIcon#\n\n之前，html.appIcon 不支持 web app manifests，这意味着它仅适用于 iOS。\n\n现在 html.appIcon 支持生成 web app manifests，并且 html.appIcon 的类型有变更。\n\n * before:\n\n\n\n * after:\n\n\n\n\n其他#\n\nRsbuild 1.0 对插件、dev server 等 API 进行了部分调整和优化。\n\n调整包括：\n\n * onBeforeBuild 钩子在 watch 模式下支持触发多次。\n * 新增 onBeforeEnvironmentCompile 和 onAfterEnvironmentCompile 钩子，分别在执行单个\n   environment 的构建前/后触发。\n * 移除 api.getHtmlPaths，改为 environment.htmlPaths。\n * 移除 api.context.entry，改为 environment.entry。\n * 移除 api.context.targets，改为 environment.target。\n * 移除 rsbuildServer.onHTTPUpgrade，改为 rsbuildServer.connectWebSocket。","routePath":"/zh/guide/migration/rsbuild-0-x","lang":"zh","toc":[{"text":"[重要] Lightning CSS loader","id":"重要-lightning-css-loader","depth":2,"charIndex":102},{"text":"[重要] output.polyfill","id":"重要-outputpolyfill","depth":2,"charIndex":371},{"text":"[重要] source.decorators","id":"重要-sourcedecorators","depth":2,"charIndex":528},{"text":"[重要] output.targets","id":"重要-outputtargets","depth":2,"charIndex":672},{"text":"[重要] Rspack 配置校验","id":"重要-rspack-配置校验","depth":2,"charIndex":959},{"text":"source.alias","id":"sourcealias","depth":2,"charIndex":1145},{"text":"source.entry","id":"sourceentry","depth":2,"charIndex":1239},{"text":"output.overrideBrowserslist","id":"outputoverridebrowserslist","depth":2,"charIndex":1327},{"text":"output.emitAssets","id":"outputemitassets","depth":2,"charIndex":1451},{"text":"output.distPath.server","id":"outputdistpathserver","depth":2,"charIndex":1555},{"text":"output.minify.html","id":"outputminifyhtml","depth":2,"charIndex":1632},{"text":"output.charset","id":"outputcharset","depth":2,"charIndex":1998},{"text":"dev.startUrl","id":"devstarturl","depth":2,"charIndex":2079},{"text":"dev.client.port","id":"devclientport","depth":2,"charIndex":2130},{"text":"html.appIcon","id":"htmlappicon","depth":2,"charIndex":2216},{"text":"其他","id":"其他","depth":2,"charIndex":2377}],"domain":"","frontmatter":{},"version":""},{"id":336,"title":"Vite","content":"#\n\n本章节介绍如何将 Vite 项目迁移到 Rsbuild。\n\n\n安装依赖#\n\n首先你需要把 Vite 相关的 npm 依赖替换为 Rsbuild 的依赖。\n\n * 移除 Vite 的依赖：\n\n * 安装 Rsbuild 的依赖：\n\n\n更新 npm scripts#\n\n下一步，你需要把 package.json 中的 npm scripts 更新为 Rsbuild 的 CLI 命令。\n\n\n\n\n创建配置文件#\n\n在 package.json 的同级目录下创建 Rsbuild 的配置文件 rsbuild.config.ts，并添加以下内容：\n\n\n\n\n构建入口#\n\nRsbuild 与 Vite 默认的构建入口不同，Vite 使用 index.html 作为默认入口，而 Rsbuild 使用 src/index.js。\n\n从 Vite 迁移到 Rsbuild 时，你可以使用 Rsbuild 提供的 source.entry 来设置构建入口，html.template 来设置模板。\n\n以一个新建的 Vite 项目为例，首先删除 index.html 中的\n\n然后添加如下配置即可。\n\n\n\nRsbuild 会在构建时自动注入","routePath":"/zh/guide/migration/vite","lang":"zh","toc":[{"text":"安装依赖","id":"安装依赖","depth":2,"charIndex":33},{"text":"更新 npm scripts","id":"更新-npm-scripts","depth":2,"charIndex":118},{"text":"创建配置文件","id":"创建配置文件","depth":2,"charIndex":198},{"text":"构建入口","id":"构建入口","depth":2,"charIndex":276},{"text":"迁移插件","id":"迁移插件","depth":2,"charIndex":-1},{"text":"配置迁移","id":"配置迁移","depth":2,"charIndex":-1},{"text":"环境变量","id":"环境变量","depth":2,"charIndex":-1},{"text":"预设类型","id":"预设类型","depth":2,"charIndex":-1},{"text":"Glob Import","id":"glob-import","depth":2,"charIndex":-1},{"text":"验证结果","id":"验证结果","depth":2,"charIndex":-1},{"text":"内容补充","id":"内容补充","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":337,"title":"Vue CLI","content":"#\n\n本章节介绍如何将 Vue CLI 项目迁移到 Rsbuild。\n\n\n安装依赖#\n\n首先你需要把 Vue CLI 的 npm 依赖替换为 Rsbuild 的依赖。\n\n * 移除 Vue CLI 的依赖：\n\n * 安装 Rsbuild 的依赖：\n\nTIP\n\n如果你的项目是基于 Vue 2 的，请将 @rsbuild/plugin-vue 替换为 @rsbuild/plugin-vue2。\n\n\n更新 npm scripts#\n\n下一步，你需要把 package.json 中的 npm scripts 更新为 Rsbuild 的 CLI 命令。\n\n\n\nTIP\n\nRsbuild 未集成 ESLint，因此没有提供用于替换 vue-cli-service lint 的命令，你可以直接使用 ESLint 的 CLI 命令\n作为替代。\n\n\n创建配置文件#\n\n在 package.json 的同级目录下创建 Rsbuild 的配置文件 rsbuild.config.ts，并添加以下内容：\n\n\n\nTIP\n\n如果你的项目是基于 Vue 2 的，请使用 ``。\n\n\nHTML 模板#\n\nVue CLI 默认使用 public/index.html 文件作为 HTML 模板。在 Rsbuild 中，你可以通过 html.template 来指定\nHTML 模板：\n\n\n\n在 HTML 模板中，如果使用了 Vue CLI 的 BASE_URL 变量，请替换为 Rsbuild 的 assetPrefix 变量，并使用斜杠进行连接：\n\n\n\n这样就完成了从 Vue CLI 到 Rsbuild 的基本迁移，此时你可以执行 npm run serve 命令来尝试启动开发服务器。\n\n\n配置迁移#\n\n以下是 Vue CLI 配置对应的 Rsbuild 配置：\n\nVUE CLI                               RSBUILD\npublicPath                            dev.assetPrefix / output.assetPrefix\noutputDir / assetsDir                 output.distPath\nfilenameHashing                       output.filenameHash\npages                                 source.entry / html.template / html.title\ntranspileDependencies                 source.include\nproductionSourceMap / css.sourceMap   output.sourceMap\ncrossorigin                           html.crossorigin\nconfigureWebpack                      tools.rspack\nchainWebpack                          tools.bundlerChain\ncss.extract                           output.injectStyles\ncss.loaderOptions                     tools.cssLoader / less / sass / postcss\ndevServer.proxy                       server.proxy\n\n说明：\n\n * 在迁移 configureWebpack 时，注意大部分 Webpack 和 Rspack 配置是相同的，但也存在一些差异或 Rspack 未实现的功能。\n * 上述表格尚未覆盖到 Vue CLI 的所有配置，欢迎补充。\n\n\n环境变量#\n\nVue CLI 默认会将 VUE_APP_ 开头的环境变量注入到 client 代码中，而 Rsbuild 默认会注入 PUBLIC_ 开头的环境变量（参考\npublic 变量）。\n\n为了兼容 Vue CLI 的行为，你可以手动调用 Rsbuild 提供的 loadEnv 方法来读取 VUE_APP_ 开头的环境变量，并通过\nsource.define 配置项注入到 client 代码中。\n\n\n\n\n内容补充#\n\n当前文档只涵盖了迁移过程的部分事项，如果你发现有合适的内容可以补充，欢迎通过 pull request 来完善文档 🤝。\n\n> Rsbuild 的文档位于 rsbuild/website 目录。","routePath":"/zh/guide/migration/vue-cli","lang":"zh","toc":[{"text":"安装依赖","id":"安装依赖","depth":2,"charIndex":36},{"text":"更新 npm scripts","id":"更新-npm-scripts","depth":2,"charIndex":198},{"text":"创建配置文件","id":"创建配置文件","depth":2,"charIndex":369},{"text":"HTML 模板","id":"html-模板","depth":2,"charIndex":479},{"text":"配置迁移","id":"配置迁移","depth":2,"charIndex":734},{"text":"环境变量","id":"环境变量","depth":2,"charIndex":1665},{"text":"内容补充","id":"内容补充","depth":2,"charIndex":1873}],"domain":"","frontmatter":{},"version":""},{"id":338,"title":"Webpack","content":"#\n\n本章节介绍如何将使用 webpack 的项目迁移到 Rsbuild。\n\n\n安装依赖#\n\n首先你需要把 webpack 相关的 npm 依赖替换为 Rsbuild 的依赖。\n\n * 移除 webpack 的依赖：\n\n * 安装 Rsbuild 的依赖：\n\n\n更新 npm scripts#\n\n下一步，你需要把 package.json 中的 npm scripts 更新为 Rsbuild 的 CLI 命令。\n\n\n\n\n创建配置文件#\n\n在 package.json 的同级目录下创建 Rsbuild 的配置文件 rsbuild.config.ts，并添加以下内容：\n\n\n\n> 查看 配置 Rsbuild 了解更多。\n\n\n配置迁移#\n\n在一个 webpack 项目中，可能已经包含了一些复杂的 webpack.config.js 配置文件。\n\n而迁移到 Rsbuild 后，大部分 webpack 配置已经被 Rsbuild 内置，不再需要手动配置，比如\noutput、resolve、module.rules 等。\n\n对于少部分需要迁移的 webpack 配置，你可以选择以下方案：\n\n * 使用 tools.rspack 选项（Rspack 和 webpack 的配置基本上等价）。\n\n\n\n * 使用 Rsbuild 封装的配置项，比如 css-loader 的选项可以通过 tools.cssLoader 设置。\n\n> 参考 配置 Rspack 了解更多。\n\n\n构建入口#\n\nwebpack 使用 entry 字段来设置构建入口，在 Rsbuild 中你可以使用 source.entry 来设置。\n\n\n\n\n清理配置#\n\n由于 Rsbuild 内置了一些常见的 loader 和 plugin，所以你可以移除以下依赖和相关的配置，这会显著提升项目的依赖安装速度。\n\n * css-loader\n * babel-loader\n * style-loader\n * postcss-loader\n * html-webpack-plugin\n * mini-css-extract-plugin\n * autoprefixer\n * @babel/core\n * @babel/preset-env\n * @babel/preset-typescript\n * @babel/runtime\n * ...\n\nTIP\n\n以上仅列出了一些可以被移除的常见依赖。在一个真实的 webpack 项目中，可能还存在很多其他依赖，请酌情处理。\n\n\n使用插件#\n\nRsbuild 提供了丰富的插件，对常见的使用场景提供开箱即用的支持，你可以参考插件列表文档来了解这些插件。\n\n我们以 React 项目为例，来介绍如何接入 Rsbuild 插件。首先，你可以移除一些 React 相关的构建依赖，它们已经被 Rsbuild React\n插件内置，比如：\n\n * react-refresh\n * @babel/preset-react\n * @pmmmwh/react-refresh-webpack-plugin\n\n然后参考 React 插件 文档，注册并使用即可：\n\n\n\n大部分常见的 webpack loaders 和 plugins 都能在 Rsbuild 中继续使用，但我们推荐你优先使用 Rsbuild\n提供的插件，这能够进一步简化你的配置。下面是它们的映射关系：\n\nWEBPACK                          RSBUILD\n@babel/preset-react              React 插件\nvue-loader                       Vue 插件 或 Vue 2 插件\nsvelte-loader                    Svelte 插件\nbabel-preset-solid               Solid 插件\nbabel-loader                     Babel 插件\nsass-loader                      Sass 插件\nless-loader                      Less 插件\nstylus-loader                    Stylus 插件\nmdx-loader                       MDX 插件\npug-loader                       Pug 插件\nyaml-loader                      Yaml 插件\ntoml-loader                      Toml 插件\n@svgr/webpack                    SVGR 插件\nfork-ts-checker-webpack-plugin   @rsbuild/plugin-type-check\nnode-polyfill-webpack-plugin     Node Polyfill 插件\n@vue/babel-plugin-jsx            Vue JSX 插件\n@vue/babel-preset-jsx            Vue 2 JSX 插件\neslint-webpack-plugin            ESLint 插件\nbabel-plugin-styled-components   Styled Components 插件\n\n\n配置 Dev Server#\n\nRsbuild 不支持使用 Rspack 的 devServer 配置项，请参考 Rspack Dev Server 进行替换。\n\n\n验证结果#\n\n完成以上步骤后，你已经完成了从 webpack 到 Rsbuild 的基本迁移，此时可以执行 npm run dev 命令来尝试启动开发服务器。\n\n如果在构建过程中发现问题，请根据错误日志进行调试，或者查看 webpack 配置，检查是否有一些必须的配置未被迁移到 Rsbuild。\n\n\n内容补充#\n\n当前文档只涵盖了迁移过程的部分事项，如果你发现有合适的内容可以补充，欢迎通过 pull request 来完善文档 🤝。\n\n> Rsbuild 的文档位于 rsbuild/website 目录。","routePath":"/zh/guide/migration/webpack","lang":"zh","toc":[{"text":"安装依赖","id":"安装依赖","depth":2,"charIndex":39},{"text":"更新 npm scripts","id":"更新-npm-scripts","depth":2,"charIndex":130},{"text":"创建配置文件","id":"创建配置文件","depth":2,"charIndex":210},{"text":"配置迁移","id":"配置迁移","depth":2,"charIndex":311},{"text":"构建入口","id":"构建入口","depth":3,"charIndex":634},{"text":"清理配置","id":"清理配置","depth":3,"charIndex":707},{"text":"使用插件","id":"使用插件","depth":3,"charIndex":1070},{"text":"配置 Dev Server","id":"配置-dev-server","depth":3,"charIndex":2322},{"text":"验证结果","id":"验证结果","depth":2,"charIndex":2405},{"text":"内容补充","id":"内容补充","depth":2,"charIndex":2556}],"domain":"","frontmatter":{},"version":""},{"id":339,"title":"提升构建性能","content":"#\n\nRsbuild 默认对构建性能进行了充分优化，但是随着使用场景变复杂、项目代码量变大，你可能会遇到一些构建性能的问题。\n\n本文档提供了一些可选的提速方法，开发者可以根据实际场景选取其中的部分方法，从而进一步提升构建速度。\n\n\n性能分析#\n\n进行构建性能分析可以帮助你确定项目中的性能瓶颈，从而采取针对性的优化。\n\n请参考 构建性能分析 章节了解更多。\n\n\n通用优化#\n\n以下是一些通用的优化方法，对开发模式和生产模式均有提速效果。\n\n\n减少模块#\n\n对应用引用的模块数量进行优化，可以减少产物体积并提升构建性能，请阅读 优化产物体积 章节来了解一些优化方法。\n\n\n开发模式优化#\n\n以下是针对开发构建进行提速的方法。\n\n\n启动 Lazy Compilation#\n\n启用 lazy compilation 可以显著减少开发启动时编译的模块数量，从而提升启动时间。\n\n\n\n> 请参考 dev.lazyCompilation 了解更多。\n\n\nSource Map 格式#\n\n为了提供良好的调试体验，Rsbuild 在开发模式下默认使用 cheap-module-source-map 格式 source map，这是一种高质量的\nsource map 格式，会带来一定的性能开销。\n\n你可以通过 output.sourceMap 调整开发时的 source map 格式，从而提升构建速度。\n\n比如禁用 source map：\n\n\n\n或是把开发模式的 source map 格式设置为开销最小的 eval 格式：\n\n\n\n> 关于不同 source map 格式之间的详细差异，请查看 Rspack - devtool。\n\n\nBrowserslist 范围#\n\n这项优化的原理与「提升 Browserslist 范围」类似，区别在于，我们可以为开发模式和生产模式设置不同的\nbrowserslist，从而减少开发模式下的编译开销。\n\n比如，你可以在 .browserslistrc 中添加以下配置，表示在开发模式下只兼容最新的浏览器，在生产模式下兼容实际需要的浏览器：\n\n\n\n注意，这项优化方法会导致开发模式与生产模式的构建产物存在一定差异。","routePath":"/zh/guide/optimization/build-performance","lang":"zh","toc":[{"text":"性能分析","id":"性能分析","depth":2,"charIndex":115},{"text":"通用优化","id":"通用优化","depth":2,"charIndex":180},{"text":"减少模块","id":"减少模块","depth":3,"charIndex":220},{"text":"开发模式优化","id":"开发模式优化","depth":2,"charIndex":284},{"text":"启动 Lazy Compilation","id":"启动-lazy-compilation","depth":2,"charIndex":313},{"text":"Source Map 格式","id":"source-map-格式","depth":3,"charIndex":421},{"text":"Browserslist 范围","id":"browserslist-范围","depth":3,"charIndex":712}],"domain":"","frontmatter":{},"version":""},{"id":340,"title":"代码拆分","content":"#\n\n良好的拆包策略对于提升应用的加载性能是十分重要的，可以充分利用浏览器的缓存机制，减少请求数量，加快页面加载速度。\n\n在 Rsbuild 中内置了多种拆包策略，可以满足大部分应用的需求，你也可以根据自己的使用场景，自定义拆包配置。\n\n> 参考：Rspack - 代码拆分 了解更多细节。\n\n\n拆包策略#\n\n> Rsbuild 的拆包配置集中在 performance.chunkSplit 中。\n\nRsbuild 支持设置以下几种拆包策略：\n\n * split-by-experience: 根据经验制定的拆分策略，自动将一些常用的 npm 包拆分为体积适中的 chunk。\n * split-by-module: 按 NPM 包的粒度拆分，每个 NPM 包对应一个 chunk。\n * split-by-size：根据模块大小自动进行拆分。\n * all-in-one: 将所有代码全部打包到一个 chunk 中。\n * single-vendor: 将所有 NPM 包的代码打包到一个单独的 chunk 中。\n * custom: 自定义拆包配置。\n\n\nsplit-by-experience#\n\n\n分包策略#\n\nRsbuild 默认采用 split-by-experience 策略，这是我们根据经验制定的策略。具体来说，当你的项目中引用了以下 npm\n包时，它们会自动被拆分为单独的 chunk：\n\n * lib-polyfill.js：包含 core-js，@swc/helpers，tslib。\n * lib-axios.js：包含 axios 以及相关的包。\n\n这种方式将常用的包进行分组，然后拆分为单独的 chunk，有助于浏览器缓存。\n\n\n配置#\n\n\n\n\n注意事项#\n\n * 如果项目中没有安装或引用以上 npm 包，则不会生成相应的 chunk。\n\n\nsplit-by-module#\n\n\n分包策略#\n\n将每一个 NPM 包拆分为一个单独的 chunk。\n\n\n配置#\n\n\n\n\n注意事项#\n\n * 这个配置会最细化地拆分 node_modules，产生大量的文件请求。\n * 在使用 HTTP/2 时，由于存在多路复用，会加快资源的加载时间，并提高缓存命中率。\n * 在未使用 HTTP/2 时，由于 HTTP 队头阻塞问题，会导致页面加载性能下降，请谨慎使用。\n\n\nall-in-one#\n\n\n分包策略#\n\n此分包策略将所有源代码和第三方依赖打包在同一个 chunk 中。\n\n\n配置#\n\n\n\n\n注意事项#\n\n * 这个配置会将构建生成的 JS 代码全部打包到一个文件里（除了 dynamic import 拆分的 chunk）。\n * 单个 JS 文件的体积可能会非常大，使页面加载性能下降。\n\n如果你需要将 dynamic import 拆分的 chunk 也打包到单个文件中，可以将 Rspack 的 output.asyncChunks 选项设置为\nfalse：\n\n\n\n\nsingle-vendor#\n\n\n分包策略#\n\n此分包策略将第三方依赖打包在一个 chunk 中，源代码打包在另外的 chunk 中。\n\n\n配置#\n\n\n\n\n注意事项#\n\n * 单个 vendor 文件的体积可能会非常大，使页面加载性能下降。\n\n\nsplit-by-size#\n\n\n分包策略#\n\n该策略下，设置 minSize、maxSize 为一个固定值后，Rsbuild 会自动进行拆分，无需干预。\n\n\n配置#\n\n\n\n\n自定义拆包#\n\n除了使用内置的拆包策略外，你也可以通过 Rsbuild 自定义拆包功能来满足更多的定制化需求。自定义拆包分为两部分:\n\n * 自定义拆包分组\n * 自定义 Rspack 的 splitChunks 配置\n\n值得注意的是，这两种自定义拆包能力可以和内置的拆包策略一起使用，也就是说，你可以使用内置的拆包策略来拆分常用的包，然后再使用自定义拆包功能来拆分其他的包。\n\n\n自定义分组#\n\nRsbuild 支持自定义拆包分组，这样比内置拆包策略更灵活，同时比手写 Rspack 的 splitChunks 配置更简单。\n\n比如将 node_modules 下的 axios 库拆分到 axios.js 中：\n\n\n\n通过 forceSplitting 配置，你可以很方便把某些模块拆分为一个 chunk。\n\n注意事项#\n\n通过 forceSplitting 配置拆分的 chunk 会通过","routePath":"/zh/guide/optimization/code-splitting","lang":"zh","toc":[{"text":"拆包策略","id":"拆包策略","depth":2,"charIndex":147},{"text":"split-by-experience","id":"split-by-experience","depth":2,"charIndex":480},{"text":"分包策略","id":"分包策略","depth":3,"charIndex":503},{"text":"配置","id":"配置","depth":3,"charIndex":730},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":738},{"text":"split-by-module","id":"split-by-module","depth":2,"charIndex":787},{"text":"分包策略","id":"分包策略-1","depth":3,"charIndex":806},{"text":"配置","id":"配置-1","depth":3,"charIndex":841},{"text":"注意事项","id":"注意事项-1","depth":3,"charIndex":849},{"text":"all-in-one","id":"all-in-one","depth":2,"charIndex":994},{"text":"分包策略","id":"分包策略-2","depth":3,"charIndex":1008},{"text":"配置","id":"配置-2","depth":3,"charIndex":1050},{"text":"注意事项","id":"注意事项-2","depth":3,"charIndex":1058},{"text":"single-vendor","id":"single-vendor","depth":2,"charIndex":1250},{"text":"分包策略","id":"分包策略-3","depth":3,"charIndex":1267},{"text":"配置","id":"配置-3","depth":3,"charIndex":1320},{"text":"注意事项","id":"注意事项-3","depth":3,"charIndex":1328},{"text":"split-by-size","id":"split-by-size","depth":2,"charIndex":1373},{"text":"分包策略","id":"分包策略-4","depth":3,"charIndex":1390},{"text":"配置","id":"配置-4","depth":3,"charIndex":1453},{"text":"自定义拆包","id":"自定义拆包","depth":2,"charIndex":1461},{"text":"自定义分组","id":"自定义分组","depth":3,"charIndex":1652},{"text":"注意事项","id":"注意事项-4","depth":4,"charIndex":1818},{"text":"自定义拆包配置","id":"自定义拆包配置","depth":3,"charIndex":-1},{"text":"使用 Dynamic Import 拆包","id":"使用-dynamic-import-拆包","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":341,"title":"静态资源内联","content":"#\n\n静态资源内联是一种优化网页性能的方法，它指的是将静态资源直接内联到 HTML 或 JS\n文件中，而不是使用外部文件引用的方式。这样做的好处是减少了浏览器发起的请求数，从而提高页面的加载速度。\n\n不过，静态资源内联也有一些缺点，比如增加了单个文件的体积，可能会导致加载变慢。所以在实际应用中，需要根据具体情况来决定是否使用静态资源内联。\n\nRsbuild 默认会自动内联体积小于 4KiB\n的静态资源，但有时候你可能需要手动控制某些特殊资源，让其强制内联或者强制不内联，这篇文档阐述了如何进行精确地控制静态资源内联行为。\n\n\n自动内联#\n\n默认情况下，当图片、字体、媒体等类型的文件体积小于阈值（默认为 4KiB）时，Rsbuild 会将资源进行内联处理，资源内联后，会被转换成一个 Base64\n编码的字符串，不再会发送独立的 HTTP 请求。当文件体积大于或等于该阈值时，则会被作为单独的资源文件，通过独立的 HTTP 请求来加载。\n\n自动内联的体积阈值可以通过 output.dataUriLimit 配置项修改。例如，修改图片资源的阈值为 5000 字节，设置视频资源不内联：\n\n\n\n\n强制内联#\n\n你可以通过在引入资源时添加 inline URL 参数来强制内联该资源，无论该资源的体积是否小于阈值。\n\n\n\n在上面这个例子中，foo.png 图片将始终被内联，无论该图片的大小是否大于阈值。\n\n\n从 CSS 文件中引用#\n\n当你在 CSS 文件中引用静态资源时，同样可以通过 inline 参数来强制内联资源。\n\n\n\n你真的需要强制内联吗？\n\n内联体积过大的资源时，会显著增加页面的白屏时间或首次可交互时间，这会损害用户体验。并且当你将一个静态资源多次内联到 CSS 文件中时，base64\n内容会重复注入，导致产物体积增大。因此，请酌情使用强制内联。\n\n\n强制不内联#\n\n当你想把一些资源始终作为单独的资源文件来处理，无论该资源的体积多小时，你可以添加 url URL 参数来强制不内联该资源。\n\n\n\n在上面这个例子中，foo.png 图片将始终通过单独的资源文件加载，无论该图片的大小是否小于阈值。\n\n\n从 CSS 文件中引用#\n\n当你在 CSS 文件中引用静态资源时，同样可以通过 url 参数来强制不内联资源。\n\n\n\n你真的需要把资源排除内联吗？\n\n将资源排除内联将增加 Web App 需要加载的资源数量，这对于弱网环境，或是未开启 HTTP2 的场景下，将会降低资源加载效率，因此，请酌情使用强制不内联。\n\n\n内联 JS 文件#\n\n除了将静态资源文件内联到 JS 文件里，Rsbuild 也支持将 JS 文件内联到 HTML 文件中。\n\n只需要开启 output.inlineScripts 配置项，构建生成的 JS 文件将不会被写入产物目录下，而是会直接内联到对应的 HTML 文件中。\n\n\n\nTIP\n\n内联 JS 文件可能会导致 HTML 单文件体积过大，并且不利于静态资源缓存，请酌情使用。\n\n\n内联 CSS 文件#\n\n你也可以将 CSS 文件内联到 HTML 文件中。\n\n只需要开启 output.inlineStyles 配置项，构建生成的 CSS 文件将不会被写入产物目录下，而是会直接内联到对应的 HTML 文件中。\n\n\n\n\n类型声明#\n\n当你在 TypeScript 代码中使用 ?inline 和 ?url 等 URL 参数时，TypeScript 可能会提示该模块缺少类型定义：\n\n\n\n此时你需要为这些 URL 参数添加类型声明，请在项目中创建 src/env.d.ts 文件，并添加类型声明。\n\n * 方法一：如果项目里安装了 @rsbuild/core 包，你可以直接引用 @rsbuild/core 提供的 预设类型：\n\n\n\n * 方法二：手动添加需要的类型声明：\n\n","routePath":"/zh/guide/optimization/inline-assets","lang":"zh","toc":[{"text":"自动内联","id":"自动内联","depth":2,"charIndex":264},{"text":"强制内联","id":"强制内联","depth":2,"charIndex":498},{"text":"从 CSS 文件中引用","id":"从-css-文件中引用","depth":3,"charIndex":604},{"text":"强制不内联","id":"强制不内联","depth":2,"charIndex":785},{"text":"从 CSS 文件中引用","id":"从-css-文件中引用-1","depth":3,"charIndex":910},{"text":"内联 JS 文件","id":"内联-js-文件","depth":2,"charIndex":1067},{"text":"内联 CSS 文件","id":"内联-css-文件","depth":2,"charIndex":1263},{"text":"类型声明","id":"类型声明","depth":2,"charIndex":1382}],"domain":"","frontmatter":{},"version":""},{"id":342,"title":"产物体积优化","content":"#\n\n产物体积的优化在生产环境中是非常重要的，因为它直接影响到了线上的用户体验。在这篇文档中，我们将介绍在 Rsbuild 中一些常见的产物体积优化方式。\n\n\n减少重复依赖#\n\n在 Web 项目中，经常出现某些第三方依赖被打包了多个版本的现象。重复依赖会导致包体积变大、构建速度变慢。\n\n\n检测重复依赖#\n\n你可以使用 Rsdoctor 来检测项目中是否存在重复依赖，Rsdoctor 会在构建过程中进行分析，找出所有重复打包的依赖包，并可视化展示出来：\n\n\n\n详见 Rsdoctor - 重复依赖问题。\n\n\n消除重复依赖#\n\n我们可以通过一些配置项和工具来检测或消除重复依赖。\n\n * Rsbuild 提供了 resolve.dedupe 配置项，它允许你强制从项目根目录解析指定的包，从而移除重复包。\n\n * 如果你在使用 pnpm >= 7.26.0，可以使用 pnpm 自带的 pnpm dedupe 命令来升级和消除其中的重复依赖。\n\n\n\n * 如果你在使用 pnpm < 7.26.0 版本，可以使用 pnpm-deduplicate 来分析出所有的重复依赖，并通过升级依赖或声明 pnpm\n   overrides 进行版本合并。\n\n\n\n * 如果你在使用 yarn，可以使用 yarn-deduplicate 来自动合并重复依赖：\n\n\n\n\n使用更轻量的库#\n\n建议将项目中体积较大的三方库替换为更轻量的库，比如将 moment 替换为 day.js。\n\n如果你需要找出项目中体积较大的三方库，可以在执行构建时添加 BUNDLE_ANALYZE=true 环境变量：\n\n\n\n详见 performance.bundleAnalyze 配置项。\n\n\n提升 Browserslist 范围#\n\nRsbuild 会根据项目的 Browserslist 配置范围进行代码编译，并注入相应的\nPolyfill。如果项目不需要兼容旧版浏览器，可以根据实际情况来提升 Browserslist 范围，从而减少在语法和 Polyfill 上的编译开销。\n\nRsbuild 默认的 Browserslist 配置为：\n\n\n\n比如只兼容 Chrome 100 以上的浏览器，可以改成：\n\n\n\nTIP\n\n请阅读 设置浏览器范围 章节来了解更多关于 Browserslist 的用法。\n\n\n按需引入 polyfill#\n\n如果当前项目的 output.polyfill 为 'entry'，在明确第三方依赖不需要额外 polyfill 的情况下，你可以将它设置为 usage 。\n\n在 usage 模式下，Rsbuild 会分析源代码中使用的语法，按需注入所需的 polyfill 代码，从而减少 polyfill 的代码量。\n\n\n\nTIP\n\n请阅读 浏览器兼容性 章节来了解更多关于 polyfill 的用法。\n\n\n使用图片压缩#\n\n在一般的前端项目中，图片资源的体积往往是项目产物体积的大头，因此如果能尽可能精简图片的体积，那么将会对项目的打包产物体积起到明显的优化效果。你可以在\nRsbuild 中注册插件来启用图片压缩功能:\n\n\n\n详见 @rsbuild/plugin-image-compress。\n\n\n代码拆包#\n\n良好的拆包策略对于提升应用的加载性能是十分重要的，可以充分利用浏览器的缓存机制，减少请求数量，加快页面加载速度。\n\n在 Rsbuild 中内置了多种拆包策略，可以满足大部分应用的需求，你也可以根据自己的使用场景，自定义拆包配置。\n\n比如将 node_modules 下的 axios 库拆分到 axios.js 中：\n\n","routePath":"/zh/guide/optimization/optimize-bundle","lang":"zh","toc":[{"text":"减少重复依赖","id":"减少重复依赖","depth":2,"charIndex":79},{"text":"检测重复依赖","id":"检测重复依赖","depth":3,"charIndex":144},{"text":"消除重复依赖","id":"消除重复依赖","depth":3,"charIndex":254},{"text":"使用更轻量的库","id":"使用更轻量的库","depth":2,"charIndex":577},{"text":"提升 Browserslist 范围","id":"提升-browserslist-范围","depth":2,"charIndex":729},{"text":"按需引入 polyfill","id":"按需引入-polyfill","depth":2,"charIndex":988},{"text":"使用图片压缩","id":"使用图片压缩","depth":2,"charIndex":1202},{"text":"代码拆包","id":"代码拆包","depth":2,"charIndex":1350}],"domain":"","frontmatter":{},"version":""},{"id":343,"title":"功能导航","content":"#\n\n在这里，你可以了解到 Rsbuild 支持的主要功能。\n\n\nJavaScript 编译#\n\n功能              描述                                               相关链接\nRspack 打包       默认使用 Rspack 作为打包工具                               -\nSWC 编译          默认通过 SWC 对 JavaScript 和 TypeScript 代码进行转译和压缩     -\nTS 编译           默认通过 SWC 编译 TS 文件                                \n代码压缩            默认在生产模式构建时开启代码压缩                                 \nPolyfill 注入     默认会注入 core-js 等 Polyfill                         \nSourceMap 生成    默认在开发模式生成 SourceMap                              \n文件别名            可选功能，通过 alias 设置文件别名                             \nBabel 编译        可选功能，通过 Babel 对 JavaScript 和 TypeScript 代码进行转译   \nNode 产物         可选功能，支持构建出运行在 Node.js 环境的 JavaScript 产物          \nWeb Worker 产物   可选功能，支持构建出运行在 Web Worker 环境的 JavaScript 产物       \n浏览器范围           可选功能，通过 browserslist 来设置 Web 应用需要兼容的浏览器范围        \n兼容性检查           可选功能，分析构建产物中是否存在当前浏览器范围下不兼容的高级语法                 \n注入环境变量          可选功能，向代码中注入环境变量或表达式                              \nNode polyfill   可选功能，在浏览器端注入 Node 核心模块的 polyfills                \nTS 类型检查         可选功能，运行 type checker 检查代码中的类型问题                  \n模块联邦            可选功能，动态加载模块，并共享依赖关系                              \n\n\nCSS 编译#\n\n功能                 描述                                相关链接\nLightning CSS      默认启用，使用 Lightning CSS 降级 CSS 语法   \nPostCSS 转换         可选功能，开启 PostCSS 转换                \nSass 预处理器          可选功能，编译 Sass/Scss 文件              \nLess 预处理器          可选功能，编译 Less 文件                   \nStylus 预处理器        可选功能，编译 Stylus 文件                 \nCSS Modules 编译     默认支持编译 CSS Modules 文件             \nCSS Modules 类型提示   可选功能，生成 CSS Modules 的类型定义文件       \nCSS 压缩             默认在生产模式构建时开启 CSS 压缩               \n内联 CSS 到 JS 中      可选功能，将 CSS 文件内联到 JS 文件中           \n\n\nHTML 编译#\n\n功能            描述                       相关链接\n设置标题          设置 HTML 的 title 标签       \n设置 meta       设置 HTML 的 meta 标签        \n设置 favicon    设置页面的 favicon 图标         \n设置 app 图标     设置 iOS 系统下的 apple icon   \n使用 EJS 模板引擎   可选功能，使用 EJS 模板语法         \n使用 Pug 模板引擎   可选功能，使用 Pug 模板语法         \n内联 JS 文件      可选功能，将 JS 内联到 HTML 中     \n内联 CSS 文件     可选功能，将 CSS 内联到 HTML 中    \n\n\n开发预览相关#\n\n功能          描述                             相关链接\nPublic 目录   默认将 public 目录作为静态资源服务的文件夹      \n请求代理        可选功能，将请求代理到指定的服务上              \n打开页面        可选功能，在启动 server 时自动在浏览器中打开页面   \nHTTPS       可选功能，开启 server 对 HTTPS 的支持     \n\n\n框架支持#\n\n功能              描述                          相关链接\nReact           可选功能，开启 React JSX 语法编译      \nReact Refresh   可选功能，开启 React Refresh 热更新   \nSVGR            可选功能，转换 SVG 为 React 组件      \nVue 3 SFC       可选功能，开启 Vue 3 SFC 单文件组件编译   \nVue 3 JSX       可选功能，开启 Vue 3 JSX 语法编译      \nVue 2 SFC       可选功能，开启 Vue 2 SFC 单文件组件编译   \nVue 2 JSX       可选功能，开启 Vue 2 JSX 语法编译      \nSvelte          可选功能，开启 Svelte 组件编译         \nSolid           可选功能，开启 Solid JSX 语法编译      \n\n\n静态资源相关#\n\n功能               描述                           相关链接\n引用图片资源           支持在代码中引用图片资源                 \n引用字体资源           支持在代码中引用字体资源                 \n引用视频资源           支持在代码中引用视频资源                 \n引用 Wasm 资源       支持在代码中引用 WebAssembly 资源      \n引用 node addons   支持在代码中引用 Node.js addons      \n静态资源内联           默认将体积较小的图片等资源内联到 JS 中        \n清理静态资源           每次开始构建前，自动清理 dist 目录下的静态资源   \n拷贝静态资源           可选功能，将静态资源拷贝到 dist 目录下       \n\n\n性能相关#\n\n功能                描述                                    相关链接\n代码拆分              Rsbuild 中内置了多种拆包策略，自动将代码包拆分为体积适中的文件   \n展示产物体积            在生产模式构建后，默认展示所有静态资源的体积信息              \n分析产物体积            可选功能，通过 Bundle Analyzer 分析产物体积        \n移除 console        可选功能，移除代码中的 console.[methodName]      \n优化 moment.js 体积   可选功能，移除 moment.js 多余的 locale 文件       \n组件库按需引入           可选功能，按需引入组件库的代码和样式                    \n图片压缩              可选功能，对引用的图片资源进行压缩处理                   \nPreload           可选功能，对资源进行预加载                         \nPrefetch          可选功能，对资源进行预获取                         \nPreconnect        可选功能，对资源进行预连接                         \nDNS prefetch      可选功能，对资源进行 DNS 预获取                    ","routePath":"/zh/guide/start/features","lang":"zh","toc":[{"text":"JavaScript 编译","id":"javascript-编译","depth":2,"charIndex":32},{"text":"CSS 编译","id":"css-编译","depth":2,"charIndex":1178},{"text":"HTML 编译","id":"html-编译","depth":2,"charIndex":1733},{"text":"开发预览相关","id":"开发预览相关","depth":2,"charIndex":2109},{"text":"框架支持","id":"框架支持","depth":2,"charIndex":2344},{"text":"静态资源相关","id":"静态资源相关","depth":2,"charIndex":2807},{"text":"性能相关","id":"性能相关","depth":2,"charIndex":3245}],"domain":"","frontmatter":{},"version":""},{"id":344,"title":"名词解释","content":"#\n\n\nBundler#\n\n指 Rspack、webpack 等模块打包工具。\n\n打包工具的主要目标是将 JavaScript、CSS 等文件打包在一起，打包后的文件可以在浏览器、Node.js 等环境中使用。当 Bundler 处理 Web\n应用时，它会构建一个依赖关系图，其中包含应用需要的各个模块，然后将所有模块打包成一个或多个 bundle。\n\n\nCSR#\n\nCSR 是 \"Client-Side Rendering\"（客户端渲染）的缩写。它表示页面是在浏览器中通过 JavaScript\n渲染的，数据获取、模板和路由等逻辑都在浏览器端完成，而不是在服务器上。\n\n在 CSR 中，服务器会向浏览器端发送一个空的 HTML 外壳和一些 JavaScript 脚本，然后由浏览器端从服务器的 API\n中拉取数据，并将动态内容渲染到页面中。\n\n\nEnvironment#\n\nenvironment 指的是构建产物的运行环境，详见 多环境构建。\n\n\nMicro-frontend#\n\n微前端（Micro-frontend，简称\nMFE）是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，它将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户\n看来仍然是内聚的单个产品。\n\n它主要解决了两个问题：\n\n * 随着项目迭代应用越来越庞大，难以维护。\n * 跨团队或跨部门协作开发项目导致效率低下的问题。\n\n\nModern.js#\n\nModern.js 是一个基于 Rsbuild 实现的渐进式 Web 开发框架。\n\n\nModule Federation#\n\nModule Federation 是一种 JavaScript 应用分治的架构模式（类似于服务端的微服务），它允许你在多个 JavaScript\n应用程序（或微前端）之间共享代码和资源。\n\n详见 模块联邦。\n\n\nRspack#\n\nRspack 是一个基于 Rust 编写的高性能 JavaScript 打包工具， 它提供对 webpack 生态良好的兼容性，能够无缝替换 webpack，\n并提供闪电般的构建速度。\n\n\nRspress#\n\nRspress 是一个基于 Rsbuild 的静态站点生成器。\n\n\nSSR#\n\nSSR 是 \"Server-Side Rendering\"（服务端渲染）的缩写。它表示由服务器生成网页的 HTML，并将其发送给客户端，而不是只发送一个空的\nHTML 外壳，并依赖 JavaScript 来生成页面内容。\n\n详见 服务端渲染（SSR）。\n\n\nSWC#\n\nSWC (Speedy Web Compiler) 是基于 Rust 语言编写的高性能 JavaScript 和 TypeScript 转译和压缩工具。\n\n详见 配置 SWC。\n\n\n更多#\n\n访问 Rspack - 术语表 查看更多名词解释。","routePath":"/zh/guide/start/glossary","lang":"zh","toc":[{"text":"Bundler","id":"bundler","depth":2,"charIndex":3},{"text":"CSR","id":"csr","depth":2,"charIndex":177},{"text":"Environment","id":"environment","depth":2,"charIndex":373},{"text":"Micro-frontend","id":"micro-frontend","depth":2,"charIndex":424},{"text":"Modern.js","id":"modernjs","depth":2,"charIndex":624},{"text":"Module Federation","id":"module-federation","depth":2,"charIndex":679},{"text":"Rspack","id":"rspack","depth":2,"charIndex":806},{"text":"Rspress","id":"rspress","depth":2,"charIndex":910},{"text":"SSR","id":"ssr","depth":2,"charIndex":954},{"text":"SWC","id":"swc","depth":2,"charIndex":1089},{"text":"更多","id":"更多","depth":2,"charIndex":1186}],"domain":"","frontmatter":{},"version":""},{"id":345,"title":"介绍","content":"#\n\nRsbuild 是由 Rspack 驱动的高性能构建工具，它默认包含了一套精心设计的构建配置，提供开箱即用的开发体验，并能够充分发挥出 Rspack\n的性能优势。\n\nRsbuild 提供 丰富的构建功能，包括编译 TypeScript、JSX、Sass、Less、CSS\nModules、Wasm，以及其他资源，也支持模块联邦、图片压缩、类型检查、PostCSS、Lightning CSS 等功能。\n\n\n💡 对比其他工具#\n\nRsbuild 是与 Vite、Create React App 或 Vue CLI\n相似的构建工具，它们都默认包含了开发服务器、命令行工具和合理的构建配置，以此来提供开箱即用的体验。\n\n\n\n\nCRA / Vue CLI#\n\n你可以将 Rsbuild 理解为一个现代化的 Create React App 或 Vue CLI，它与这些工具的主要区别在于：\n\n * 底层的打包工具由 Webpack 替换为 Rspack，提供 5 ~ 10 倍的构建性能。\n * 与前端 UI 框架解耦，并通过 插件 来支持所有 UI 框架，包括 React、Vue、Svelte、Solid 等。\n * 提供更好的扩展性，你可以通过 配置、 插件 API 和 JavaScript API 来灵活地扩展 Rsbuild。\n\n\nVite#\n\nRsbuild 与 Vite 有许多相似之处，它们皆致力于提升前端的开发体验。其主要区别在于：\n\n * 生产一致性：Rsbuild 在开发阶段和生产构建均使用 Rspack 进行打包，因此开发和生产构建的产物具备强一致性。而 Vite 在开发阶段使用 ESM\n   加载模块，这虽然提升了启动速度，但开发和生产构建的产物容易出现不一致。\n * 生态兼容性：Rsbuild 兼容大部分的 webpack 插件和所有 Rspack 插件，而 Vite 则是兼容 Rollup\n   插件。如果你目前更多地使用了 webpack 生态的插件和 loaders，那么迁移到 Rsbuild 会更容易。\n * 模块联邦：Rsbuild 团队与 Module Federation 的开发团队密切合作，并为 Module Federation\n   提供一流的支持，帮助你开发微前端架构的大型 Web 应用。\n\n\n🚀 性能#\n\nRsbuild 能够充分发挥 Rspack 的性能优势，以下是构建 1000 个 React 组件的时间：\n\n> 以上数据来自 performance-compare benchmark。\n\n\n🔥 特性#\n\nRsbuild 具备以下特性：\n\n * 易于配置：Rsbuild 的目标之一，是为 Rspack 用户提供开箱即用的构建能力，使开发者能够在零配置的情况下开发 web 项目。同时，Rsbuild\n   提供一套语义化的构建配置，以降低 Rspack 配置的学习成本。\n\n * 性能优先：Rsbuild 集成了社区中基于 Rust 的高性能工具，包括 Rspack、SWC 和 Lightning\n   CSS，以提供一流的构建速度和开发体验。\n\n * 插件生态：Rsbuild 内置一个轻量级的插件系统，提供一系列高质量的官方插件。此外，Rsbuild 兼容大部分的 webpack 插件和所有的\n   Rspack 插件，这意味着你可以在 Rsbuild 中使用社区或公司内现有的插件，而无须重写相关代码。\n\n * 产物稳定：Rsbuild 设计时充分考虑了构建产物的稳定性，它的开发和生产构建产物具备较强的一致性，并自动完成语法降级和 polyfill\n   注入。Rsbuild 也提供插件来进行类型检查和产物语法检查，以避免线上代码的质量问题和兼容性问题。\n\n * 框架无关：Rsbuild 不与前端 UI 框架耦合，并通过插件来支持 React、Vue、Svelte、Solid、Preact\n   等框架，未来也计划支持社区中更多的 UI 框架。\n\n\n🎯 生态#\n\nRsbuild 为上层的框架和工具提供了 JavaScript API 和 plugin API。例如，我们基于 Rsbuild 实现了 Rspress 和\nRslib，并充分复用 Rsbuild 的能力和生态。\n\n下图说明了 Rsbuild 与生态中其他工具之间的关系：\n\n\n\n\n🦀 链接#\n\n * Rspack：基于 Rust 的高性能打包工具。\n * Rspress：基于 Rsbuild 的静态站点生成器。\n * Rsdoctor：针对 Rspack 和 webpack 的一站式构建分析工具。\n * Rslib: 基于 Rsbuild 的 library 开发工具。\n * Modern.js：基于 Rsbuild 的渐进式 React 框架。\n * awesome-rspack：与 Rspack 和 Rsbuild 相关的精彩内容列表。\n * rspack-examples：Rspack、Rsbuild、Rspress 和 Rsdoctor 的示例项目。\n * storybook-rsbuild: 基于 Rsbuild 构建的 Storybook。\n * rsbuild-plugin-template：使用此模板创建你的 Rsbuild 插件。\n * rstack-design-resources：Rspack、Rsbuild、Rspress 和 Rsdoctor 的设计资源。\n\n\n🧑‍💻 社区#\n\n欢迎加入我们的 Discord 交流频道！Rspack / Rsbuild 团队和用户都在那里活跃，并且我们一直期待着各种贡献。\n\n你也可以加入 飞书群 与大家一起交流。\n\n\n✨ 下一步#\n\n你可能想要：","routePath":"/zh/guide/start/","lang":"zh","toc":[{"text":"💡 对比其他工具","id":"-对比其他工具","depth":2,"charIndex":205},{"text":"CRA / Vue CLI","id":"cra--vue-cli","depth":3,"charIndex":314},{"text":"Vite","id":"vite","depth":3,"charIndex":572},{"text":"🚀 性能","id":"-性能","depth":2,"charIndex":980},{"text":"🔥 特性","id":"-特性","depth":2,"charIndex":1085},{"text":"🎯 生态","id":"-生态","depth":2,"charIndex":1675},{"text":"🦀 链接","id":"-链接","depth":2,"charIndex":1824},{"text":"🧑‍💻 社区","id":"-社区","depth":2,"charIndex":2287},{"text":"✨ 下一步","id":"-下一步","depth":2,"charIndex":2386}],"domain":"","frontmatter":{},"version":""},{"id":346,"title":"快速上手","content":"#\n\n\n在线示例#\n\n我们提供了基于 Rsbuild 的在线示例，通过示例项目，你可以直观感受 Rspack 的构建性能和 Rsbuild 的开发体验：\n\n * Rsbuild CodeSandbox 示例\n\n你也可以使用 豆包 MarsCode 快速创建一个在线的 Rsbuild 项目：\n\n 1. 访问 MarsCode - Rsbuild 模板。\n 2. 登录，点击右上角的「使用模板」按钮即可。\n\n\n环境准备#\n\nRsbuild 支持使用 Node.js、Deno 或 Bun 作为运行时。\n\n\nNode.js#\n\n对于 Node.js，请安装 Node.js >= 16 版本，推荐使用 Node.js LTS 版本。\n\n通过以下命令检查当前使用的 Node.js 版本：\n\n\n\n如果你的环境中尚未安装 Node.js，或是版本过低，可以通过 nvm 或 fnm 安装。\n\n下面是通过 nvm 安装的例子：\n\n\n\n\n创建 Rsbuild 项目#\n\n你可以使用 create-rsbuild 来创建一个 Rsbuild 项目，调用以下命令：\n\n然后按照提示操作即可。\n\n\n模板#\n\n在创建项目时，你可以选择 create-rsbuild 提供的下列模板：\n\n模板        描述              可选功能\nvanilla   原生 JavaScript   TypeScript\nreact     React 19        TypeScript\nvue3      Vue 3           TypeScript\nvue2      Vue 2           TypeScript\nlit       Lit             TypeScript\npreact    Preact          TypeScript\nsvelte    Svelte 5        TypeScript\nsolid     Solid           TypeScript\n\n\n可选工具#\n\ncreate-rsbuild 能够帮助你设置一些常用的工具，包括 Biome、ESLint 和\nprettier，你可以使用上下箭头和空格进行选择。如果你不需要这些工具，可以直接按回车跳过。\n\n\n\nTIP\n\nBiome 提供与 ESLint 和 Prettier 相似的代码检查和格式化功能。如果你选择了 Biome，通常就不需要再选择 ESLint 或\nPrettier 了。\n\n\n当前目录#\n\n如果你需要在当前目录下创建项目，可以将 target folder 设置为 .：\n\n\n\n\n快速创建#\n\ncreate-rsbuild 提供了一些 CLI 选项。通过设置这些 CLI 选项，你可以跳过交互式的选择步骤，一键创建项目。\n\n比如，一键创建 React 项目到 my-project 目录：\n\n\n\ncreate-rsbuild 完整的 CLI 选项如下：\n\n\n\n\n从现有项目迁移#\n\n如果你需要从一个现有项目迁移迁移到 Rsbuild，可以参考以下指南：\n\n * 从 webpack 迁移\n * 从 Create React App 迁移\n * 从 Vue CLI 迁移\n * 从 Vite 迁移\n * 从 Modern.js Builder 迁移\n\n\n其他项目#\n\n对于其他类型的项目，你可以手动安装 @rsbuild/core 包：\n\n然后参考指南和文档，按需启用各个功能：\n\n * 参考 CLI 工具 来了解可用的 CLI 命令。\n * 参考 插件列表 来选择 Rsbuild 插件。\n * 参考 配置 Rsbuild 进行配置。\n\n\n命令行工具#\n\nRsbuild 内置了一个轻量的命令行工具，包含 dev、build 等命令。\n\n\n\n请参考 CLI 工具 来了解所有可用的命令以及选项。\n\n\n入口模块#\n\nRsbuild CLI 默认会使用 src/index.(js|ts|jsx|tsx) 作为入口模块，你可以使用 source.entry\n配置项来修改入口模块。\n\n\n核心 npm 包#\n\n\n@rsbuild/core#\n\nRsbuild 核心包，提供 CLI 命令和 JavaScript API。\n\n\ncreate-rsbuild#\n\n用于创建 Rsbuild 新项目。\n\n\n下一步#\n\n你可能想要：","routePath":"/zh/guide/start/quick-start","lang":"zh","toc":[{"text":"在线示例","id":"在线示例","depth":2,"charIndex":3},{"text":"环境准备","id":"环境准备","depth":2,"charIndex":203},{"text":"Node.js","id":"nodejs","depth":3,"charIndex":251},{"text":"创建 Rsbuild 项目","id":"创建-rsbuild-项目","depth":2,"charIndex":412},{"text":"模板","id":"模板","depth":3,"charIndex":489},{"text":"可选工具","id":"可选工具","depth":3,"charIndex":861},{"text":"当前目录","id":"当前目录","depth":3,"charIndex":1060},{"text":"快速创建","id":"快速创建","depth":3,"charIndex":1112},{"text":"从现有项目迁移","id":"从现有项目迁移","depth":2,"charIndex":1253},{"text":"其他项目","id":"其他项目","depth":3,"charIndex":1398},{"text":"命令行工具","id":"命令行工具","depth":2,"charIndex":1542},{"text":"入口模块","id":"入口模块","depth":2,"charIndex":1622},{"text":"核心 npm 包","id":"核心-npm-包","depth":2,"charIndex":1713},{"text":"@rsbuild/core","id":"rsbuildcore","depth":3,"charIndex":1725},{"text":"create-rsbuild","id":"create-rsbuild","depth":3,"charIndex":1782},{"text":"下一步","id":"下一步","depth":2,"charIndex":1819}],"domain":"","frontmatter":{},"version":""},{"id":348,"title":"Plugin Core","content":"#\n\n本章节描述了 Rsbuild 插件核心的类型定义和 API。\n\n\nRsbuildPlugin#\n\n插件对象的类型，插件对象包含以下属性：\n\n * name：插件的名称，唯一标识符。\n * setup：插件逻辑的主入口函数，可以是一个异步函数。该函数仅会在初始化插件时执行一次。插件 API\n   对象上挂载了提供给插件使用的上下文数据、工具函数和注册生命周期钩子的函数，关于生命周期钩子的完整介绍，请阅读 Plugin Hooks 章节。\n * pre：声明前置插件的名称，这些插件会在当前插件之前执行。\n * post：声明后置插件的名称，这些插件会在当前插件之后执行。\n * remove：声明需要移除的插件，可以传入插件 name 的数组。\n\n\n\n你可以从 @rsbuild/core 中导入该类型：\n\n\n\n\n前置插件#\n\n默认情况下，插件会按照添加顺序依次执行，通过 pre 字段可以声明前置执行的插件。\n\n比如有下面两个插件：\n\n\n\nBar 插件在 pre 字段中配置了 Foo 插件，因此 Foo 插件一定会在 Bar 插件之前执行。\n\n\n后置插件#\n\n同样的，通过 post 字段可以声明后置执行的插件。\n\n\n\nBar 插件在 post 字段中配置了 Foo 插件，因此 Foo 插件一定会在 Bar 插件之后执行。\n\n\n移除插件#\n\n通过 remove 字段可以在一个插件中移除其他插件。\n\n\n\n比如同时注册上述的 Foo 和 Bar 插件，由于 Bar 插件声明 remove 了 Foo 插件，因此 Foo 插件不会生效。\n\n需要注意的是：如果当前插件注册为特定环境插件，则仅支持移除同环境插件，不能移除全局插件。\n\n\napi.context#\n\napi.context 是一个只读对象，提供一些上下文信息。\n\napi.context 的内容与 rsbuild.context 完全一致，请参考 rsbuild.context。\n\n * 示例：\n\n\n\n\napi.getRsbuildConfig#\n\n * 示例：\n\n\n\n\napi.getNormalizedConfig#\n\n * 示例：\n\n\n\n\napi.isPluginExists#\n\n * 示例：\n\n\n\n\napi.transform#\n\n用于转换模块的代码。\n\n * 类型：\n\n\n\napi.transform 接受两个参数：\n\n * descriptor：一个对象，用于描述模块的匹配条件。\n * handler：一个转换函数，接收模块当前的代码，并返回转换后的代码。\n\n\n示例#\n\n比如匹配以 .pug 为后缀的模块，并转换为 JavaScript 代码：\n\n\n\n\ndescriptor 参数#\n\ndescriptor 参数是一个对象，用于描述模块的匹配条件。\n\n * 类型：\n\n\n\ndescriptor 参数支持设置以下匹配条件：\n\n * test：匹配模块的路径（不包含 query），等价于 Rspack 的 Rule.test。\n\n\n\n * targets：匹配 Rsbuild output.target，仅对匹配的 targets 应用当前 transform 函数。\n\n\n\n * environments：匹配 Rsbuild environment name，仅对匹配的 environments 应用当前 transform\n   函数。\n\n\n\n * resourceQuery：匹配模块的 query，等价于 Rspack 的 Rule.resourceQuery。\n\n\n\n * raw：如果 raw 为 true，则 transform 函数将接收到 Buffer 类型的代码，而不是 string 类型。\n\n\n\n * layer：等同于 Rspack 的 Rule.layer。\n * issuerLayer：等同于 Rspack 的 Rule.issuerLayer。\n\n\nhandler 参数#\n\nhandler 参数是一个转换函数，接收模块当前的代码，并返回转换后的代码。\n\n * 类型：\n\n\n\nhandler 函数提供以下参数：\n\n * code：模块的代码。\n * resource：模块的绝对路径，包含 query。\n * resourcePath：模块的绝对路径，不包含 query。\n * resourceQuery：模块路径上的 query。\n * environment: 当前构建的 environment 上下文.\n * addDependency：添加一个额外的文件作为依赖。该文件将被监听，并在发生变更时触发重新构建。与 Rspack loader 的\n   this.addDependency 相同。\n * emitFile：将一个文件输出到构建结果中。与 Rspack loader 的 this.emitFile 相同。\n\n比如：\n\n\n\n\n与 loader 的区别#\n\napi.transform 可以理解为 Rspack loader 的一个轻量化实现，它提供了简单易用的 API，并在底层自动调用 Rspack loader\n进行代码转换。\n\n在 Rsbuild 插件中，你可以通过 api.transform 快速实现代码转换功能，能够满足大部分常见场景，而无须学习 Rspack loader\n的编写方法。\n\n注意，对于一些复杂的代码转换场景，api.transform 可能无法满足，此时你可以使用 Rspack loader 进行实现。\n\n\napi.resolve#\n\n在模块解析开始之前，拦截并修改模块的请求信息。等价于 Rspack 的 normalModuleFactory.hooks.resolve hook。\n\n * 版本： >= 1.0.17\n * 类型：\n\n\n\n\n示例#\n\n * 修改 a.js 文件请求：\n\n\n\n\nhandler 参数#\n\nhandler 参数是一个回调函数，接收一个模块的请求信息，并允许你修改它。\n\n * 类型：\n\n\n\nhandler 函数提供以下参数：\n\n * resolveData：当前模块请求信息，详情可参考 Rspack - resolve 钩子。\n * compiler：Rspack 的 Compiler 对象。\n * compilation：Rspack 的 Compilation 对象。\n * environment: 当前构建的 environment 上下文。\n\n\napi.processAssets#\n\n在输出产物之前对 assets 进行修改，等价于 Rspack 的 compilation.hooks.processAssets hook。\n\n * 版本： >= 1.0.0\n * 类型：\n\n\n\napi.processAssets 接受两个参数：\n\n * descriptor：一个对象，用于描述 processAssets 触发的 stage 和匹配条件。\n * handler：一个回调函数，接收 assets 对象并允许你修改它。\n\n\n示例#\n\n * 在 additional 阶段输出一个新的 asset：\n\n\n\n * 更新一个已经存在的 asset：\n\n\n\n * 移除一个 asset：\n\n\n\n\ndescriptor 参数#\n\ndescriptor 参数是一个对象，用于描述 processAssets 触发的 stage 和匹配条件。\n\n * 类型：\n\n\n\ndescriptor 参数支持设置以下属性：\n\n * stage：Rspack 内部将 processAssets 划分为多个 stages（参考 process assets\n   stages，你可以根据需要进行的操作来选择合适的 stage。\n\n\n\n * targets：匹配 Rsbuild output.target，仅对匹配的 targets 应用当前 processAssets 函数。\n\n\n\n * environments：匹配 Rsbuild environment name，仅对匹配的 environments 应用当前\n   processAssets 函数。\n\n\n\n\nhandler 参数#\n\nhandler 参数是一个回调函数，接收一个 assets 对象，并允许你修改它。\n\n * 类型：\n\n\n\nhandler 函数提供以下参数：\n\n * assets：一个对象，其中 key 是 asset 的路径名，值是由 Source 表示的 asset 数据。\n * compiler：Rspack 的 Compiler 对象。\n * compilation：Rspack 的 Compilation 对象。\n * environment: 当前构建的 environment 上下文.\n * sources：Rspack Sources 对象，它包含了多种表示 Sources 的 classes。\n\n\nProcess assets stages#\n\n下面是支持的 stage 列表，Rspack 会按由上至下的顺序依次执行这些 stages，请根据你需要进行的操作来选择合适的 stage。\n\n * additional — 在编译中添加额外的 asset。\n * pre-process — asset 进行了基础的预处理。\n * derived — 从现有 asset 中派生新的 asset。\n * additions — 为现有的 asset 添加额外的内容，例如 banner 或初始代码。\n * optimize — 以通用的方式优化现有 asset。\n * optimize-count — 优化现有 asset 的数量，例如，进行合并操作。\n * optimize-compatibility — 优化现有 asset 的兼容性，例如添加 polyfills 或者 vendor prefixes。\n * optimize-size — 优化现有 asset 的大小，例如进行压缩或者删除空格。\n * dev-tooling — 为 asset 添加开发者工具，例如，提取 source map。\n * optimize-inline — 将 asset 内联到其他 asset 中来优化现有 asset 数量。\n * summarize — 整理现有 asset 列表。\n * optimize-hash — 优化 asset 的 hash 值，例如，生成基于 asset 内容的真实 hash 值。\n * optimize-transfer — 优化已有 asset 的转换操作，例如对 asset 进行压缩，并作为独立的 asset。\n * analyse — 分析已有 asset。\n * report — 创建用于上报的 asset。\n\n\napi.expose#\n\n用于插件间通信。\n\napi.expose 可以显式暴露当前插件的一些属性或方法，其他插件可以通过 api.useExposed 来获取这些 API。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\napi.useExposed#\n\n用于插件间通信。\n\napi.useExposed 可以获取到其他插件暴露的属性或方法。\n\n * 类型：\n\n\n\n * 示例：\n\n\n\n\n标识符#\n\n你可以使用 Symbol 作为唯一标识符，从而避免潜在的命名冲突：\n\n\n\n\n类型声明#\n\n你可以通过函数的泛型来声明类型：\n\n\n\n\n执行顺序#\n\n在进行插件间通信时，你需要留意插件的执行顺序。\n\n比如，在上面的示例中，如果 pluginParent 未注册，或者注册顺序晚于 pluginChild，那么\napi.useExposed('plugin-parent') 会返回一个 undefined。\n\n你可以使用插件对象的 pre、post 选项，以及插件 hook 的 order 选项来保证顺序是正确的。","routePath":"/zh/plugins/dev/core","lang":"zh","toc":[{"text":"RsbuildPlugin","id":"rsbuildplugin","depth":2,"charIndex":35},{"text":"前置插件","id":"前置插件","depth":3,"charIndex":360},{"text":"后置插件","id":"后置插件","depth":3,"charIndex":478},{"text":"移除插件","id":"移除插件","depth":3,"charIndex":570},{"text":"api.context","id":"apicontext","depth":2,"charIndex":722},{"text":"api.getRsbuildConfig","id":"apigetrsbuildconfig","depth":2,"charIndex":839},{"text":"api.getNormalizedConfig","id":"apigetnormalizedconfig","depth":2,"charIndex":873},{"text":"api.isPluginExists","id":"apiispluginexists","depth":2,"charIndex":910},{"text":"api.transform","id":"apitransform","depth":2,"charIndex":942},{"text":"示例","id":"示例","depth":3,"charIndex":1076},{"text":"descriptor 参数","id":"descriptor-参数","depth":3,"charIndex":1123},{"text":"handler 参数","id":"handler-参数","depth":3,"charIndex":1640},{"text":"与 loader 的区别","id":"与-loader-的区别","depth":3,"charIndex":2040},{"text":"api.resolve","id":"apiresolve","depth":2,"charIndex":2297},{"text":"示例","id":"示例-1","depth":3,"charIndex":2416},{"text":"`handler` 参数","id":"handler-参数-1","depth":3,"charIndex":-1},{"text":"api.processAssets","id":"apiprocessassets","depth":2,"charIndex":2690},{"text":"示例","id":"示例-2","depth":3,"charIndex":2932},{"text":"descriptor 参数","id":"descriptor-参数-1","depth":3,"charIndex":3014},{"text":"handler 参数","id":"handler-参数-2","depth":3,"charIndex":3393},{"text":"Process assets stages","id":"process-assets-stages","depth":3,"charIndex":3710},{"text":"api.expose","id":"apiexpose","depth":2,"charIndex":4492},{"text":"api.useExposed","id":"apiuseexposed","depth":2,"charIndex":4602},{"text":"标识符","id":"标识符","depth":3,"charIndex":4685},{"text":"类型声明","id":"类型声明","depth":3,"charIndex":4729},{"text":"执行顺序","id":"执行顺序","depth":3,"charIndex":4757}],"domain":"","frontmatter":{},"version":""},{"id":349,"title":"Plugin Hooks","content":"的标签组 bodyTags: HtmlBasicTag[]; }; type Context = { /** * Rspack 的 Compiler 对象 */\ncompiler: Rspack.Compiler; /** * Rspack 的 Compilation 对象 */ compilation:\nRspack.Compilation; /** * 静态资源的 URL 前缀 * @example 'https://example.com/' */\nassetPrefix: string; /** * HTML 文件的名称，相对于 dist 目录 * @example 'index.html' */\nfilename: string; /** * 当前构建的 environment 上下文 */ environment:\nEnvironmentContext; }; function ModifyHTMLTags( callback: (tags: HTMLTags,\ncontext: Context) => MaybePromise, ): void;","routePath":"/zh/plugins/dev/hooks","lang":"zh","toc":[{"text":"总览","id":"总览","depth":2,"charIndex":-1},{"text":"Common Hooks","id":"common-hooks","depth":3,"charIndex":-1},{"text":"Dev Hooks","id":"dev-hooks","depth":3,"charIndex":-1},{"text":"Build Hooks","id":"build-hooks","depth":3,"charIndex":-1},{"text":"Preview Hooks","id":"preview-hooks","depth":3,"charIndex":-1},{"text":"Hooks 顺序","id":"hooks-顺序","depth":2,"charIndex":-1},{"text":"Dev Hooks","id":"dev-hooks-1","depth":3,"charIndex":-1},{"text":"Build Hooks","id":"build-hooks-1","depth":3,"charIndex":-1},{"text":"Preview Hooks","id":"preview-hooks-1","depth":3,"charIndex":-1},{"text":"Global Hooks vs Environment Hooks","id":"global-hooks-vs-environment-hooks","depth":2,"charIndex":-1},{"text":"Global Hooks","id":"global-hooks","depth":3,"charIndex":-1},{"text":"Environment Hooks","id":"environment-hooks","depth":3,"charIndex":-1},{"text":"回调函数顺序","id":"回调函数顺序","depth":2,"charIndex":-1},{"text":"默认行为","id":"默认行为","depth":3,"charIndex":-1},{"text":"order 字段","id":"order-字段","depth":3,"charIndex":-1},{"text":"Common Hooks","id":"common-hooks-1","depth":2,"charIndex":-1},{"text":"modifyRsbuildConfig","id":"modifyrsbuildconfig","depth":3,"charIndex":-1},{"text":"modifyEnvironmentConfig","id":"modifyenvironmentconfig","depth":3,"charIndex":-1},{"text":"modifyRspackConfig","id":"modifyrspackconfig","depth":3,"charIndex":-1},{"text":"modifyBundlerChain","id":"modifybundlerchain","depth":3,"charIndex":-1},{"text":"modifyHTMLTags","id":"modifyhtmltags","depth":3,"charIndex":-1},{"text":"onBeforeCreateCompiler","id":"onbeforecreatecompiler","depth":3,"charIndex":-1},{"text":"onAfterCreateCompiler","id":"onaftercreatecompiler","depth":3,"charIndex":-1},{"text":"onBeforeEnvironmentCompile","id":"onbeforeenvironmentcompile","depth":3,"charIndex":-1},{"text":"onAfterEnvironmentCompile","id":"onafterenvironmentcompile","depth":3,"charIndex":-1},{"text":"Build Hooks","id":"build-hooks-2","depth":2,"charIndex":-1},{"text":"onBeforeBuild","id":"onbeforebuild","depth":3,"charIndex":-1},{"text":"onAfterBuild","id":"onafterbuild","depth":3,"charIndex":-1},{"text":"onCloseBuild","id":"onclosebuild","depth":3,"charIndex":-1},{"text":"Dev Hooks","id":"dev-hooks-2","depth":2,"charIndex":-1},{"text":"onBeforeStartDevServer","id":"onbeforestartdevserver","depth":3,"charIndex":-1},{"text":"onAfterStartDevServer","id":"onafterstartdevserver","depth":3,"charIndex":-1},{"text":"onAfterEnvironmentCompile","id":"onafterenvironmentcompile-1","depth":3,"charIndex":-1},{"text":"onDevCompileDone","id":"ondevcompiledone","depth":3,"charIndex":-1},{"text":"onCloseDevServer","id":"onclosedevserver","depth":3,"charIndex":-1},{"text":"Preview Hooks","id":"preview-hooks-2","depth":2,"charIndex":-1},{"text":"onBeforeStartProdServer","id":"onbeforestartprodserver","depth":3,"charIndex":-1},{"text":"onAfterStartProdServer","id":"onafterstartprodserver","depth":3,"charIndex":-1},{"text":"Other Hooks","id":"other-hooks","depth":2,"charIndex":-1},{"text":"onExit","id":"onexit","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":350,"title":"插件系统","content":"#\n\nRsbuild 提供了一套轻量强大的插件系统，用以实现自身的大多数功能，并允许用户进行扩展。\n\n开发者编写的插件能够修改 Rsbuild 的默认行为，并添加各类额外功能，包括但不限于：\n\n * 获取上下文信息\n * 注册生命周期钩子\n * 转换模块的源代码\n * 修改 Rspack 配置\n * 修改 Rsbuild 配置\n * ...\n\n\n对比其他插件#\n\n在开发 Rsbuild 插件之前，你可能已经接触过 Webpack、Vite、esbuild 等工具的插件系统。\n\n总体而言，Rsbuild 的插件 API 和 esbuild 相似，与 Webpack / Rspack 插件相比，Rsbuild 的插件 API\n更加简洁和容易上手。\n\n\n\n从功能上看，Rsbuild 的插件 API 主要围绕 Rsbuild 的运行流程和构建配置，并提供一些 hooks 用于扩展。而 Rspack 的插件 API\n则更加复杂和丰富，能够修改打包过程的每一个环节。\n\nRsbuild 插件中可以集成 Rspack 插件，如果 Rsbuild 提供的 hooks 无法满足你的需求，你也可以通过 Rspack 插件来实现功能，并在\nRsbuild 插件中注册 Rspack 插件：\n\n\n\n\n开发插件#\n\n插件提供类似 (options?: PluginOptions) => RsbuildPlugin 的函数作为入口。\n\n\n插件示例#\n\n\n\n注册插件：\n\n\n\n\n插件结构#\n\n函数形式的插件可以 接受选项对象 并 返回插件实例，并通过闭包机制管理内部状态。\n\n其中各部分的作用分别为：\n\n * name 属性用于标注插件名称。\n * setup 作为插件逻辑的主入口。\n * api 对象包含了各类钩子和工具函数。\n\n\n命名规范#\n\n插件的命名规范如下：\n\n * 插件的函数命名为 pluginAbc，并通过具名导出。\n * 插件的 name 采用 scope:foo-bar 或 plugin-foo-bar 格式，添加 scope: 可以避免和其他插件产生命名冲突。\n\n下面是一个例子：\n\n\n\nTIP\n\nRsbuild 官方插件的 name 统一使用 rsbuild: 作为前缀，比如 rsbuild:react 对应 @rsbuild/plugin-react。\n\n\n模板仓库#\n\nrsbuild-plugin-template 是一个最小的 Rsbuild 插件模板仓库，你可以基于该仓库来开发你的 Rsbuild 插件。\n\n\nEnvironment 插件#\n\nRsbuild 支持同时为多个环境构建产物，并支持某个插件仅在指定环境下运行。\n\n当你希望你开发的插件支持作为 Environment 插件使用时，需要注意以下几点：\n\n 1. 每个 environment 有自身的 Rsbuild 配置：\n    * 使用 environment 上下文 代替 getRsbuildConfig 获取 environment 信息。\n    * 修改特定 environment 的 Rsbuild 配置时，优先使用 modifyEnvironmentConfig 代替\n      modifyRsbuildConfig ，以避免对其他 environments 产生影响。\n 2. 避免副作用，你的插件代码可能执行多次：\n    * 当同一个插件在不同环境下注册多次时，会被视为多个 Rsbuild 插件（哪怕它们指向同一个插件实例），这是因为它们带有不同的 Rsbuild\n      environment 上下文。\n\n下面是一个 Environment 插件例子：\n\n\n\n\n引用其他插件#\n\nRsbuild 的 plugins 配置项支持传入一个嵌套的数组，这意味着你可以通过这种方式在插件内部引用其他 Rsbuild 插件。\n\n例如，在 pluginFoo 内部引用并注册 pluginBar：\n\n\n\n\n生命周期钩子#\n\nRsbuild 在内部按照约定的生命周期进行任务调度，插件可以通过注册钩子来介入工作流程的任意阶段，并实现自己的功能。\n\nRsbuild 生命周期钩子的完整列表参考 API 文档。\n\nRsbuild 不会接管底层 Rspack 的生命周期，相关生命周期钩子的使用方式见对应文档：Rspack Plugin API。\n\n\n使用配置项#\n\n自行编写的插件通常使用初始化时传入函数的参数作为配置项即可，开发者可以随意定义和使用函数的入参。\n\n但某些情况下插件可能需要读取 / 修改 Rsbuild 公用的配置项，这时就需要了解 Rsbuild 内部对配置项的生产和消费流程：\n\n * 读取、解析配置并合并默认值\n * 插件通过 api.modifyRsbuildConfig(...) 回调修改配置项\n * 归一化配置项并提供给插件后续消费，此后无法再修改配置项\n\n整套流程可以通过这个简单的插件体现：\n\n\n\n插件中有三种方式使用配置项对象：\n\n * api.modifyRsbuildConfig(config => {}) 在回调中修改配置\n * api.getRsbuildConfig() 获取配置项\n * api.getNormalizedConfig() 获取归一化后的配置项\n\n归一化的配置项会再次合并默认值，并移除大部分可选类型，对于 PluginUploadDist 的例子，其部分类型定义为：\n\n\n\ngetNormalizedConfig() 的返回值类型与 RsbuildConfig 的略有不同、相比文档其它地方描述的类型进行了收窄，\n在使用时无需自行判空、填充默认值。\n\n因此使用配置项的最佳方式应该是：\n\n * 通过 api.modifyRsbuildConfig(config => {}) 来修改配置\n * 在其后的生命周期中读取 api.getNormalizedConfig() 作为插件实际使用的配置\n\n\n修改 Rspack 配置#\n\nRsbuild 插件允许你修改内置的 Rspack 配置，包括：\n\n * api.modifyRspackConfig：修改 Rspack 配置对象。\n * api.modifyBundlerChain 通过 rspack-chain 来修改 Rspack 配置。\n\n\n示例#\n\n比如，通过 Rsbuild 插件来注册 eslint-rspack-plugin：\n\n","routePath":"/zh/plugins/dev/","lang":"zh","toc":[{"text":"对比其他插件","id":"对比其他插件","depth":2,"charIndex":173},{"text":"开发插件","id":"开发插件","depth":2,"charIndex":544},{"text":"插件示例","id":"插件示例","depth":3,"charIndex":612},{"text":"插件结构","id":"插件结构","depth":3,"charIndex":631},{"text":"命名规范","id":"命名规范","depth":3,"charIndex":760},{"text":"模板仓库","id":"模板仓库","depth":3,"charIndex":987},{"text":"Environment 插件","id":"environment-插件","depth":3,"charIndex":1068},{"text":"引用其他插件","id":"引用其他插件","depth":3,"charIndex":1545},{"text":"生命周期钩子","id":"生命周期钩子","depth":2,"charIndex":1661},{"text":"使用配置项","id":"使用配置项","depth":2,"charIndex":1830},{"text":"修改 Rspack 配置","id":"修改-rspack-配置","depth":2,"charIndex":2489},{"text":"示例","id":"示例","depth":3,"charIndex":2639}],"domain":"","frontmatter":{},"version":""},{"id":351,"title":"总览","content":"#\n\n\n插件系统#\n\n你可以阅读 插件系统 来了解 Rsbuild 插件的功能，以及如何开发一个 Rsbuild 插件。\n\n\n使用插件#\n\n你可以在 rsbuild.config.ts 中通过 plugins 选项来注册 Rsbuild 插件，详见 plugins。\n\n如果你使用了 Rsbuild 的 JavaScript API，可以通过 addPlugins 方法来注册插件。\n\n\n官方插件#\n\n以下是 Rsbuild 官方提供的插件。\n\n\nReact#\n\n适用于 React 框架的插件有：\n\n * React 插件：提供对 React 的支持。\n * SVGR 插件：支持将 SVG 图片转换为一个 React 组件使用。\n * Styled Components 插件：提供对 styled-components 的编译时支持。\n\n\nVue#\n\n适用于 Vue 框架的插件有：\n\n * Vue 插件：提供对 Vue 3 SFC（单文件组件）的支持。\n * Vue JSX 插件：提供对 Vue 3 JSX / TSX 语法的支持。\n * Vue 2 插件：提供对 Vue 2 SFC（单文件组件）的支持。\n * Vue 2 JSX 插件：提供对 Vue 2 JSX / TSX 语法的支持。\n\n\nPreact#\n\n适用于 Preact 框架的插件有：\n\n * Preact 插件：提供对 Preact 的支持。\n\n\nSvelte#\n\n适用于 Svelte 框架的插件有：\n\n * Svelte 插件：提供对 Svelte 组件（.svelte 文件）的支持。\n\n\nSolid#\n\n适用于 Solid 框架的插件有：\n\n * Solid 插件：提供对 Solid 的支持。\n\n\n通用插件#\n\n以下是与框架无关的通用插件：\n\n * Assets Retry 插件：用于在静态资源加载失败时自动发起重试请求。\n * Babel 插件：提供对 Babel 转译能力的支持。\n * Sass 插件：使用 Sass 作为 CSS 预处理器。\n * Less 插件：使用 Less 作为 CSS 预处理器。\n * Stylus 插件：使用 Stylus 作为 CSS 预处理器。\n * Basic SSL 插件: 为 HTTPS server 生成不受信任的自签名证书。\n * ESLint 插件：用于在编译过程中运行 ESLint 检查。\n * Type Check 插件：用于在单独的进程中运行 TypeScript 类型检查。\n * Image Compress 插件：压缩图片资源。\n * MDX 插件：提供 MDX 支持。\n * Node Polyfill 插件：用于注入 Node 核心模块在浏览器端的 polyfills。\n * Source Build 插件：用于 monorepo 场景，支持引用其他子目录的源代码，并完成构建和热更新。\n * Check Syntax 插件：检查构建产物的语法兼容性，判断是否存在导致兼容性问题的高级语法。\n * CSS Minimizer 插件：用于自定义 CSS 压缩工具，切换到 cssnano 或其他工具进行 CSS 压缩。\n * Typed CSS Modules 插件：用于为 CSS Modules 文件生成类型声明。\n * Pug 插件：提供对 Pug 模板引擎的支持。\n * Rem 插件：用于实现移动端页面的 rem 自适应布局。\n * UMD 插件：用于构建 UMD 格式的产物。\n * YAML 插件：引用 YAML 文件，并将其转换为 JavaScript 对象。\n * TOML 插件：引用 TOML 文件，并将其转换为 JavaScript 对象。\n\nTIP\n\n你可以在 web-infra-dev/rsbuild 和 rspack-contrib 中找到这些插件的源代码。\n\n\n社区插件#\n\n你可以在 awesome-rspack - Rsbuild Plugins 中查看社区提供的 Rsbuild 插件。\n\n也可以在 npm 上搜索 rsbuild-plugin 关键词来发现更多 Rsbuild 插件。","routePath":"/zh/plugins/list/","lang":"zh","toc":[{"text":"插件系统","id":"插件系统","depth":2,"charIndex":3},{"text":"使用插件","id":"使用插件","depth":2,"charIndex":62},{"text":"官方插件","id":"官方插件","depth":2,"charIndex":193},{"text":"React","id":"react","depth":3,"charIndex":223},{"text":"Vue","id":"vue","depth":3,"charIndex":372},{"text":"Preact","id":"preact","depth":3,"charIndex":553},{"text":"Svelte","id":"svelte","depth":3,"charIndex":613},{"text":"Solid","id":"solid","depth":3,"charIndex":687},{"text":"通用插件","id":"通用插件","depth":3,"charIndex":743},{"text":"社区插件","id":"社区插件","depth":2,"charIndex":1629}],"domain":"","frontmatter":{},"version":""},{"id":352,"title":"Assets Retry 插件","content":"+ <%= htmlPlugin.tags.bodyTags %>","routePath":"/zh/plugins/list/plugin-assets-retry","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":-1},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":-1},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":-1},{"text":"选项","id":"选项","depth":2,"charIndex":-1},{"text":"domain","id":"domain","depth":3,"charIndex":-1},{"text":"type","id":"type","depth":3,"charIndex":-1},{"text":"max","id":"max","depth":3,"charIndex":-1},{"text":"test","id":"test","depth":3,"charIndex":-1},{"text":"crossOrigin","id":"crossorigin","depth":3,"charIndex":-1},{"text":"onRetry","id":"onretry","depth":3,"charIndex":-1},{"text":"onSuccess","id":"onsuccess","depth":3,"charIndex":-1},{"text":"onFail","id":"onfail","depth":3,"charIndex":-1},{"text":"addQuery","id":"addquery","depth":3,"charIndex":-1},{"text":"inlineScript","id":"inlinescript","depth":3,"charIndex":-1},{"text":"minify","id":"minify","depth":3,"charIndex":-1},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":-1},{"text":"使用限制","id":"使用限制","depth":2,"charIndex":-1},{"text":"模块联邦","id":"模块联邦","depth":3,"charIndex":-1},{"text":"微前端","id":"微前端","depth":3,"charIndex":-1},{"text":"自定义模版中的资源","id":"自定义模版中的资源","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":353,"title":"Babel 插件","content":"#\n\nRsbuild 默认使用 SWC 编译，当内置的功能无法满足诉求、需要添加一些 Babel presets 或 plugins 进行额外处理时，你可以使用\nRsbuild 的 Babel 插件。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n\n编译缓存#\n\n使用 Babel 插件后，Rsbuild 除了执行默认的 SWC 转译，还会执行 Babel 转译，存在额外的编译开销，这可能导致构建速度明显降低。\n\n为了降低 Babel 转译的开销，@rsbuild/plugin-babel 默认开启了 Babel 编译缓存。如果你希望禁用缓存，可以将\nperformance.buildCache 设置为 false：\n\n\n\n\n选项#\n\n\nbabelLoaderOptions#\n\n传递给 babel-loader 的选项，请查阅 babel-loader 文档 来了解具体用法。\n\n * 类型： Object | Function\n * 默认值：\n\n\n\nFunction 类型#\n\n当配置项为 Function 类型时，默认 Babel 配置会作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终的 babel-loader\n配置。\n\n\n\n函数的第二个参数提供了一些方便的工具函数，请继续阅读下方文档。\n\nTIP\n\n以上示例仅作为参考，通常来说，你不需要手动配置 babel-plugin-import，因为 Rspack SWC 编译已支持 transformImport\n能力，Rsbuild 也提供了更通用的 source.transformImport 配置。\n\nObject 类型#\n\n当配置项的值为 Object 类型时，会与默认配置通过 Object.assign 浅合并。\n\nCAUTION\n\nObject.assign 是浅拷贝，会完全覆盖内置的 presets 或 plugins 数组，导致内置的 presets 或 plugins\n失效，请在明确影响面的情况下再使用这种方式。\n\n\n\n工具函数#\n\n配置项为 Function 类型时，第二个参数可用的工具函数如下:\n\naddPlugins#\n\n * 类型： (plugins: BabelPlugin[]) => void\n\n添加若干个 Babel 插件。\n\n\n\naddPresets#\n\n * 类型： (presets: BabelPlugin[]) => void\n\n添加若干个 Babel 预设配置 (大多数情况下不需要增加预设)。\n\n\n\nremovePlugins#\n\n * 类型： (plugins: string | string[]) => void\n\n移除 Babel 插件，传入需要移除的插件名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\n\n\nremovePresets#\n\n * 类型： (presets: string | string[]) => void\n\n移除 Babel 预设配置，传入需要移除的预设名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\n\n\n\ninclude#\n\n * 类型： string | RegExp | (string | RegExp)[]\n * 默认值： undefined\n\n用于指定需要 Babel 编译的文件。\n\n由于 Babel 编译存在性能开销，通过 include 来匹配部分文件可以减少 Babel 编译的模块数量，从而提升构建性能。\n\n比如，只对 .custom.js 文件进行编译，并忽略 node_modules 下的文件：\n\n\n\nTIP\n\n当你配置 include 或 exclude 选项时，Rsbuild 会创建一条单独的 Rspack rule 来应用 babel-loader 和\nswc-loader。\n\n这条单独的 rule 与 Rsbuild 内置的 SWC rule 是完全独立的，并且不会受到 source.include 和 source.exclude\n的作用。\n\n\nexclude#\n\n * 类型： string | RegExp | (string | RegExp)[]\n * 默认值： undefined\n\n用于指定不需要 Babel 编译的文件。\n\n由于 Babel 编译存在性能开销，通过 exclude 来排除部分文件可以减少 Babel 编译的模块数量，从而提升构建性能。\n\n\n调试配置#\n\n当你通过配置项修改 babel-loader 配置后，可以在 Rsbuild 调试模式 下查看最终生成的配置。\n\n首先通过 DEBUG=rsbuild 参数开启调试模式：\n\n\n\n然后打开生成的 rspack.config.web.mjs，搜索 babel-loader 关键词，即可看到完整的 babel-loader 配置内容。\n\n\n常见问题#\n\n\n编译卡死#\n\n在使用 Babel 插件后，如果编译进度条卡死，但终端无 Error 日志时，通常是因为编译过程中出现了异常。在某些情况下，当 Error 被 webpack\n或其他模块捕获后，错误日志不会被正确输出。最为常见的场景是 Babel 配置出现异常，抛出 Error 后被 webpack 捕获，而 webpack\n在个别情况下吞掉了 Error。\n\n解决方法：\n\n如果你修改 Babel 配置后出现此问题，建议检查是否有以下错误用法：\n\n 1. 配置了一个不存在的 plugin 或 preset，可能是名称拼写错误，或是未正确安装。\n\n\n\n 2. 是否配置了多个 babel-plugin-import，但是没有在数组的第三项声明每一个 babel-plugin-import 的名称。\n\n\n\n","routePath":"/zh/plugins/list/plugin-babel","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":102},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":110},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":135},{"text":"编译缓存","id":"编译缓存","depth":2,"charIndex":178},{"text":"选项","id":"选项","depth":2,"charIndex":369},{"text":"babelLoaderOptions","id":"babelloaderoptions","depth":3,"charIndex":375},{"text":"Function 类型","id":"function-类型","depth":4,"charIndex":483},{"text":"Object 类型","id":"object-类型","depth":4,"charIndex":751},{"text":"工具函数","id":"工具函数","depth":4,"charIndex":919},{"text":"include","id":"include","depth":3,"charIndex":1358},{"text":"exclude","id":"exclude","depth":3,"charIndex":1749},{"text":"调试配置","id":"调试配置","depth":2,"charIndex":1912},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":2087},{"text":"编译卡死","id":"编译卡死","depth":3,"charIndex":2095}],"domain":"","frontmatter":{},"version":""},{"id":354,"title":"Less 插件","content":"#\n\n使用 Less 作为 CSS 预处理器，基于 less-loader 实现。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\nTIP\n * Less 插件仅支持 @rsbuild/core >= 0.7.0 版本。\n * 当 @rsbuild/core 版本小于 0.7.0 时，内置支持 Less 插件，你不需要安装该插件。\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n注册插件后，你可以在代码中引入 *.less 或 *.module.less 文件，无须添加其他配置。\n\n\n选项#\n\n如果你需要自定义 Less 的编译行为，可以使用以下配置项。\n\n\nlessLoaderOptions#\n\n修改 less-loader 的配置。\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n * 示例：\n\n当 lessLoaderOptions 的值是一个对象时，它会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，lessOptions\n会通过 deepMerge 进行深层合并。\n\n\n\n当 lessLoaderOptions 的值是一个函数时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个值作为最终结果：\n\n\n\nTIP\n\nlessLoaderOptions.lessOptions 是直接传递给 Less 的配置，请参阅 Less 文档 以了解所有可用选项。\n\n\ninclude#\n\n * 类型： RuleSetCondition\n * 默认值： /\\.less$/\n * 版本： >= 1.1.0\n\n用于指定一部分 .less 模块，这些模块会被 less-loader 编译。这个值与 Rspack 中的 rule.test 选项相同。\n\n比如：\n\n\n\n\nexclude#\n\n * 类型： RuleSetCondition\n * 默认值： undefined\n\n用于排除一部分 .less 模块，这些模块不会被 less-loader 编译。\n\n比如：\n\n\n\n\n修改 Less 版本#\n\n在某些场景下，如果你需要使用特定的 Less 版本，而不是使用 Rsbuild 内置的 Less v4，可以在项目中安装需要使用的 Less 版本，并通过\nless-loader 的 implementation 选项设置。\n\n\n\n\n实践#\n\n\n配置多个 Less 插件#\n\n通过使用 include 和 exclude 选项，你可以同时注册多个 Less 插件，并为每个插件指定不同的选项。\n\n例如：\n\n\n\n\n常见问题#\n\n\nLess 文件中的除法不生效？#\n\n@rsbuild/plugin-less 内置的 Less 版本为 v4，与 v3 版本相比，除法的写法有一些区别：\n\n\n\nLess 中除法的写法可以通过配置项来修改，详见 Less - Math。","routePath":"/zh/plugins/list/plugin-less","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":43},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":51},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":178},{"text":"选项","id":"选项","depth":2,"charIndex":274},{"text":"lessLoaderOptions","id":"lessloaderoptions","depth":3,"charIndex":312},{"text":"include","id":"include","depth":3,"charIndex":651},{"text":"exclude","id":"exclude","depth":3,"charIndex":799},{"text":"修改 Less 版本","id":"修改-less-版本","depth":2,"charIndex":902},{"text":"实践","id":"实践","depth":2,"charIndex":1032},{"text":"配置多个 Less 插件","id":"配置多个-less-插件","depth":3,"charIndex":1038},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":1121},{"text":"Less 文件中的除法不生效？","id":"less-文件中的除法不生效","depth":3,"charIndex":1129}],"domain":"","frontmatter":{},"version":""},{"id":355,"title":"Preact 插件","content":"#\n\nPreact 插件提供了对 Preact 的支持，插件内部集成了 JSX 编译、React aliasing 等功能。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n注册插件后，你可以直接进行 Preact 开发。\n\n\n选项#\n\n\nreactAliasesEnabled#\n\n是否将 react、react-dom 通过 alias 指向 preact/compat。\n\n * 类型： boolean\n * 默认值： true\n * 示例： 禁用别名。\n\n\n\n\nprefreshEnabled#\n\n是否注入 Prefresh 用于 HMR。\n\n * 类型： boolean\n * 默认值： true\n * 版本： >= v1.1.0\n * 示例： 禁用 Prefresh。\n\n\n\n\ninclude#\n\n指定要由 @rspack/plugin-preact-refresh 插件处理的文件。这个值与 Rspack 中的 rule.test 选项相同。\n\n * 类型： RuleSetCondition\n * 默认值： /\\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/\n * 版本： >= v1.1.0\n\n\n\n\nexclude#\n\n排除 @rspack/plugin-preact-refresh 插件处理的文件。这个值与 Rspack 中的 rule.exclude 选项相同。\n\n * 类型： RuleSetCondition\n * 默认值： /[\\\\/]node_modules[\\\\/]/\n * 版本： >= v1.1.0\n\n","routePath":"/zh/plugins/list/plugin-preact","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":64},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":72},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":97},{"text":"选项","id":"选项","depth":2,"charIndex":166},{"text":"reactAliasesEnabled","id":"reactaliasesenabled","depth":3,"charIndex":172},{"text":"prefreshEnabled","id":"prefreshenabled","depth":3,"charIndex":287},{"text":"include","id":"include","depth":3,"charIndex":397},{"text":"exclude","id":"exclude","depth":3,"charIndex":574}],"domain":"","frontmatter":{},"version":""},{"id":356,"title":"React 插件","content":"#\n\nReact 插件提供了对 React 的支持，插件内部集成了 JSX 编译、React Refresh 等功能。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n注册插件后，你可以直接进行 React 开发。\n\n\n选项#\n\n\nswcReactOptions#\n\n用于配置 SWC 转换 React 代码的行为，等价于 SWC 的 jsc.transform.react 选项。\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n\nswcReactOptions.runtime#\n\n设置 JSX runtime 的类型。\n\n * 类型： 'automatic' | 'classic'\n * 默认值： 'automatic'\n\n默认情况下，Rsbuild 使用 React 17 引入的新版本 JSX runtime，即 runtime: 'automatic'。\n\n如果你当前的 React 版本低于 16.14.0，可以将 runtime 设置为 'classic'：\n\n\n\n> React 16.14.0 可以使用新版本 JSX runtime。\n\n在使用 classic JSX runtime 时，你需要手动在代码中引入 React：\n\n\n\n\nswcReactOptions.importSource#\n\n当 runtime 为 'automatic' 时，你可以通过 importSource 来指定 JSX runtime 的引入路径。\n\n * 类型： string\n * 默认值： 'react'\n\n比如，在使用 Emotion 时，你可以将 importSource 设置为 '@emotion/react'：\n\n\n\n\nsplitChunks#\n\n在 chunkSplit.strategy 设置为 split-by-experience 时，Rsbuild 默认会自动将 react 和 router\n相关的包拆分为单独的 chunk:\n\n * lib-react.js：包含 react，react-dom，以及 react 的子依赖（scheduler）。\n * lib-router.js：包含 react-router，react-router-dom，以及 react-router\n   的子依赖（history，@remix-run/router）。\n\n该选项用于控制这一行为，决定是否需要将 react 和 router 相关的包拆分为单独的 chunk。\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n * 示例：\n\n\n\n\nenableProfiler#\n\n * 类型： boolean\n * 默认值： false\n\n当设置为 true 时，在生产构建中启用 React 性能分析器以用于性能分析。需要搭配 React DevTools\n来检查分析结果并识别潜在的性能优化方案。分析会增加一些额外开销，因此出于性能考虑，在生产模式中默认是禁用的。\n\n\n\n执行构建脚本时，设置 REACT_PROFILER=true 即可：\n\n\n\n由于 Windows 系统不支持上述用法，你也可以使用 cross-env 来设置环境变量，这可以确保在不同的操作系统中都能正常使用：\n\n\n\n> 关于使用 React DevTools 进行性能分析的详细信息，请参见 React 文档。\n\n\nreactRefreshOptions#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n设置 @rspack/plugin-react-refresh 的选项，传入的值会与默认值进行浅合并。\n\n * 示例：\n\n\n\n\nfastRefresh#\n\n * 类型： boolean\n * 默认值： true\n\n是否在开发模式下启用 React Fast Refresh。\n\n如果你需要禁用 Fast Refresh，可以将其设置为 false：\n\n","routePath":"/zh/plugins/list/plugin-react","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":61},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":69},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":94},{"text":"选项","id":"选项","depth":2,"charIndex":162},{"text":"swcReactOptions","id":"swcreactoptions","depth":3,"charIndex":168},{"text":"swcReactOptions.runtime","id":"swcreactoptionsruntime","depth":3,"charIndex":267},{"text":"swcReactOptions.importSource","id":"swcreactoptionsimportsource","depth":3,"charIndex":579},{"text":"splitChunks","id":"splitchunks","depth":3,"charIndex":771},{"text":"enableProfiler","id":"enableprofiler","depth":3,"charIndex":1132},{"text":"reactRefreshOptions","id":"reactrefreshoptions","depth":3,"charIndex":1456},{"text":"fastRefresh","id":"fastrefresh","depth":3,"charIndex":1563}],"domain":"","frontmatter":{},"version":""},{"id":357,"title":"Sass 插件","content":"#\n\n使用 Sass 作为 CSS 预处理器，基于 sass-loader 实现。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\nTIP\n * Sass 插件仅支持 @rsbuild/core >= 0.7.0 版本。\n * 当 @rsbuild/core 版本小于 0.7.0 时，内置支持 Sass 插件，你不需要安装该插件。\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n注册插件后，你可以在代码中引入 *.scss，*.sass，*.module.scss 或 *.module.sass 文件，无须添加其他配置。\n\n\n选项#\n\n如果你需要自定义 Sass 的编译行为，可以使用以下配置项。\n\n\nsassLoaderOptions#\n\n修改 sass-loader 的配置。\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n * 示例：\n\n当 sassLoaderOptions 的值是一个对象时，它会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，sassOptions\n会通过 deepMerge 进行深层合并。\n\n\n\n当 sassLoaderOptions 的值是一个函数时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个值作为最终结果：\n\n\n\n\ninclude#\n\n * 类型： RuleSetCondition\n * 默认值： /\\.s(?:a|c)ss$/\n * 版本： >= 1.1.0\n\n用于指定一部分 .scss 或 .sass 模块，这些模块会被 sass-loader 编译。这个值与 Rspack 中的 rule.test 选项相同。\n\n比如：\n\n\n\n\nexclude#\n\n * 类型： RuleSetCondition\n * 默认值： undefined\n\n用于排除一部分 .sass 或 .scss 模块，这些模块不会被 sass-loader 编译。\n\n比如：\n\n\n\n\n实践#\n\n\n修改 Sass implementation#\n\nSass 提供了多种实现，包括 sass、sass-embedded 和 node-sass。\n\nRsbuild 默认使用最新的 sass-embedded 实现。sass-embedded 是一个围绕原生 Dart Sass 可执行文件的\nJavaScript wrapper，具备一致的 API 和最佳的性能。\n\n如果你需要使用其他 Sass 实现，而不是使用 Rsbuild 内置的 sass-embedded，可以在项目中安装需要使用的 Sass 实现，并通过\nsass-loader 的 implementation 选项来设置。\n\n\n\nTIP\n\n将 sass-embedded 修改为其他 Sass 实现，可能会构建性能显著下降。\n\n\n选择 Sass API#\n\nRsbuild 默认使用最新的 modern-compiler API，如果你依赖了 Sass 的 legacy API，可以将 sass-loader 的\napi 选项设置为 legacy，以兼容一些废弃的 Sass 写法。\n\n\n\nTIP\n\nSass 的 legacy API 已经被废弃，并且将在 Sass 2.0 中被移除，建议迁移到 modern-compiler API，详见 Sass -\nLegacy JS API。\n\n\n忽略 Sass 废弃提示#\n\nSass 会通过 warning 日志提示你一些废弃的写法，这些写法在 Sass\n未来的大版本中将会被移除，建议根据日志进行修改。如果你不想看到这些日志，可以通过 Sass 的 silenceDeprecations 选项来忽略这些警告。\n\n例如，@import 已经被 Sass 废弃，当你使用该语法时，Sass 会输出如下日志：\n\n\n\n@rsbuild/plugin-sass 默认添加了如下配置来忽略 @import 的警告，如果你需要忽略其他废弃警告，可以使用同样的方式。\n\n\n\n> 请查看 Sass Deprecations 了解更多信息。\n\n\n配置多个 Sass 插件#\n\n通过使用 include 和 exclude 选项，你可以同时注册多个 Sass 插件，并为每个插件指定不同的选项。\n\n例如：\n\n","routePath":"/zh/plugins/list/plugin-sass","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":43},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":51},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":178},{"text":"选项","id":"选项","depth":2,"charIndex":295},{"text":"sassLoaderOptions","id":"sassloaderoptions","depth":3,"charIndex":333},{"text":"include","id":"include","depth":3,"charIndex":597},{"text":"exclude","id":"exclude","depth":3,"charIndex":759},{"text":"实践","id":"实践","depth":2,"charIndex":870},{"text":"修改 Sass implementation","id":"修改-sass-implementation","depth":3,"charIndex":876},{"text":"选择 Sass API","id":"选择-sass-api","depth":3,"charIndex":1225},{"text":"忽略 Sass 废弃提示","id":"忽略-sass-废弃提示","depth":3,"charIndex":1457},{"text":"配置多个 Sass 插件","id":"配置多个-sass-插件","depth":3,"charIndex":1750}],"domain":"","frontmatter":{},"version":""},{"id":358,"title":"Solid 插件","content":"#\n\nSolid 插件提供了对 Solid 的支持，插件内部集成了 babel-preset-solid。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n注册插件后，你可以直接进行 Solid 开发。\n\nTIP\n\n由于 Solid 的 JSX 依赖 Babel 进行编译，因此你需要额外添加 Babel 插件。\n\nBabel 编译会产生额外的编译开销，在上述例子中，我们通过 include 来匹配 .jsx 和 .tsx 文件，从而减少 Babel 带来的性能开销。\n\n\n选项#\n\n如果你需要自定义 Solid 的编译行为，可以使用以下配置项。\n\n\nsolidPresetOptions#\n\n传递给 babel-preset-solid 的选项，请查阅 babel-preset-solid 文档 来了解具体用法。\n\n * 类型： SolidPresetOptions\n * 默认值： {}\n * 示例：\n\n","routePath":"/zh/plugins/list/plugin-solid","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":55},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":63},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":88},{"text":"选项","id":"选项","depth":2,"charIndex":290},{"text":"solidPresetOptions","id":"solidpresetoptions","depth":3,"charIndex":329}],"domain":"","frontmatter":{},"version":""},{"id":359,"title":"Stylus 插件","content":"#\n\nStylus 是一个富于表现力、动态的、健壮的 CSS 预处理器；通过 Stylus 插件，你可以使用 Stylus 作为 CSS 预处理器。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n\n示例#\n\n注册插件后，你可以在代码中引入 *.styl，*.stylus，*.module.styl 或 *.module.stylus 文件，无须添加其他配置。\n\n * normalize.styl:\n\n\n\n * title.module.styl:\n\n\n\n * index.js:\n\n\n\n\n选项#\n\n如果你需要自定义 Stylus 的编译行为，可以使用以下配置项。\n\n\nstylusOptions#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n传递给 Stylus 的选项，请查阅 Stylus 文档 来了解具体用法。\n\n\n\n\nsourceMap#\n\n * 类型： boolean\n * 默认值： 与 output.sourceMap.css 一致\n\n是否生成 source map 文件。\n\n","routePath":"/zh/plugins/list/plugin-stylus","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":76},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":84},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":109},{"text":"示例","id":"示例","depth":2,"charIndex":152},{"text":"选项","id":"选项","depth":2,"charIndex":299},{"text":"stylusOptions","id":"stylusoptions","depth":3,"charIndex":339},{"text":"sourceMap","id":"sourcemap","depth":3,"charIndex":426}],"domain":"","frontmatter":{},"version":""},{"id":360,"title":"Svelte 插件","content":"#\n\nSvelte 插件提供了对 Svelte 组件（.svelte 文件）的支持，插件内部集成了 svelte-loader。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n注册插件后，你可以在代码中引入 *.svelte 单文件组件。\n\n\n选项#\n\n如果你需要自定义 Svelte 的编译行为，可以使用以下配置项。\n\n\nsvelteLoaderOptions#\n\n传递给 svelte-loader 的选项，请查阅 svelte-loader 文档 来了解具体用法。\n\n * 类型： SvelteLoaderOptions\n * 默认值：\n\n\n\n * 示例：\n\n\n\n\npreprocessOptions#\n\n传递给 svelte-preprocess 的选项，请查阅 svelte-preprocess 文档 来了解具体用法。\n\n * 类型： AutoPreprocessOptions\n * 默认值： undefined\n\n\n\n * 示例：\n\n","routePath":"/zh/plugins/list/plugin-svelte","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":66},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":74},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":99},{"text":"选项","id":"选项","depth":2,"charIndex":175},{"text":"svelteLoaderOptions","id":"svelteloaderoptions","depth":3,"charIndex":215},{"text":"preprocessOptions","id":"preprocessoptions","depth":3,"charIndex":339}],"domain":"","frontmatter":{},"version":""},{"id":361,"title":"SVGR 插件","content":"#\n\n默认情况下，Rsbuild 会将 SVG 图片当作静态资源处理，处理规则可参考：引用静态资源。\n\n通过添加 SVGR 插件，Rsbuild 支持调用 SVGR，将 SVG 图片转换为一个 React 组件使用。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n\n示例#\n\n\n默认用法#\n\n注册插件后，当你在 JS 文件中引用 SVG 资源时，如果导入的路径包含 ?react 后缀，Rsbuild 会调用 SVGR，将 SVG 图片转换为一个\nReact 组件。\n\n\n\n如果导入的路径不包含 ?react 后缀，那么 SVG 会被当做普通的静态资源来处理，你会得到一个 URL 字符串或 base64 URL，参考 引用静态资源。\n\n\n\n\n具名导入#\n\n@rsbuild/plugin-svgr 支持具名导入 ReactComponent 来使用 SVGR，你需要设置 svgrOptions.exportType\n为 'named'：\n\n\n\n\n\n@rsbuild/plugin-svgr 也支持默认导入和混合导入等用法：\n\n * 通过 svgrOptions.exportType 设置为 'default' 来启用默认导入。\n * 通过 mixedImport 选项来启用混合导入，从而同时使用默认导入和具名导入。\n\n\n选项#\n\n如果你需要自定义 SVGR 的编译行为，可以使用以下配置项：\n\n * 类型：\n\n\n\n\nsvgrOptions#\n\n用于修改 SVGR 的选项，传入的对象会与默认值进行 deep merge。完整文档请参考 SVGR - Options。\n\n * 类型： import('@svgr/core').Config\n * 默认值：\n\n\n\n * 示例：\n\n\n\n当你设置 svgoConfig.plugins 时，同名 plugin 的配置会被自动合并，比如下面的配置会与内置的 preset-default 进行合并：\n\n\n\n合并后的 svgoConfig `如下：\n\n\n\n\nsvgrOptions.exportType#\n\n设置 SVG React 组件的导出方式。\n\n * 类型： 'default' | 'named'\n * 默认值： undefined\n\nexportType 可以设置为：\n\n * default：使用默认导出。\n * named：使用 ReactComponent 具名导出。\n\n比如把 SVG 文件默认导出的内容设置为 React 组件：\n\n\n\n此时再使用默认导入，你会得到一个 React 组件，而不是 URL：\n\n\n\n同时，你也可以通过指定 ?url 的 query 来导入 url，比如：\n\n\n\nTIP\n\n当 svgrOptions.exportType 被设置为 'default' 时，具名导入（ReactComponent）将无法使用。\n\n\nmixedImport#\n\n * 类型： boolean\n * 默认值： false\n\n是否开启混合导入，允许同时使用默认导入和命名导入。\n\n混合导入通常和 svgrOptions.exportType: 'named' 同时使用，比如：\n\n\n\n此时引用的 SVG 文件会同时导出 URL 和 React 组件：\n\n\n\n局限性#\n\n建议优先使用 ?react 来将 SVG 转换为 React 组件，而不是使用混合导入。因为混合导入有如下局限性：\n\n 1. 包体积增加：混合导入会导致单个 SVG 模块被编译为两种代码（即使部分导出没有被使用），这会增加产物的包体积。\n 2. 编译速度下降：混合导入会产生额外的编译开销。即使代码中未使用到 ReactComponent 导出，SVG 文件仍然会被 SVGR 编译。而 SVGR\n    是基于 Babel 实现的，性能开销较大。\n\n\nquery#\n\n * 类型： RegExp\n * 默认值： /react/\n\n用于自定义匹配 SVGR 转换的 query 后缀。\n\n比如需要匹配带有 ?svgr 后缀的 import 路径：\n\n\n\n\n\n\nexclude#\n\n * 类型： RuleSetCondition\n * 默认值： undefined\n\n用于排除一部分 SVG 模块，这些 SVG 模块不会经过 SVGR 处理。\n\n比如，项目中包含 a.svg 和 b.svg，你可以将 b.svg 添加到 exclude：\n\n\n\n在引用时，a.svg 会被转换为 React 组件，b.svg 会被当做普通的静态资源来处理：\n\n\n\n\nexcludeImporter#\n\n * 类型： RuleSetCondition\n * 默认值： undefined\n\n用于排除一部分模块，这些模块引用的 SVG 文件不会经过 SVGR 处理。\n\n比如，项目中包含 page-a/index.ts 和 page-b/index.ts，你可以将 page-b 添加到 excludeImporter：\n\n\n\n * page-a 中引用的 SVG 会被转换为 React 组件：\n\n\n\n * page-b 中引用的 SVG 会被当做普通的静态资源来处理：\n\n\n\nTIP\n\n模块路径中的 query 比 exclude 和 excludeImporter 具有更高的优先级。比如某个模块被 exclude，添加 ?react\n依然可以使它被 SVGR 转换。\n\n\n类型声明#\n\n当你在 TypeScript 代码中引用 SVG 资源时，TypeScript 可能会提示该模块缺少类型定义：\n\n\n\n此时你需要为 SVG 资源添加类型声明文件，请在项目中创建 src/env.d.ts 文件，并添加相应的类型声明。\n\n * 默认情况下，你可以添加如下类型声明：\n\n\n\n * 如果 svgrOptions.exportType 的值为 'default'，则将类型声明设置为：\n\n\n\n * 如果 svgrOptions.exportType 的值为 'named'，则将类型声明设置为：\n\n\n\n * 如果 svgrOptions.exportType 的值为 'named'，且开启了 mixedImport，则将类型声明设置为：\n\n\n\n添加类型声明后，如果依然存在上述错误提示，请尝试重启当前 IDE，或者调整 env.d.ts 所在的目录，使 TypeScript 能够正确识别类型定义。","routePath":"/zh/plugins/list/plugin-svgr","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":110},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":118},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":143},{"text":"示例","id":"示例","depth":2,"charIndex":186},{"text":"默认用法","id":"默认用法","depth":3,"charIndex":192},{"text":"具名导入","id":"具名导入","depth":3,"charIndex":375},{"text":"选项","id":"选项","depth":2,"charIndex":617},{"text":"svgrOptions","id":"svgroptions","depth":3,"charIndex":665},{"text":"svgrOptions.exportType","id":"svgroptionsexporttype","depth":3,"charIndex":906},{"text":"mixedImport","id":"mixedimport","depth":3,"charIndex":1260},{"text":"局限性","id":"局限性","depth":4,"charIndex":1420},{"text":"query","id":"query","depth":3,"charIndex":1653},{"text":"exclude","id":"exclude","depth":3,"charIndex":1756},{"text":"excludeImporter","id":"excludeimporter","depth":3,"charIndex":1950},{"text":"类型声明","id":"类型声明","depth":2,"charIndex":2305}],"domain":"","frontmatter":{},"version":""},{"id":362,"title":"Vue 插件","content":"#\n\nVue 插件提供了对 Vue 3 SFC（单文件组件）的支持，插件内部集成了 vue-loader v17 版本。\n\nTIP\n\n对于 Vue 3 JSX / TSX 语法，请使用 Vue JSX 插件。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以在 rsbuild.config.ts 文件中注册插件：\n\n\n\n注册插件后，你可以在代码中引入 *.vue 单文件组件。\n\n\n选项#\n\n如果你需要自定义 Vue 的编译行为，可以使用以下配置项。\n\n\nvueLoaderOptions#\n\n传递给 vue-loader 的选项，请查阅 vue-loader 文档 来了解具体用法。\n\n * 类型： VueLoaderOptions\n * 默认值：\n\n\n\n * 示例：\n\n\n\n\nsplitChunks#\n\n在 chunkSplit.strategy 设置为 split-by-experience 时，Rsbuild 默认会自动将 vue 和 router\n相关的包拆分为单独的 chunk:\n\n * lib-vue.js：包含 vue，vue-loader，以及 vue\n   的子依赖（@vue/shared，@vue/reactivity，@vue/runtime-dom，@vue/runtime-core）。\n * lib-router.js：包含 vue-router。\n\n该选项用于控制这一行为，决定是否需要将 vue 和 router 相关的包拆分为单独的 chunk。\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n * 示例：\n\n\n\n\n常见问题#\n\n\n/deep/ 选择器导致编译报错#\n\n/deep/ 是从 Vue v2.7 开始废弃的用法，它不是一个合法的 CSS 语法，因此在编译时，Lightning CSS 等 CSS 编译工具会抛出错误。\n\n你可以使用 :deep() 代替它，更多用法参考 Vue - Deep Selectors。\n\n\n\n> 你也可以参考 Vue - RFC 0023 了解更多。","routePath":"/zh/plugins/list/plugin-vue","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":106},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":114},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":139},{"text":"选项","id":"选项","depth":2,"charIndex":212},{"text":"vueLoaderOptions","id":"vueloaderoptions","depth":3,"charIndex":249},{"text":"splitChunks","id":"splitchunks","depth":3,"charIndex":361},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":699},{"text":"/deep/ 选择器导致编译报错","id":"deep-选择器导致编译报错","depth":3,"charIndex":707}],"domain":"","frontmatter":{},"version":""}]