<html><head></head><body>
<p><strong>Compression</strong> is an important way to increase the performance of a website. For some documents, size reduction of up to 70% lowers the bandwidth capacity needs. Over the years, algorithms also got more efficient, and new ones are supported by clients and servers.</p>
<p>In practice, web developers don't need to implement compression mechanisms, both browsers and servers have it implemented already, but they have to be sure that the server is configured adequately. Compression happens at three different levels:</p>
<ul>
  <li>first some file formats are compressed with specific optimized methods,</li>
  <li>then general encryption can happen at the HTTP level (the resource is transmitted compressed from end to end),</li>
  <li>and finally compression can be defined at the connection level, between two nodes of an HTTP connection.</li>
</ul>
<h2 id="file_format_compression">File format compression</h2>
<p>Each data type has some redundancy, that is <em>wasted space</em>, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types use a lot of space to store their data and the need to optimize storage and regain space was apparent very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</p>
<ul>
  <li>
    <em>Loss-less compression</em>, where the compression-decompression cycle doesn't alter the data that is recovered. It matches (byte to byte) with the original.
    For images, <code>gif</code> or <code>png</code> are using lossless compression.
  </li>
  <li>
    <em>Lossy compression</em>, where the cycle alters the original data in a (hopefully) imperceptible way for the user.
    Video formats on the Web are lossy; the <code>jpeg</code> image format is also lossy.
  </li>
</ul>
<p>Some formats can be used for both loss-less or lossy compression, like <code>webp</code>, and usually lossy algorithm can be configured to compress more or less, which then of course leads to less or more quality. For better performance of a website, it is ideal to compress as much as possible, while keeping an acceptable level of quality. For images, an image generated by a tool could be not optimized enough for the Web; it is recommended to use tools that will compress as much as possible with the required quality. There are <a href="https://www.creativebloq.com/design/image-compression-tools-1132865">numerous tools</a> that are specialized for this.</p>
<p>Lossy compression algorithms are usually more efficient than loss-less ones.</p>
<div class="notecard note">
  <p><strong>Note:</strong> As compression works better on a specific kind of files, it usually provides nothing to compress them a second time. In fact, this is often counterproductive as the cost of the overhead (algorithms usually need a dictionary that adds to the initial size) can be higher than the extra gain in compression resulting in a larger file. Do not use the two following techniques for files in a compressed format.</p>
</div>
<h2 id="end-to-end_compression">End-to-end compression</h2>
<p>For compression, end-to-end compression is where the largest performance improvements of websites reside. End-to-end compression refers to a compression of the body of a message that is done by the server and will last unchanged until it reaches the client. Whatever the intermediate nodes are, they leave the body untouched.</p><!--
%%{init: { "sequence": { "wrap": true, "width": 175, "noteAlign": "center", "messageAlign": "left" }} }%%

sequenceDiagram
    participant Client
    participant Proxy1 as Proxy
    participant Proxy2 as Proxy
    participant Server

    Note over Client: Resource requested.
    Client->>Server:
    Note over Server: Resource is compressed and returned.
    Server->>Client:
    Note over Proxy1,Proxy2: Intermediate nodes do not uncompress the body.
    Note over Client: Client decompresses the body.
-->
<p>
  <img src="/en-US/docs/Web/HTTP/Compression/httpenco1.svg" alt="A server sending a compressed HTTP body to a client via network nodes. The body is not decompressed at any hop through the network until it reaches the client." width="950" height="463">
</p>
<p>All modern browsers and servers do support it and the only thing to negotiate is the compression algorithm to use. These algorithms are optimized for text. In the 1990s, compression technology was advancing at a rapid pace and numerous successive algorithms have been added to the set of possible choices. Nowadays, only two are relevant: <code>gzip</code>, the most common one, and <code>br</code> the new challenger.</p>
<p>To select the algorithm to use, browsers and servers use <a href="/en-US/docs/Web/HTTP/Content_negotiation">proactive content negotiation</a>. The browser sends an <a href="/en-US/docs/Web/HTTP/Headers/Accept-Encoding"><code>Accept-Encoding</code></a> header with the algorithm it supports and its order of precedence, the server picks one, uses it to compress the body of the response and uses the <a href="/en-US/docs/Web/HTTP/Headers/Content-Encoding"><code>Content-Encoding</code></a> header to tell the browser the algorithm it has chosen. As content negotiation has been used to choose a representation based on its encoding, the server must send a <a href="/en-US/docs/Web/HTTP/Headers/Vary"><code>Vary</code></a> header containing at least <a href="/en-US/docs/Web/HTTP/Headers/Accept-Encoding"><code>Accept-Encoding</code></a> alongside this header in the response; that way, caches will be able to cache the different representations of the resource.</p><!--
%%{init: { "sequence": { "wrap": true, "width":380, "noteAlign": "center", "messageAlign": "left" }} }%%

sequenceDiagram
    participant Client
    participant Server

    Note over Client: The client signifies its ability to understand two compression algorithms.
    Client->>Server: GET /doc HTTP/1.1<br/>Accept-Encoding: br, gzip
    Note over Server: The resource is sent compressed. The Vary header indicates that content negotiation has been used to select the algorithm.
    Server->>Client: HTTP/1.1 200 OK<br/>Content-Encoding: br<br/>Vary: Accept-Encoding
-->
<p>
  <img src="/en-US/docs/Web/HTTP/Compression/httpcompression1.svg" alt="A client requesting content with an 'Accept-Encoding: br, gzip' header. The server responds with a body compressed using the Brotli algorithm and the required 'Content-Encoding' and 'Vary' headers." width="850" height="479">
</p>
<p>As compression brings significant performance improvements, it is recommended to activate it for all files except already compressed ones like images, audio files and videos.</p>
<p>Apache supports compression and uses <a href="https://httpd.apache.org/docs/current/mod/mod_deflate.html">mod_deflate</a>; for Nginx there is <a href="https://nginx.org/en/docs/http/ngx_http_gzip_module.html">ngx_http_gzip_module</a>; for IIS, the <a href="https://learn.microsoft.com/en-us/iis/configuration/system.webServer/httpCompression/"><code>&lt;httpCompression&gt;</code></a> element.</p>
<h2 id="hop-by-hop_compression">Hop-by-hop compression</h2>
<p>Hop-by-hop compression, though similar to end-to-end compression, differs by one fundamental element: the compression doesn't happen on the resource in the server, creating a specific representation that is then transmitted, but on the body of the message between any two nodes on the path between the client and the server. Connections between successive intermediate nodes may apply a <em>different</em> compression.</p><!--
%%{init: { "sequence": { "wrap": true, "width": 130, "noteAlign": "center", "messageAlign": "left" }} }%%

sequenceDiagram
    participant Client
    participant N1 as Node
    participant N2 as Node
    participant N3 as Node
    participant Server

    Client->>N1: Uncompressed
    Note left of Client: Client sends an uncompressed body.
    Note over N1,N3: Intermediate nodes send the body with or without compression on a hop-by-hop basis.
    N1->>N2: Uncompressed
    N2->>N3: Compressed
    N3->>Server: Uncompressed
    Note right of Server: The server receives an uncompressed body.
-->
<p>
  <img src="/en-US/docs/Web/HTTP/Compression/httpte1.svg" alt="A server sending an uncompressed HTTP body to a client via network nodes. The body is compressed and decompressed by nodes on the network depending on 'Transfer-Encoding' headers before it reaches the client." width="1132" height="624">
</p>
<p>To do this, HTTP uses a mechanism similar to the content negotiation for end-to-end compression: the node transmitting the request advertizes its will using the <a href="/en-US/docs/Web/HTTP/Headers/TE"><code>TE</code></a> header and the other node chooses the adequate method, applies it, and indicates its choice with the <a href="/en-US/docs/Web/HTTP/Headers/Transfer-Encoding"><code>Transfer-Encoding</code></a> header.</p><!--
%%{init: { "sequence": { "wrap": true, "width": 175, "noteAlign": "center" }} }%%

sequenceDiagram
    participant Client
    participant Node1 as Node
    participant Node2 as Node
    participant Server

    Note over Client: Request message
    Client->>Node1: GET /doc HTTP/1.1

    Note over Node1: Shows support for compression while forwarding message.
    Node1->>Node2: GET /doc HTTP/1.1<br/>TE: gzip, br

    Note over Node2: Forwards message
    Node2->>Server: GET /doc HTTP/1.1

    Note over Server: Returns resource in an uncompressed body.
    Server->>Node2: HTTP/1.1 200 OK

    Note over Node2: Compresses body and forwards message.
    Node2->>Node1: HTTP/1.1 200 OK<br/>Transfer-Encoding: br

    Note over Node1: Decompresses resource and returns message to Client.
    Node1->>Client: HTTP/1.1 200 OK
-->
<p>
  <img src="/en-US/docs/Web/HTTP/Compression/httpcomp2.svg" alt="A client requesting content from a server with no compression-related headers. The server responds with an uncompressed body. The body is compressed and decompressed by nodes on the network before it reaches the client." width="951" height="943">
</p>
<p>In practice, hop-by-hop compression is transparent for the server and the client, and is rarely used. <a href="/en-US/docs/Web/HTTP/Headers/TE"><code>TE</code></a> and <a href="/en-US/docs/Web/HTTP/Headers/Transfer-Encoding"><code>Transfer-Encoding</code></a> are mostly used to send a response by chunks, allowing to start transmitting a resource without knowing its length.</p>
<p>Note that using <a href="/en-US/docs/Web/HTTP/Headers/Transfer-Encoding"><code>Transfer-Encoding</code></a> and compression at the hop level is so rare that most servers, like Apache, Nginx, or IIS, have no easy way to configure it. Such configuration usually happens at the proxy level.</p>
<h2 id="see_also">See also</h2>
<ul>
  <li>Glossary terms:
    <ul>
      <li><a href="/en-US/docs/Glossary/Brotli_compression">Brotli compression</a></li>
      <li><a href="/en-US/docs/Glossary/gzip_compression">Gzip compression</a></li>
      <li><a href="/en-US/docs/Glossary/Lossless_compression">Lossless compression</a></li>
      <li><a href="/en-US/docs/Glossary/Lossy_compression">Lossy compression</a></li>
      <li><a href="/en-US/docs/Glossary/Zstandard_compression">Zstandard compression</a></li>
    </ul>
  </li>
</ul>
</body></html>