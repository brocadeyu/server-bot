{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"Overview\",\"depth\":2},{\"url\":\"#choosing-between-event-handlers-and-effects\",\"depth\":2,\"text\":\"Choosing between event handlers and Effects \"},{\"url\":\"#event-handlers-run-in-response-to-specific-interactions\",\"depth\":3,\"text\":\"Event handlers run in response to specific interactions \"},{\"url\":\"#effects-run-whenever-synchronization-is-needed\",\"depth\":3,\"text\":\"Effects run whenever synchronization is needed \"},{\"url\":\"#reactive-values-and-reactive-logic\",\"depth\":2,\"text\":\"Reactive values and reactive logic \"},{\"url\":\"#logic-inside-event-handlers-is-not-reactive\",\"depth\":3,\"text\":\"Logic inside event handlers is not reactive \"},{\"url\":\"#logic-inside-effects-is-reactive\",\"depth\":3,\"text\":\"Logic inside Effects is reactive \"},{\"url\":\"#extracting-non-reactive-logic-out-of-effects\",\"depth\":2,\"text\":\"Extracting non-reactive logic out of Effects \"},{\"url\":\"#declaring-an-effect-event\",\"depth\":3,\"text\":\"Declaring an Effect Event \"},{\"url\":\"#reading-latest-props-and-state-with-effect-events\",\"depth\":3,\"text\":\"Reading latest props and state with Effect Events \"},{\"url\":\"#limitations-of-effect-events\",\"depth\":3,\"text\":\"Limitations of Effect Events \"},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","content":"[[\"$r\",\"MaxWidth\",\"32\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if some value they read, like a prop or a state variable, is different from what it was during the last render. Sometimes, you also want a mix of both behaviors: an Effect that re-runs in response to some values but not others. This page will teach you how to do that.\"}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"How to choose between an event handler and an Effect\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Why Effects are reactive, and event handlers are not\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"What to do when you want a part of your Effect‚Äôs code to not be reactive\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"What Effect Events are, and how to extract them from your Effects\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"How to read the latest props and state from Effects using Effect Events\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"choosing-between-event-handlers-and-effects\",\"children\":\"Choosing between event handlers and Effects \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"First, let‚Äôs recap the difference between event handlers and Effects.\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Imagine you‚Äôre implementing a chat room component. Your requirements look like this:\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Your component should automatically connect to the selected chat room.\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"When you click the ‚ÄúSend‚Äù button, it should send a message to the chat.\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Let‚Äôs say you‚Äôve already implemented the code for them, but you‚Äôre not sure where to put it. Should you use event handlers or Effects? Every time you need to answer this question, consider \",[\"$r\",\"a\",null,{\"href\":\"/learn/synchronizing-with-effects#what-are-effects-and-how-are-they-different-from-events\",\"children\":[[\"$r\",\"em\",null,{\"children\":\"why\"}],\" the code needs to run.\"]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"event-handlers-run-in-response-to-specific-interactions\",\"children\":\"Event handlers run in response to specific interactions \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"From the user‚Äôs perspective, sending a message should happen \",[\"$r\",\"em\",null,{\"children\":\"because\"}],\" the particular ‚ÄúSend‚Äù button was clicked. The user will get rather upset if you send their message at any other time or for any other reason. This is why sending a message should be an event handler. Event handlers let you handle specific interactions:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-6}\",\"children\":\"function ChatRoom({ roomId }) {\\n  const [message, setMessage] = useState('');\\n  // ...\\n  function handleSendClick() {\\n    sendMessage(message);\\n  }\\n  // ...\\n  return (\\n    <>\\n      <input value={message} onChange={e => setMessage(e.target.value)} />\\n      <button onClick={handleSendClick}>Send</button>\\n    </>\\n  );\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"With an event handler, you can be sure that \",[\"$r\",\"code\",null,{\"children\":\"sendMessage(message)\"}],\" will \",[\"$r\",\"em\",null,{\"children\":\"only\"}],\" run if the user presses the button.\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"effects-run-whenever-synchronization-is-needed\",\"children\":\"Effects run whenever synchronization is needed \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Recall that you also need to keep the component connected to the chat room. Where does that code go?\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"The \",[\"$r\",\"em\",null,{\"children\":\"reason\"}],\" to run this code is not some particular interaction. It doesn‚Äôt matter why or how the user navigated to the chat room screen. Now that they‚Äôre looking at it and could interact with it, the component needs to stay connected to the selected chat server. Even if the chat room component was the initial screen of your app, and the user has not performed any interactions at all, you would \",[\"$r\",\"em\",null,{\"children\":\"still\"}],\" need to connect. This is why it‚Äôs an Effect:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3-9}\",\"children\":\"function ChatRoom({ roomId }) {\\n  // ...\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => {\\n      connection.disconnect();\\n    };\\n  }, [roomId]);\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"With this code, you can be sure that there is always an active connection to the currently selected chat server, \",[\"$r\",\"em\",null,{\"children\":\"regardless\"}],\" of the specific interactions performed by the user. Whether the user has only opened your app, selected a different room, or navigated to another screen and back, your Effect ensures that the component will \",[\"$r\",\"em\",null,{\"children\":\"remain synchronized\"}],\" with the currently selected room, and will \",[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#why-synchronization-may-need-to-happen-more-than-once\",\"children\":\"re-connect whenever it‚Äôs necessary.\"}]]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection, sendMessage } from './chat.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [message, setMessage] = useState('');\\n\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n\\n  function handleSendClick() {\\n    sendMessage(message);\\n  }\\n\\n  return (\\n    <>\\n      <h1>Welcome to the {roomId} room!</h1>\\n      <input value={message} onChange={e => setMessage(e.target.value)} />\\n      <button onClick={handleSendClick}>Send</button>\\n    </>\\n  );\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  const [show, setShow] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        Choose the chat room:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">general</option>\\n          <option value=\\\"travel\\\">travel</option>\\n          <option value=\\\"music\\\">music</option>\\n        </select>\\n      </label>\\n      <button onClick={() => setShow(!show)}>\\n        {show ? 'Close chat' : 'Open chat'}\\n      </button>\\n      {show && <hr />}\\n      {show && <ChatRoom roomId={roomId} />}\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function sendMessage(message) {\\n  console.log('üîµ You sent: ' + message);\\n}\\n\\nexport function createConnection(serverUrl, roomId) {\\n  // A real implementation would actually connect to the server\\n  return {\\n    connect() {\\n      console.log('‚úÖ Connecting to \\\"' + roomId + '\\\" room at ' + serverUrl + '...');\\n    },\\n    disconnect() {\\n      console.log('‚ùå Disconnected from \\\"' + roomId + '\\\" room at ' + serverUrl);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"input, select { margin-right: 20px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"88\",{\"children\":[\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reactive-values-and-reactive-logic\",\"children\":\"Reactive values and reactive logic \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Intuitively, you could say that event handlers are always triggered ‚Äúmanually‚Äù, for example by clicking a button. Effects, on the other hand, are ‚Äúautomatic‚Äù: they run and re-run as often as it‚Äôs needed to stay synchronized.\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"There is a more precise way to think about this.\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Props, state, and variables declared inside your component‚Äôs body are called \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"reactive values\"}],\". In this example, \",[\"$r\",\"code\",null,{\"children\":\"serverUrl\"}],\" is not a reactive value, but \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" and \",[\"$r\",\"code\",null,{\"children\":\"message\"}],\" are. They participate in the rendering data flow:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 3, \\\"roomId\\\"], [2, 4, \\\"message\\\"]]\",\"children\":\"const serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId }) {\\n  const [message, setMessage] = useState('');\\n\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Reactive values like these can change due to a re-render. For example, the user may edit the \",[\"$r\",\"code\",null,{\"children\":\"message\"}],\" or choose a different \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" in a dropdown. Event handlers and Effects respond to changes differently:\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"Logic inside event handlers is \",[\"$r\",\"em\",null,{\"children\":\"not reactive.\"}]]}],\" It will not run again unless the user performs the same interaction (e.g. a click) again. Event handlers can read reactive values without ‚Äúreacting‚Äù to their changes.\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":[\"Logic inside Effects is \",[\"$r\",\"em\",null,{\"children\":\"reactive.\"}]]}],\" If your Effect reads a reactive value, \",[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values\",\"children\":\"you have to specify it as a dependency.\"}],\" Then, if a re-render causes that value to change, React will re-run your Effect‚Äôs logic with the new value.\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Let‚Äôs revisit the previous example to illustrate this difference.\"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"logic-inside-event-handlers-is-not-reactive\",\"children\":\"Logic inside event handlers is not reactive \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Take a look at this line of code. Should this logic be reactive or not?\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 2, \\\"message\\\"]]\",\"children\":\"    // ...\\n    sendMessage(message);\\n    // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"From the user‚Äôs perspective, \",[\"$r\",\"strong\",null,{\"children\":[\"a change to the \",[\"$r\",\"code\",null,{\"children\":\"message\"}],\" does \",[\"$r\",\"em\",null,{\"children\":\"not\"}],\" mean that they want to send a message.\"]}],\" It only means that the user is typing. In other words, the logic that sends a message should not be reactive. It should not run again only because the \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"reactive value\"}],\" has changed. That‚Äôs why it belongs in the event handler:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2}\",\"children\":\"  function handleSendClick() {\\n    sendMessage(message);\\n  }\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Event handlers aren‚Äôt reactive, so \",[\"$r\",\"code\",null,{\"children\":\"sendMessage(message)\"}],\" will only run when the user clicks the Send button.\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"logic-inside-effects-is-reactive\",\"children\":\"Logic inside Effects is reactive \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Now let‚Äôs return to these lines:\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 2, \\\"roomId\\\"]]\",\"children\":\"    // ...\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"From the user‚Äôs perspective, \",[\"$r\",\"strong\",null,{\"children\":[\"a change to the \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" \",[\"$r\",\"em\",null,{\"children\":\"does\"}],\" mean that they want to connect to a different room.\"]}],\" In other words, the logic for connecting to the room should be reactive. You \",[\"$r\",\"em\",null,{\"children\":\"want\"}],\" these lines of code to ‚Äúkeep up‚Äù with the \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"reactive value\"}],\", and to run again if that value is different. That‚Äôs why it belongs in an Effect:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-3}\",\"children\":\"  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.connect();\\n    return () => {\\n      connection.disconnect()\\n    };\\n  }, [roomId]);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Effects are reactive, so \",[\"$r\",\"code\",null,{\"children\":\"createConnection(serverUrl, roomId)\"}],\" and \",[\"$r\",\"code\",null,{\"children\":\"connection.connect()\"}],\" will run for every distinct value of \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\". Your Effect keeps the chat connection synchronized to the currently selected room.\"]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"extracting-non-reactive-logic-out-of-effects\",\"children\":\"Extracting non-reactive logic out of Effects \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Things get more tricky when you want to mix reactive logic with non-reactive logic.\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"For example, imagine that you want to show a notification when the user connects to the chat. You read the current theme (dark or light) from the props so that you can show the notification in the correct color:\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,4-6}\",\"children\":\"function ChatRoom({ roomId, theme }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.on('connected', () => {\\n      showNotification('Connected!', theme);\\n    });\\n    connection.connect();\\n    // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"However, \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" is a reactive value (it can change as a result of re-rendering), and \",[\"$r\",\"a\",null,{\"href\":\"/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency\",\"children\":\"every reactive value read by an Effect must be declared as its dependency.\"}],\" Now you have to specify \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" as a dependency of your Effect:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5,11}\",\"children\":\"function ChatRoom({ roomId, theme }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.on('connected', () => {\\n      showNotification('Connected!', theme);\\n    });\\n    connection.connect();\\n    return () => {\\n      connection.disconnect()\\n    };\\n  }, [roomId, theme]); // ‚úÖ All dependencies declared\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Play with this example and see if you can spot the problem with this user experience:\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"latest\\\",\\n    \\\"react-dom\\\": \\\"latest\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"toastify-js\\\": \\\"1.12.0\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { createConnection, sendMessage } from './chat.js';\\nimport { showNotification } from './notifications.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId, theme }) {\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.on('connected', () => {\\n      showNotification('Connected!', theme);\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId, theme]);\\n\\n  return <h1>Welcome to the {roomId} room!</h1>\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  const [isDark, setIsDark] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        Choose the chat room:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">general</option>\\n          <option value=\\\"travel\\\">travel</option>\\n          <option value=\\\"music\\\">music</option>\\n        </select>\\n      </label>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isDark}\\n          onChange={e => setIsDark(e.target.checked)}\\n        />\\n        Use dark theme\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        theme={isDark ? 'dark' : 'light'}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // A real implementation would actually connect to the server\\n  let connectedCallback;\\n  let timeout;\\n  return {\\n    connect() {\\n      timeout = setTimeout(() => {\\n        if (connectedCallback) {\\n          connectedCallback();\\n        }\\n      }, 100);\\n    },\\n    on(event, callback) {\\n      if (connectedCallback) {\\n        throw Error('Cannot add the handler twice.');\\n      }\\n      if (event !== 'connected') {\\n        throw Error('Only \\\"connected\\\" event is supported.');\\n      }\\n      connectedCallback = callback;\\n    },\\n    disconnect() {\\n      clearTimeout(timeout);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/notifications.js\",\"children\":\"import Toastify from 'toastify-js';\\nimport 'toastify-js/src/toastify.css';\\n\\nexport function showNotification(message, theme) {\\n  Toastify({\\n    text: message,\\n    duration: 2000,\\n    gravity: 'top',\\n    position: 'right',\\n    style: {\\n      background: theme === 'dark' ? 'black' : 'white',\\n      color: theme === 'dark' ? 'white' : 'black',\\n    },\\n  }).showToast();\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"116\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"When the \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" changes, the chat re-connects as you would expect. But since \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" is also a dependency, the chat \",[\"$r\",\"em\",null,{\"children\":\"also\"}],\" re-connects every time you switch between the dark and the light theme. That‚Äôs not great!\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"In other words, you \",[\"$r\",\"em\",null,{\"children\":\"don‚Äôt\"}],\" want this line to be reactive, even though it is inside an Effect (which is reactive):\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"      // ...\\n      showNotification('Connected!', theme);\\n      // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"You need a way to separate this non-reactive logic from the reactive Effect around it.\"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"declaring-an-effect-event\",\"children\":\"Declaring an Effect Event \"}],\"\\n\",[\"$r\",\"Wip\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"This section describes an \",[\"$r\",\"strong\",null,{\"children\":\"experimental API that has not yet been released\"}],\" in a stable version of React.\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Use a special Hook called \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/experimental_useEffectEvent\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useEffectEvent\"}]}],\" to extract this non-reactive logic out of your Effect:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,4-6}\",\"children\":\"import { useEffect, useEffectEvent } from 'react';\\n\\nfunction ChatRoom({ roomId, theme }) {\\n  const onConnected = useEffectEvent(() => {\\n    showNotification('Connected!', theme);\\n  });\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Here, \",[\"$r\",\"code\",null,{\"children\":\"onConnected\"}],\" is called an \",[\"$r\",\"em\",null,{\"children\":\"Effect Event.\"}],\" It‚Äôs a part of your Effect logic, but it behaves a lot more like an event handler. The logic inside it is not reactive, and it always ‚Äúsees‚Äù the latest values of your props and state.\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Now you can call the \",[\"$r\",\"code\",null,{\"children\":\"onConnected\"}],\" Effect Event from inside your Effect:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-4,9,13}\",\"children\":\"function ChatRoom({ roomId, theme }) {\\n  const onConnected = useEffectEvent(() => {\\n    showNotification('Connected!', theme);\\n  });\\n\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.on('connected', () => {\\n      onConnected();\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]); // ‚úÖ All dependencies declared\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"This solves the problem. Note that you had to \",[\"$r\",\"em\",null,{\"children\":\"remove\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"onConnected\"}],\" from the list of your Effect‚Äôs dependencies. \",[\"$r\",\"strong\",null,{\"children\":\"Effect Events are not reactive and must be omitted from dependencies.\"}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Verify that the new behavior works as you would expect:\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"toastify-js\\\": \\\"1.12.0\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\nimport { createConnection, sendMessage } from './chat.js';\\nimport { showNotification } from './notifications.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId, theme }) {\\n  const onConnected = useEffectEvent(() => {\\n    showNotification('Connected!', theme);\\n  });\\n\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.on('connected', () => {\\n      onConnected();\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n\\n  return <h1>Welcome to the {roomId} room!</h1>\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  const [isDark, setIsDark] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        Choose the chat room:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">general</option>\\n          <option value=\\\"travel\\\">travel</option>\\n          <option value=\\\"music\\\">music</option>\\n        </select>\\n      </label>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isDark}\\n          onChange={e => setIsDark(e.target.checked)}\\n        />\\n        Use dark theme\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        theme={isDark ? 'dark' : 'light'}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // A real implementation would actually connect to the server\\n  let connectedCallback;\\n  let timeout;\\n  return {\\n    connect() {\\n      timeout = setTimeout(() => {\\n        if (connectedCallback) {\\n          connectedCallback();\\n        }\\n      }, 100);\\n    },\\n    on(event, callback) {\\n      if (connectedCallback) {\\n        throw Error('Cannot add the handler twice.');\\n      }\\n      if (event !== 'connected') {\\n        throw Error('Only \\\"connected\\\" event is supported.');\\n      }\\n      connectedCallback = callback;\\n    },\\n    disconnect() {\\n      clearTimeout(timeout);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/notifications.js hidden\",\"children\":\"import Toastify from 'toastify-js';\\nimport 'toastify-js/src/toastify.css';\\n\\nexport function showNotification(message, theme) {\\n  Toastify({\\n    text: message,\\n    duration: 2000,\\n    gravity: 'top',\\n    position: 'right',\\n    style: {\\n      background: theme === 'dark' ? 'black' : 'white',\\n      color: theme === 'dark' ? 'white' : 'black',\\n    },\\n  }).showToast();\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"178\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to a user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you ‚Äúbreak the chain‚Äù between the reactivity of Effects and code that should not be reactive.\"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"reading-latest-props-and-state-with-effect-events\",\"children\":\"Reading latest props and state with Effect Events \"}],\"\\n\",[\"$r\",\"Wip\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"This section describes an \",[\"$r\",\"strong\",null,{\"children\":\"experimental API that has not yet been released\"}],\" in a stable version of React.\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter.\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"For example, say you have an Effect to log the page visits:\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function Page() {\\n  useEffect(() => {\\n    logVisit();\\n  }, []);\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Later, you add multiple routes to your site. Now your \",[\"$r\",\"code\",null,{\"children\":\"Page\"}],\" component receives a \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" prop with the current path. You want to pass the \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" as a part of your \",[\"$r\",\"code\",null,{\"children\":\"logVisit\"}],\" call, but the dependency linter complains:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,3}\",\"children\":\"function Page({ url }) {\\n  useEffect(() => {\\n    logVisit(url);\\n  }, []); // üî¥ React Hook useEffect has a missing dependency: 'url'\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Think about what you want the code to do. You \",[\"$r\",\"em\",null,{\"children\":\"want\"}],\" to log a separate visit for different URLs since each URL represents a different page. In other words, this \",[\"$r\",\"code\",null,{\"children\":\"logVisit\"}],\" call \",[\"$r\",\"em\",null,{\"children\":\"should\"}],\" be reactive with respect to the \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\". This is why, in this case, it makes sense to follow the dependency linter, and add \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" as a dependency:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4}\",\"children\":\"function Page({ url }) {\\n  useEffect(() => {\\n    logVisit(url);\\n  }, [url]); // ‚úÖ All dependencies declared\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Now let‚Äôs say you want to include the number of items in the shopping cart together with every page visit:\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2-3,6}\",\"children\":\"function Page({ url }) {\\n  const { items } = useContext(ShoppingCartContext);\\n  const numberOfItems = items.length;\\n\\n  useEffect(() => {\\n    logVisit(url, numberOfItems);\\n  }, [url]); // üî¥ React Hook useEffect has a missing dependency: 'numberOfItems'\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"You used \",[\"$r\",\"code\",null,{\"children\":\"numberOfItems\"}],\" inside the Effect, so the linter asks you to add it as a dependency. However, you \",[\"$r\",\"em\",null,{\"children\":\"don‚Äôt\"}],\" want the \",[\"$r\",\"code\",null,{\"children\":\"logVisit\"}],\" call to be reactive with respect to \",[\"$r\",\"code\",null,{\"children\":\"numberOfItems\"}],\". If the user puts something into the shopping cart, and the \",[\"$r\",\"code\",null,{\"children\":\"numberOfItems\"}],\" changes, this \",[\"$r\",\"em\",null,{\"children\":\"does not mean\"}],\" that the user visited the page again. In other words, \",[\"$r\",\"em\",null,{\"children\":\"visiting the page\"}],\" is, in some sense, an ‚Äúevent‚Äù. It happens at a precise moment in time.\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Split the code in two parts:\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5-7,10}\",\"children\":\"function Page({ url }) {\\n  const { items } = useContext(ShoppingCartContext);\\n  const numberOfItems = items.length;\\n\\n  const onVisit = useEffectEvent(visitedUrl => {\\n    logVisit(visitedUrl, numberOfItems);\\n  });\\n\\n  useEffect(() => {\\n    onVisit(url);\\n  }, [url]); // ‚úÖ All dependencies declared\\n  // ...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Here, \",[\"$r\",\"code\",null,{\"children\":\"onVisit\"}],\" is an Effect Event. The code inside it isn‚Äôt reactive. This is why you can use \",[\"$r\",\"code\",null,{\"children\":\"numberOfItems\"}],\" (or any other reactive value!) without worrying that it will cause the surrounding code to re-execute on changes.\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"On the other hand, the Effect itself remains reactive. Code inside the Effect uses the \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" prop, so the Effect will re-run after every re-render with a different \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\". This, in turn, will call the \",[\"$r\",\"code\",null,{\"children\":\"onVisit\"}],\" Effect Event.\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"As a result, you will call \",[\"$r\",\"code\",null,{\"children\":\"logVisit\"}],\" for every change to the \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\", and always read the latest \",[\"$r\",\"code\",null,{\"children\":\"numberOfItems\"}],\". However, if \",[\"$r\",\"code\",null,{\"children\":\"numberOfItems\"}],\" changes on its own, this will not cause any of the code to re-run.\"]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"You might be wondering if you could call \",[\"$r\",\"code\",null,{\"children\":\"onVisit()\"}],\" with no arguments, and read the \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" inside it:\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,6}\",\"children\":\"  const onVisit = useEffectEvent(() => {\\n    logVisit(url, numberOfItems);\\n  });\\n\\n  useEffect(() => {\\n    onVisit();\\n  }, [url]);\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"This would work, but it‚Äôs better to pass this \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" to the Effect Event explicitly. \",[\"$r\",\"strong\",null,{\"children\":[\"By passing \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" as an argument to your Effect Event, you are saying that visiting a page with a different \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" constitutes a separate ‚Äúevent‚Äù from the user‚Äôs perspective.\"]}],\" The \",[\"$r\",\"code\",null,{\"children\":\"visitedUrl\"}],\" is a \",[\"$r\",\"em\",null,{\"children\":\"part\"}],\" of the ‚Äúevent‚Äù that happened:\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1-2,6}\",\"children\":\"  const onVisit = useEffectEvent(visitedUrl => {\\n    logVisit(visitedUrl, numberOfItems);\\n  });\\n\\n  useEffect(() => {\\n    onVisit(url);\\n  }, [url]);\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"Since your Effect Event explicitly ‚Äúasks‚Äù for the \",[\"$r\",\"code\",null,{\"children\":\"visitedUrl\"}],\", now you can‚Äôt accidentally remove \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" from the Effect‚Äôs dependencies. If you remove the \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" dependency (causing distinct page visits to be counted as one), the linter will warn you about it. You want \",[\"$r\",\"code\",null,{\"children\":\"onVisit\"}],\" to be reactive with regards to the \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\", so instead of reading the \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" inside (where it wouldn‚Äôt be reactive), you pass it \",[\"$r\",\"em\",null,{\"children\":\"from\"}],\" your Effect.\"]}],[\"$r\",\"p\",null,{\"children\":\"This becomes especially important if there is some asynchronous logic inside the Effect:\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6,8}\",\"children\":\"  const onVisit = useEffectEvent(visitedUrl => {\\n    logVisit(visitedUrl, numberOfItems);\\n  });\\n\\n  useEffect(() => {\\n    setTimeout(() => {\\n      onVisit(url);\\n    }, 5000); // Delay logging visits\\n  }, [url]);\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"Here, \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" inside \",[\"$r\",\"code\",null,{\"children\":\"onVisit\"}],\" corresponds to the \",[\"$r\",\"em\",null,{\"children\":\"latest\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" (which could have already changed), but \",[\"$r\",\"code\",null,{\"children\":\"visitedUrl\"}],\" corresponds to the \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" that originally caused this Effect (and this \",[\"$r\",\"code\",null,{\"children\":\"onVisit\"}],\" call) to run.\"]}]]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"is-it-okay-to-suppress-the-dependency-linter-instead\",\"children\":\"Is it okay to suppress the dependency linter instead? \"}],[\"$r\",\"p\",null,{\"children\":\"In the existing codebases, you may sometimes see the lint rule suppressed like this:\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{7-9}\",\"children\":\"function Page({ url }) {\\n  const { items } = useContext(ShoppingCartContext);\\n  const numberOfItems = items.length;\\n\\n  useEffect(() => {\\n    logVisit(url, numberOfItems);\\n    // üî¥ Avoid suppressing the linter like this:\\n    // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, [url]);\\n  // ...\\n}\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"After \",[\"$r\",\"code\",null,{\"children\":\"useEffectEvent\"}],\" becomes a stable part of React, we recommend \",[\"$r\",\"strong\",null,{\"children\":\"never suppressing the linter\"}],\".\"]}],[\"$r\",\"p\",null,{\"children\":[\"The first downside of suppressing the rule is that React will no longer warn you when your Effect needs to ‚Äúreact‚Äù to a new reactive dependency you‚Äôve introduced to your code. In the earlier example, you added \",[\"$r\",\"code\",null,{\"children\":\"url\"}],\" to the dependencies \",[\"$r\",\"em\",null,{\"children\":\"because\"}],\" React reminded you to do it. You will no longer get such reminders for any future edits to that Effect if you disable the linter. This leads to bugs.\"]}],[\"$r\",\"p\",null,{\"children\":[\"Here is an example of a confusing bug caused by suppressing the linter. In this example, the \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" function is supposed to read the current \",[\"$r\",\"code\",null,{\"children\":\"canMove\"}],\" state variable value in order to decide whether the dot should follow the cursor. However, \",[\"$r\",\"code\",null,{\"children\":\"canMove\"}],\" is always \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\" inside \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\".\"]}],[\"$r\",\"p\",null,{\"children\":\"Can you see why?\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\n\\nexport default function App() {\\n  const [position, setPosition] = useState({ x: 0, y: 0 });\\n  const [canMove, setCanMove] = useState(true);\\n\\n  function handleMove(e) {\\n    if (canMove) {\\n      setPosition({ x: e.clientX, y: e.clientY });\\n    }\\n  }\\n\\n  useEffect(() => {\\n    window.addEventListener('pointermove', handleMove);\\n    return () => window.removeEventListener('pointermove', handleMove);\\n    // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, []);\\n\\n  return (\\n    <>\\n      <label>\\n        <input type=\\\"checkbox\\\"\\n          checked={canMove}\\n          onChange={e => setCanMove(e.target.checked)}\\n        />\\n        The dot is allowed to move\\n      </label>\\n      <hr />\\n      <div style={{\\n        position: 'absolute',\\n        backgroundColor: 'pink',\\n        borderRadius: '50%',\\n        opacity: 0.6,\\n        transform: `translate(${position.x}px, ${position.y}px)`,\\n        pointerEvents: 'none',\\n        left: -20,\\n        top: -20,\\n        width: 40,\\n        height: 40,\\n      }} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body {\\n  height: 200px;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"The problem with this code is in suppressing the dependency linter. If you remove the suppression, you‚Äôll see that this Effect should depend on the \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" function. This makes sense: \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" is declared inside the component body, which makes it a reactive value. Every reactive value must be specified as a dependency, or it can potentially get stale over time!\"]}],[\"$r\",\"p\",null,{\"children\":[\"The author of the original code has ‚Äúlied‚Äù to React by saying that the Effect does not depend (\",[\"$r\",\"code\",null,{\"children\":\"[]\"}],\") on any reactive values. This is why React did not re-synchronize the Effect after \",[\"$r\",\"code\",null,{\"children\":\"canMove\"}],\" has changed (and \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" with it). Because React did not re-synchronize the Effect, the \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" attached as a listener is the \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" function created during the initial render. During the initial render, \",[\"$r\",\"code\",null,{\"children\":\"canMove\"}],\" was \",[\"$r\",\"code\",null,{\"children\":\"true\"}],\", which is why \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" from the initial render will forever see that value.\"]}],[\"$r\",\"p\",null,{\"children\":[\"$r\",\"strong\",null,{\"children\":\"If you never suppress the linter, you will never see problems with stale values.\"}]}],[\"$r\",\"p\",null,{\"children\":[\"With \",[\"$r\",\"code\",null,{\"children\":\"useEffectEvent\"}],\", there is no need to ‚Äúlie‚Äù to the linter, and the code works as you would expect:\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\n\\nexport default function App() {\\n  const [position, setPosition] = useState({ x: 0, y: 0 });\\n  const [canMove, setCanMove] = useState(true);\\n\\n  const onMove = useEffectEvent(e => {\\n    if (canMove) {\\n      setPosition({ x: e.clientX, y: e.clientY });\\n    }\\n  });\\n\\n  useEffect(() => {\\n    window.addEventListener('pointermove', onMove);\\n    return () => window.removeEventListener('pointermove', onMove);\\n  }, []);\\n\\n  return (\\n    <>\\n      <label>\\n        <input type=\\\"checkbox\\\"\\n          checked={canMove}\\n          onChange={e => setCanMove(e.target.checked)}\\n        />\\n        The dot is allowed to move\\n      </label>\\n      <hr />\\n      <div style={{\\n        position: 'absolute',\\n        backgroundColor: 'pink',\\n        borderRadius: '50%',\\n        opacity: 0.6,\\n        transform: `translate(${position.x}px, ${position.y}px)`,\\n        pointerEvents: 'none',\\n        left: -20,\\n        top: -20,\\n        width: 40,\\n        height: 40,\\n      }} />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body {\\n  height: 200px;\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"This doesn‚Äôt mean that \",[\"$r\",\"code\",null,{\"children\":\"useEffectEvent\"}],\" is \",[\"$r\",\"em\",null,{\"children\":\"always\"}],\" the correct solution. You should only apply it to the lines of code that you don‚Äôt want to be reactive. In the above sandbox, you didn‚Äôt want the Effect‚Äôs code to be reactive with regards to \",[\"$r\",\"code\",null,{\"children\":\"canMove\"}],\". That‚Äôs why it made sense to extract an Effect Event.\"]}],[\"$r\",\"p\",null,{\"children\":[\"Read \",[\"$r\",\"a\",null,{\"href\":\"/learn/removing-effect-dependencies\",\"children\":\"Removing Effect Dependencies\"}],\" for other correct alternatives to suppressing the linter.\"]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"limitations-of-effect-events\",\"children\":\"Limitations of Effect Events \"}],\"\\n\",[\"$r\",\"Wip\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"This section describes an \",[\"$r\",\"strong\",null,{\"children\":\"experimental API that has not yet been released\"}],\" in a stable version of React.\"]}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Effect Events are very limited in how you can use them:\"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"strong\",null,{\"children\":\"Only call them from inside Effects.\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"strong\",null,{\"children\":\"Never pass them to other components or Hooks.\"}]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"For example, don‚Äôt declare and pass an Effect Event like this:\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-6,8}\",\"children\":\"function Timer() {\\n  const [count, setCount] = useState(0);\\n\\n  const onTick = useEffectEvent(() => {\\n    setCount(count + 1);\\n  });\\n\\n  useTimer(onTick, 1000); // üî¥ Avoid: Passing Effect Events\\n\\n  return <h1>{count}</h1>\\n}\\n\\nfunction useTimer(callback, delay) {\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      callback();\\n    }, delay);\\n    return () => {\\n      clearInterval(id);\\n    };\\n  }, [delay, callback]); // Need to specify \\\"callback\\\" in dependencies\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Instead, always declare Effect Events directly next to the Effects that use them:\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{10-12,16,21}\",\"children\":\"function Timer() {\\n  const [count, setCount] = useState(0);\\n  useTimer(() => {\\n    setCount(count + 1);\\n  }, 1000);\\n  return <h1>{count}</h1>\\n}\\n\\nfunction useTimer(callback, delay) {\\n  const onTick = useEffectEvent(() => {\\n    callback();\\n  });\\n\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      onTick(); // ‚úÖ Good: Only called locally inside an Effect\\n    }, delay);\\n    return () => {\\n      clearInterval(id);\\n    };\\n  }, [delay]); // No need to specify \\\"onTick\\\" (an Effect Event) as a dependency\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Effect Events are non-reactive ‚Äúpieces‚Äù of your Effect code. They should be next to the Effect using them.\"}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Event handlers run in response to specific interactions.\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Effects run whenever synchronization is needed.\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Logic inside event handlers is not reactive.\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Logic inside Effects is reactive.\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"You can move non-reactive logic from Effects into Effect Events.\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Only call Effect Events from inside Effects.\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"Don‚Äôt pass Effect Events to other components or Hooks.\"}],\"\\n\"]}]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"fix-a-variable-that-doesnt-update\",\"children\":\"Fix a variable that doesn‚Äôt update \"}],[\"$r\",\"p\",null,{\"children\":[\"This \",[\"$r\",\"code\",null,{\"children\":\"Timer\"}],\" component keeps a \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" state variable which increases every second. The value by which it‚Äôs increasing is stored in the \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" state variable. You can control the \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" variable with the plus and minus buttons.\"]}],[\"$r\",\"p\",null,{\"children\":[\"However, no matter how many times you click the plus button, the counter is still incremented by one every second. What‚Äôs wrong with this code? Why is \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" always equal to \",[\"$r\",\"code\",null,{\"children\":\"1\"}],\" inside the Effect‚Äôs code? Find the mistake and fix it.\"]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"To fix this code, it‚Äôs enough to follow the rules.\"}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\n\\nexport default function Timer() {\\n  const [count, setCount] = useState(0);\\n  const [increment, setIncrement] = useState(1);\\n\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      setCount(c => c + increment);\\n    }, 1000);\\n    return () => {\\n      clearInterval(id);\\n    };\\n    // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, []);\\n\\n  return (\\n    <>\\n      <h1>\\n        Counter: {count}\\n        <button onClick={() => setCount(0)}>Reset</button>\\n      </h1>\\n      <hr />\\n      <p>\\n        Every second, increment by:\\n        <button disabled={increment === 0} onClick={() => {\\n          setIncrement(i => i - 1);\\n        }}>‚Äì</button>\\n        <b>{increment}</b>\\n        <button onClick={() => {\\n          setIncrement(i => i + 1);\\n        }}>+</button>\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"As usual, when you‚Äôre looking for bugs in Effects, start by searching for linter suppressions.\"}],[\"$r\",\"p\",null,{\"children\":[\"If you remove the suppression comment, React will tell you that this Effect‚Äôs code depends on \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\", but you ‚Äúlied‚Äù to React by claiming that this Effect does not depend on any reactive values (\",[\"$r\",\"code\",null,{\"children\":\"[]\"}],\"). Add \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" to the dependency array:\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\n\\nexport default function Timer() {\\n  const [count, setCount] = useState(0);\\n  const [increment, setIncrement] = useState(1);\\n\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      setCount(c => c + increment);\\n    }, 1000);\\n    return () => {\\n      clearInterval(id);\\n    };\\n  }, [increment]);\\n\\n  return (\\n    <>\\n      <h1>\\n        Counter: {count}\\n        <button onClick={() => setCount(0)}>Reset</button>\\n      </h1>\\n      <hr />\\n      <p>\\n        Every second, increment by:\\n        <button disabled={increment === 0} onClick={() => {\\n          setIncrement(i => i - 1);\\n        }}>‚Äì</button>\\n        <b>{increment}</b>\\n        <button onClick={() => {\\n          setIncrement(i => i + 1);\\n        }}>+</button>\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 10px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"Now, when \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" changes, React will re-synchronize your Effect, which will restart the interval.\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-a-freezing-counter\",\"children\":\"Fix a freezing counter \"}],[\"$r\",\"p\",null,{\"children\":[\"This \",[\"$r\",\"code\",null,{\"children\":\"Timer\"}],\" component keeps a \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" state variable which increases every second. The value by which it‚Äôs increasing is stored in the \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" state variable, which you can control it with the plus and minus buttons. For example, try pressing the plus button nine times, and notice that the \",[\"$r\",\"code\",null,{\"children\":\"count\"}],\" now increases each second by ten rather than by one.\"]}],[\"$r\",\"p\",null,{\"children\":[\"There is a small issue with this user interface. You might notice that if you keep pressing the plus or minus buttons faster than once per second, the timer itself seems to pause. It only resumes after a second passes since the last time you‚Äôve pressed either button. Find why this is happening, and fix the issue so that the timer ticks on \",[\"$r\",\"em\",null,{\"children\":\"every\"}],\" second without interruptions.\"]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"It seems like the Effect which sets up the timer ‚Äúreacts‚Äù to the \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" value. Does the line that uses the current \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" value in order to call \",[\"$r\",\"code\",null,{\"children\":\"setCount\"}],\" really need to be reactive?\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\n\\nexport default function Timer() {\\n  const [count, setCount] = useState(0);\\n  const [increment, setIncrement] = useState(1);\\n\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      setCount(c => c + increment);\\n    }, 1000);\\n    return () => {\\n      clearInterval(id);\\n    };\\n  }, [increment]);\\n\\n  return (\\n    <>\\n      <h1>\\n        Counter: {count}\\n        <button onClick={() => setCount(0)}>Reset</button>\\n      </h1>\\n      <hr />\\n      <p>\\n        Every second, increment by:\\n        <button disabled={increment === 0} onClick={() => {\\n          setIncrement(i => i - 1);\\n        }}>‚Äì</button>\\n        <b>{increment}</b>\\n        <button onClick={() => {\\n          setIncrement(i => i + 1);\\n        }}>+</button>\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"The issue is that the code inside the Effect uses the \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" state variable. Since it‚Äôs a dependency of your Effect, every change to \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" causes the Effect to re-synchronize, which causes the interval to clear. If you keep clearing the interval every time before it has a chance to fire, it will appear as if the timer has stalled.\"]}],[\"$r\",\"p\",null,{\"children\":[\"To solve the issue, extract an \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\" Effect Event from the Effect:\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\n\\nexport default function Timer() {\\n  const [count, setCount] = useState(0);\\n  const [increment, setIncrement] = useState(1);\\n\\n  const onTick = useEffectEvent(() => {\\n    setCount(c => c + increment);\\n  });\\n\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      onTick();\\n    }, 1000);\\n    return () => {\\n      clearInterval(id);\\n    };\\n  }, []);\\n\\n  return (\\n    <>\\n      <h1>\\n        Counter: {count}\\n        <button onClick={() => setCount(0)}>Reset</button>\\n      </h1>\\n      <hr />\\n      <p>\\n        Every second, increment by:\\n        <button disabled={increment === 0} onClick={() => {\\n          setIncrement(i => i - 1);\\n        }}>‚Äì</button>\\n        <b>{increment}</b>\\n        <button onClick={() => {\\n          setIncrement(i => i + 1);\\n        }}>+</button>\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 10px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"Since \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\" is an Effect Event, the code inside it isn‚Äôt reactive. The change to \",[\"$r\",\"code\",null,{\"children\":\"increment\"}],\" does not trigger any Effects.\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-a-non-adjustable-delay\",\"children\":\"Fix a non-adjustable delay \"}],[\"$r\",\"p\",null,{\"children\":[\"In this example, you can customize the interval delay. It‚Äôs stored in a \",[\"$r\",\"code\",null,{\"children\":\"delay\"}],\" state variable which is updated by two buttons. However, even if you press the ‚Äúplus 100 ms‚Äù button until the \",[\"$r\",\"code\",null,{\"children\":\"delay\"}],\" is 1000 milliseconds (that is, a second), you‚Äôll notice that the timer still increments very fast (every 100 ms). It‚Äôs as if your changes to the \",[\"$r\",\"code\",null,{\"children\":\"delay\"}],\" are ignored. Find and fix the bug.\"]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"Code inside Effect Events is not reactive. Are there cases in which you would \",[\"$r\",\"em\",null,{\"children\":\"want\"}],\" the \",[\"$r\",\"code\",null,{\"children\":\"setInterval\"}],\" call to re-run?\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\n\\nexport default function Timer() {\\n  const [count, setCount] = useState(0);\\n  const [increment, setIncrement] = useState(1);\\n  const [delay, setDelay] = useState(100);\\n\\n  const onTick = useEffectEvent(() => {\\n    setCount(c => c + increment);\\n  });\\n\\n  const onMount = useEffectEvent(() => {\\n    return setInterval(() => {\\n      onTick();\\n    }, delay);\\n  });\\n\\n  useEffect(() => {\\n    const id = onMount();\\n    return () => {\\n      clearInterval(id);\\n    }\\n  }, []);\\n\\n  return (\\n    <>\\n      <h1>\\n        Counter: {count}\\n        <button onClick={() => setCount(0)}>Reset</button>\\n      </h1>\\n      <hr />\\n      <p>\\n        Increment by:\\n        <button disabled={increment === 0} onClick={() => {\\n          setIncrement(i => i - 1);\\n        }}>‚Äì</button>\\n        <b>{increment}</b>\\n        <button onClick={() => {\\n          setIncrement(i => i + 1);\\n        }}>+</button>\\n      </p>\\n      <p>\\n        Increment delay:\\n        <button disabled={delay === 100} onClick={() => {\\n          setDelay(d => d - 100);\\n        }}>‚Äì100 ms</button>\\n        <b>{delay} ms</b>\\n        <button onClick={() => {\\n          setDelay(d => d + 100);\\n        }}>+100 ms</button>\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"The problem with the above example is that it extracted an Effect Event called \",[\"$r\",\"code\",null,{\"children\":\"onMount\"}],\" without considering what the code should actually be doing. You should only extract Effect Events for a specific reason: when you want to make a part of your code non-reactive. However, the \",[\"$r\",\"code\",null,{\"children\":\"setInterval\"}],\" call \",[\"$r\",\"em\",null,{\"children\":\"should\"}],\" be reactive with respect to the \",[\"$r\",\"code\",null,{\"children\":\"delay\"}],\" state variable. If the \",[\"$r\",\"code\",null,{\"children\":\"delay\"}],\" changes, you want to set up the interval from scratch! To fix this code, pull all the reactive code back inside the Effect:\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\n\\nexport default function Timer() {\\n  const [count, setCount] = useState(0);\\n  const [increment, setIncrement] = useState(1);\\n  const [delay, setDelay] = useState(100);\\n\\n  const onTick = useEffectEvent(() => {\\n    setCount(c => c + increment);\\n  });\\n\\n  useEffect(() => {\\n    const id = setInterval(() => {\\n      onTick();\\n    }, delay);\\n    return () => {\\n      clearInterval(id);\\n    }\\n  }, [delay]);\\n\\n  return (\\n    <>\\n      <h1>\\n        Counter: {count}\\n        <button onClick={() => setCount(0)}>Reset</button>\\n      </h1>\\n      <hr />\\n      <p>\\n        Increment by:\\n        <button disabled={increment === 0} onClick={() => {\\n          setIncrement(i => i - 1);\\n        }}>‚Äì</button>\\n        <b>{increment}</b>\\n        <button onClick={() => {\\n          setIncrement(i => i + 1);\\n        }}>+</button>\\n      </p>\\n      <p>\\n        Increment delay:\\n        <button disabled={delay === 100} onClick={() => {\\n          setDelay(d => d - 100);\\n        }}>‚Äì100 ms</button>\\n        <b>{delay} ms</b>\\n        <button onClick={() => {\\n          setDelay(d => d + 100);\\n        }}>+100 ms</button>\\n      </p>\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 10px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"In general, you should be suspicious of functions like \",[\"$r\",\"code\",null,{\"children\":\"onMount\"}],\" that focus on the \",[\"$r\",\"em\",null,{\"children\":\"timing\"}],\" rather than the \",[\"$r\",\"em\",null,{\"children\":\"purpose\"}],\" of a piece of code. It may feel ‚Äúmore descriptive‚Äù at first but it obscures your intent. As a rule of thumb, Effect Events should correspond to something that happens from the \",[\"$r\",\"em\",null,{\"children\":\"user‚Äôs\"}],\" perspective. For example, \",[\"$r\",\"code\",null,{\"children\":\"onMessage\"}],\", \",[\"$r\",\"code\",null,{\"children\":\"onTick\"}],\", \",[\"$r\",\"code\",null,{\"children\":\"onVisit\"}],\", or \",[\"$r\",\"code\",null,{\"children\":\"onConnected\"}],\" are good Effect Event names. Code inside them would likely not need to be reactive. On the other hand, \",[\"$r\",\"code\",null,{\"children\":\"onMount\"}],\", \",[\"$r\",\"code\",null,{\"children\":\"onUpdate\"}],\", \",[\"$r\",\"code\",null,{\"children\":\"onUnmount\"}],\", or \",[\"$r\",\"code\",null,{\"children\":\"onAfterRender\"}],\" are so generic that it‚Äôs easy to accidentally put code that \",[\"$r\",\"em\",null,{\"children\":\"should\"}],\" be reactive into them. This is why you should name your Effect Events after \",[\"$r\",\"em\",null,{\"children\":\"what the user thinks has happened,\"}],\" not when some code happened to run.\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"fix-a-delayed-notification\",\"children\":\"Fix a delayed notification \"}],[\"$r\",\"p\",null,{\"children\":\"When you join a chat room, this component shows a notification. However, it doesn‚Äôt show the notification immediately. Instead, the notification is artificially delayed by two seconds so that the user has a chance to look around the UI.\"}],[\"$r\",\"p\",null,{\"children\":[\"This almost works, but there is a bug. Try changing the dropdown from ‚Äúgeneral‚Äù to ‚Äútravel‚Äù and then to ‚Äúmusic‚Äù very quickly. If you do it fast enough, you will see two notifications (as expected!) but they will \",[\"$r\",\"em\",null,{\"children\":\"both\"}],\" say ‚ÄúWelcome to music‚Äù.\"]}],[\"$r\",\"p\",null,{\"children\":[\"Fix it so that when you switch from ‚Äúgeneral‚Äù to ‚Äútravel‚Äù and then to ‚Äúmusic‚Äù very quickly, you see two notifications, the first one being ‚ÄúWelcome to travel‚Äù and the second one being ‚ÄúWelcome to music‚Äù. (For an additional challenge, assuming you‚Äôve \",[\"$r\",\"em\",null,{\"children\":\"already\"}],\" made the notifications show the correct rooms, change the code so that only the latter notification is displayed.)\"]}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"Your Effect knows which room it connected to. Is there any information that you might want to pass to your Effect Event?\"}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"toastify-js\\\": \\\"1.12.0\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\nimport { createConnection, sendMessage } from './chat.js';\\nimport { showNotification } from './notifications.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId, theme }) {\\n  const onConnected = useEffectEvent(() => {\\n    showNotification('Welcome to ' + roomId, theme);\\n  });\\n\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.on('connected', () => {\\n      setTimeout(() => {\\n        onConnected();\\n      }, 2000);\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n\\n  return <h1>Welcome to the {roomId} room!</h1>\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  const [isDark, setIsDark] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        Choose the chat room:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">general</option>\\n          <option value=\\\"travel\\\">travel</option>\\n          <option value=\\\"music\\\">music</option>\\n        </select>\\n      </label>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isDark}\\n          onChange={e => setIsDark(e.target.checked)}\\n        />\\n        Use dark theme\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        theme={isDark ? 'dark' : 'light'}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // A real implementation would actually connect to the server\\n  let connectedCallback;\\n  let timeout;\\n  return {\\n    connect() {\\n      timeout = setTimeout(() => {\\n        if (connectedCallback) {\\n          connectedCallback();\\n        }\\n      }, 100);\\n    },\\n    on(event, callback) {\\n      if (connectedCallback) {\\n        throw Error('Cannot add the handler twice.');\\n      }\\n      if (event !== 'connected') {\\n        throw Error('Only \\\"connected\\\" event is supported.');\\n      }\\n      connectedCallback = callback;\\n    },\\n    disconnect() {\\n      clearTimeout(timeout);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/notifications.js hidden\",\"children\":\"import Toastify from 'toastify-js';\\nimport 'toastify-js/src/toastify.css';\\n\\nexport function showNotification(message, theme) {\\n  Toastify({\\n    text: message,\\n    duration: 2000,\\n    gravity: 'top',\\n    position: 'right',\\n    style: {\\n      background: theme === 'dark' ? 'black' : 'white',\\n      color: theme === 'dark' ? 'white' : 'black',\\n    },\\n  }).showToast();\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"Inside your Effect Event, \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" is the value \",[\"$r\",\"em\",null,{\"children\":\"at the time Effect Event was called.\"}]]}],[\"$r\",\"p\",null,{\"children\":[\"Your Effect Event is called with a two second delay. If you‚Äôre quickly switching from the travel to the music room, by the time the travel room‚Äôs notification shows, \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" is already \",[\"$r\",\"code\",null,{\"children\":\"\\\"music\\\"\"}],\". This is why both notifications say ‚ÄúWelcome to music‚Äù.\"]}],[\"$r\",\"p\",null,{\"children\":[\"To fix the issue, instead of reading the \",[\"$r\",\"em\",null,{\"children\":\"latest\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" inside the Effect Event, make it a parameter of your Effect Event, like \",[\"$r\",\"code\",null,{\"children\":\"connectedRoomId\"}],\" below. Then pass \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" from your Effect by calling \",[\"$r\",\"code\",null,{\"children\":\"onConnected(roomId)\"}],\":\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"toastify-js\\\": \\\"1.12.0\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\nimport { createConnection, sendMessage } from './chat.js';\\nimport { showNotification } from './notifications.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId, theme }) {\\n  const onConnected = useEffectEvent(connectedRoomId => {\\n    showNotification('Welcome to ' + connectedRoomId, theme);\\n  });\\n\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    connection.on('connected', () => {\\n      setTimeout(() => {\\n        onConnected(roomId);\\n      }, 2000);\\n    });\\n    connection.connect();\\n    return () => connection.disconnect();\\n  }, [roomId]);\\n\\n  return <h1>Welcome to the {roomId} room!</h1>\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  const [isDark, setIsDark] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        Choose the chat room:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">general</option>\\n          <option value=\\\"travel\\\">travel</option>\\n          <option value=\\\"music\\\">music</option>\\n        </select>\\n      </label>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isDark}\\n          onChange={e => setIsDark(e.target.checked)}\\n        />\\n        Use dark theme\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        theme={isDark ? 'dark' : 'light'}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // A real implementation would actually connect to the server\\n  let connectedCallback;\\n  let timeout;\\n  return {\\n    connect() {\\n      timeout = setTimeout(() => {\\n        if (connectedCallback) {\\n          connectedCallback();\\n        }\\n      }, 100);\\n    },\\n    on(event, callback) {\\n      if (connectedCallback) {\\n        throw Error('Cannot add the handler twice.');\\n      }\\n      if (event !== 'connected') {\\n        throw Error('Only \\\"connected\\\" event is supported.');\\n      }\\n      connectedCallback = callback;\\n    },\\n    disconnect() {\\n      clearTimeout(timeout);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/notifications.js hidden\",\"children\":\"import Toastify from 'toastify-js';\\nimport 'toastify-js/src/toastify.css';\\n\\nexport function showNotification(message, theme) {\\n  Toastify({\\n    text: message,\\n    duration: 2000,\\n    gravity: 'top',\\n    position: 'right',\\n    style: {\\n      background: theme === 'dark' ? 'black' : 'white',\\n      color: theme === 'dark' ? 'white' : 'black',\\n    },\\n  }).showToast();\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"The Effect that had \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" set to \",[\"$r\",\"code\",null,{\"children\":\"\\\"travel\\\"\"}],\" (so it connected to the \",[\"$r\",\"code\",null,{\"children\":\"\\\"travel\\\"\"}],\" room) will show the notification for \",[\"$r\",\"code\",null,{\"children\":\"\\\"travel\\\"\"}],\". The Effect that had \",[\"$r\",\"code\",null,{\"children\":\"roomId\"}],\" set to \",[\"$r\",\"code\",null,{\"children\":\"\\\"music\\\"\"}],\" (so it connected to the \",[\"$r\",\"code\",null,{\"children\":\"\\\"music\\\"\"}],\" room) will show the notification for \",[\"$r\",\"code\",null,{\"children\":\"\\\"music\\\"\"}],\". In other words, \",[\"$r\",\"code\",null,{\"children\":\"connectedRoomId\"}],\" comes from your Effect (which is reactive), while \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" always uses the latest value.\"]}],[\"$r\",\"p\",null,{\"children\":\"To solve the additional challenge, save the notification timeout ID and clear it in the cleanup function of your Effect:\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\n  \\\"dependencies\\\": {\\n    \\\"react\\\": \\\"experimental\\\",\\n    \\\"react-dom\\\": \\\"experimental\\\",\\n    \\\"react-scripts\\\": \\\"latest\\\",\\n    \\\"toastify-js\\\": \\\"1.12.0\\\"\\n  },\\n  \\\"scripts\\\": {\\n    \\\"start\\\": \\\"react-scripts start\\\",\\n    \\\"build\\\": \\\"react-scripts build\\\",\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\n  }\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState, useEffect } from 'react';\\nimport { experimental_useEffectEvent as useEffectEvent } from 'react';\\nimport { createConnection, sendMessage } from './chat.js';\\nimport { showNotification } from './notifications.js';\\n\\nconst serverUrl = 'https://localhost:1234';\\n\\nfunction ChatRoom({ roomId, theme }) {\\n  const onConnected = useEffectEvent(connectedRoomId => {\\n    showNotification('Welcome to ' + connectedRoomId, theme);\\n  });\\n\\n  useEffect(() => {\\n    const connection = createConnection(serverUrl, roomId);\\n    let notificationTimeoutId;\\n    connection.on('connected', () => {\\n      notificationTimeoutId = setTimeout(() => {\\n        onConnected(roomId);\\n      }, 2000);\\n    });\\n    connection.connect();\\n    return () => {\\n      connection.disconnect();\\n      if (notificationTimeoutId !== undefined) {\\n        clearTimeout(notificationTimeoutId);\\n      }\\n    };\\n  }, [roomId]);\\n\\n  return <h1>Welcome to the {roomId} room!</h1>\\n}\\n\\nexport default function App() {\\n  const [roomId, setRoomId] = useState('general');\\n  const [isDark, setIsDark] = useState(false);\\n  return (\\n    <>\\n      <label>\\n        Choose the chat room:{' '}\\n        <select\\n          value={roomId}\\n          onChange={e => setRoomId(e.target.value)}\\n        >\\n          <option value=\\\"general\\\">general</option>\\n          <option value=\\\"travel\\\">travel</option>\\n          <option value=\\\"music\\\">music</option>\\n        </select>\\n      </label>\\n      <label>\\n        <input\\n          type=\\\"checkbox\\\"\\n          checked={isDark}\\n          onChange={e => setIsDark(e.target.checked)}\\n        />\\n        Use dark theme\\n      </label>\\n      <hr />\\n      <ChatRoom\\n        roomId={roomId}\\n        theme={isDark ? 'dark' : 'light'}\\n      />\\n    </>\\n  );\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/chat.js\",\"children\":\"export function createConnection(serverUrl, roomId) {\\n  // A real implementation would actually connect to the server\\n  let connectedCallback;\\n  let timeout;\\n  return {\\n    connect() {\\n      timeout = setTimeout(() => {\\n        if (connectedCallback) {\\n          connectedCallback();\\n        }\\n      }, 100);\\n    },\\n    on(event, callback) {\\n      if (connectedCallback) {\\n        throw Error('Cannot add the handler twice.');\\n      }\\n      if (event !== 'connected') {\\n        throw Error('Only \\\"connected\\\" event is supported.');\\n      }\\n      connectedCallback = callback;\\n    },\\n    disconnect() {\\n      clearTimeout(timeout);\\n    }\\n  };\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/notifications.js hidden\",\"children\":\"import Toastify from 'toastify-js';\\nimport 'toastify-js/src/toastify.css';\\n\\nexport function showNotification(message, theme) {\\n  Toastify({\\n    text: message,\\n    duration: 2000,\\n    gravity: 'top',\\n    position: 'right',\\n    style: {\\n      background: theme === 'dark' ? 'black' : 'white',\\n      color: theme === 'dark' ? 'white' : 'black',\\n    },\\n  }).showToast();\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":\"This ensures that already scheduled (but not yet displayed) notifications get cancelled when you change rooms.\"}]]}]]}]]","meta":{"title":"Separating Events from Effects"},"languages":null},"__N_SSG":true}