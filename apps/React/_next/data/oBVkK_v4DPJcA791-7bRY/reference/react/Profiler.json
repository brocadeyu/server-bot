{"pageProps":{"toc":"[{\"url\":\"#\",\"text\":\"Overview\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"Reference \"},{\"url\":\"#profiler\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" \"]},{\"url\":\"#onrender-callback\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" callback \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"Usage \"},{\"url\":\"#measuring-rendering-performance-programmatically\",\"depth\":3,\"text\":\"Measuring rendering performance programmatically \"},{\"url\":\"#measuring-different-parts-of-the-application\",\"depth\":3,\"text\":\"Measuring different parts of the application \"}]","content":"[[\"$r\",\"MaxWidth\",\"last\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" lets you measure rendering performance of a React tree programmatically.\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<Profiler id=\\\"App\\\" onRender={onRender}>\\n  <App />\\n</Profiler>\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"Reference \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"profiler\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Wrap a component tree in a \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" to measure its rendering performance.\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<Profiler id=\\\"App\\\" onRender={onRender}>\\n  <App />\\n</Profiler>\\n\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"props\",\"children\":\"Props \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"id\"}],\": A string identifying the part of the UI you are measuring.\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\": An \",[\"$r\",\"a\",null,{\"href\":\"#onrender-callback\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" callback\"]}],\" that React calls every time components within the profiled tree update. It receives information about what was rendered and how much time it took.\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"Caveats \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"Profiling adds some additional overhead, so \",[\"$r\",\"strong\",null,{\"children\":\"it is disabled in the production build by default.\"}],\" To opt into production profiling, you need to enable a \",[\"$r\",\"a\",null,{\"href\":\"https://fb.me/react-profiling\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"special production build with profiling enabled.\"}]]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"onrender-callback\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" callback \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React will call your \",[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" callback with information about what was rendered.\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {\\n  // Aggregate or log render timings...\\n}\\n\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"onrender-parameters\",\"children\":\"Parameters \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"id\"}],\": The string \",[\"$r\",\"code\",null,{\"children\":\"id\"}],\" prop of the \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers.\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"phase\"}],\": \",[\"$r\",\"code\",null,{\"children\":\"\\\"mount\\\"\"}],\", \",[\"$r\",\"code\",null,{\"children\":\"\\\"update\\\"\"}],\" or \",[\"$r\",\"code\",null,{\"children\":\"\\\"nested-update\\\"\"}],\". This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or Hooks.\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"actualDuration\"}],\": The number of milliseconds spent rendering the \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"memo\"}]}],\" and \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\"). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"baseDuration\"}],\": The number of milliseconds estimating how much time it would take to re-render the entire \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare \",[\"$r\",\"code\",null,{\"children\":\"actualDuration\"}],\" against it to see if memoization is working.\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"startTime\"}],\": A numeric timestamp for when React began rendering the current update.\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"commitTime\"}],\": A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"Usage \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"measuring-rendering-performance-programmatically\",\"children\":\"Measuring rendering performance programmatically \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Wrap the \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" component around a React tree to measure its rendering performance.\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2,4}\",\"children\":\"<App>\\n  <Profiler id=\\\"Sidebar\\\" onRender={onRender}>\\n    <Sidebar />\\n  </Profiler>\\n  <PageContent />\\n</App>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"It requires two props: an \",[\"$r\",\"code\",null,{\"children\":\"id\"}],\" (string) and an \",[\"$r\",\"code\",null,{\"children\":\"onRender\"}],\" callback (function) which React calls any time a component within the tree “commits” an update.\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"Profiling adds some additional overhead, so \",[\"$r\",\"strong\",null,{\"children\":\"it is disabled in the production build by default.\"}],\" To opt into production profiling, you need to enable a \",[\"$r\",\"a\",null,{\"href\":\"https://fb.me/react-profiling\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"special production build with profiling enabled.\"}]]}]}],\"\\n\",[\"$r\",\"Note\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" lets you gather measurements programmatically. If you’re looking for an interactive profiler, try the Profiler tab in \",[\"$r\",\"a\",null,{\"href\":\"/learn/react-developer-tools\",\"children\":\"React Developer Tools\"}],\". It exposes similar functionality as a browser extension.\"]}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"measuring-different-parts-of-the-application\",\"children\":\"Measuring different parts of the application \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"You can use multiple \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" components to measure different parts of your application:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5,7}\",\"children\":\"<App>\\n  <Profiler id=\\\"Sidebar\\\" onRender={onRender}>\\n    <Sidebar />\\n  </Profiler>\\n  <Profiler id=\\\"Content\\\" onRender={onRender}>\\n    <Content />\\n  </Profiler>\\n</App>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"You can also nest \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" components:\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5,7,9,12}\",\"children\":\"<App>\\n  <Profiler id=\\\"Sidebar\\\" onRender={onRender}>\\n    <Sidebar />\\n  </Profiler>\\n  <Profiler id=\\\"Content\\\" onRender={onRender}>\\n    <Content>\\n      <Profiler id=\\\"Editor\\\" onRender={onRender}>\\n        <Editor />\\n      </Profiler>\\n      <Preview />\\n    </Content>\\n  </Profiler>\\n</App>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"Although \",[\"$r\",\"code\",null,{\"children\":\"<Profiler>\"}],\" is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application.\"]}],\"\\n\",[\"$r\",\"hr\",null,{}]]}]]","meta":{"title":"<Profiler>"},"languages":null},"__N_SSG":true}